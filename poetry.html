<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11926b61342eb5c3ba3c24a4cb47522f2c57626a70ca2f438e336874f986fe93bb6fa45a2326aa841c427d206687cdc3ad4cb56a023c1cc2e21a9590c77af814962af233a2586f76307af135f8f366b432719561ce39d422325d045f35ec897790f7a5bc45ea86a0aa9abbe47bca941449f5e073dd5e5380d4392e3cd42307b092146e7e3d7c236ac0607877198dff61cbdda1f7009403281e3c84e5eb31d4a6d73ab5dfb9cabc33bb99f76d0d02f845506a0cb30bd96469d4a22ebd7dbd99c7b344739056ddffbdaa5df2750412ead2998c0ffebedd224b2f996758eaa1c37f1c6ad426a99cf46b8d173ec8e483bdaa3b0aa29296745d21d1b179adcb30e51fd9a5947cc2aeb5255c5e3eebb107aa07c53c30dc8c12ce870c0cec6fc04175f7634d892b4b9dc61345cb302c082fb82379188b16f23e700b913db3060fff1898026b695afa3f752bc0969ddacf30958a80f146f002632374b1529367bdf86b0808831e2898e74295c9a310870d9d1a0c510ff5b5fd0827736b760e65158af711b7a726987276bb7ad52d88d43fb906031a5cb725b8fe87ac90de882914270ef55546d42d6cc926105c4c5a7fdda54de66172fdd517c406900ccd5fee4e96f2271f3c45f1bcf1bf019863625f6acc773b53784d925afe59841d36ba799293c82929d35aa453dbb5dc1e0fcc495ab5aa476bc080039949ee1c92abf268ea28167a9a232fa364015e9499e7c69114955d970dfa4cae8ee610c79f69c0ae5693441e7a119aeb7429dd6d8fdf092c86d3c4bc6f48a1496380eacd8e7c860f729cc6fd642bfbb1df5dc41f1abc2a09752d50acc34d5489a450b2884bfba6e8f301a11e25d9927a31507104637ceeafeb45da0e3d0cc15e4fa5f94b3e11ee80cc89f793671af418a094b5650f98fb4d564f9f11c71bc57893b61f79dfbfbc2ab78d6e245884287635dea8af35a5b0bfe427bb325246708ea207979c13b8c8cfaebdc1b4bdf9caf91c1826b1fcfe48be1b67c290ccc30d94dde78e4e45d20fc51b62a58796e1a79dffd4dd0c156fe7eff141470b584415ee3047de6ec91f59c801cc44bf0f69a485030731704fcbafc5147fc4658256b03d72c6b2854837619c7fddde615e53a998dcc99fffd847ddecb8222651af6904a4a55d0b13c472f8ac60ea1eea0143e7cd674fdb113dea60ec455d9e0cc7e7cdef043e9518819342891a68113245d2e32a9d6a638810a89d8c0fc84770d1238c043b7644f34c0043d8b1fc13b817f37aeba013f7cb392f5c6766dbacb9181baeef2ef994a35660cf637136af86c11d7a8370c9b572f6ad90fdc845c87969b8dd0e1e749761c3193630b2a8d95a68e97afeab7c6ee81191ff1cd3d70e0b39bb83e56248359027fb7717f57d958da46813929e48012b1b8ab6b9631f29aa529aada519ca10e534cd37bbf59ac6c8f7c3eb8682a52af206999cfdb96868b87c605084ab790f860bfef19ddee30f8d39abadbbf2557983694a9594ea78169af9b71913a3cacf2f682a97255f6dec18385b796b40e24777cad3982ecb9ada31c001ed3117d960cfcff36d8e7f042fb5eaa7bbf00c45c798489d0b3c7470d1c29338bd70ac2bf128390da71aa4ddf384fac49cfee75dc02194e62aba82df53d1f381ec88f9d84068af0b71b5ff90233fc2a3c99977509bd1b3cac9b4b40631b7b6b85e4d6d46ce7ec8667924555b2298f9022a87b536dd2a8cfb40d4bd40a16d7aa31d8acf33a291e86d9f0f180a8fa876e4b5ef3b274ce0e62ab21e94d2e4599d24eb1c14af256e0d057ff08babf4d50a29596b69bcc7f1da40b8e40eb41a5ca0408f1398251a52bedc045ac90846f4460eedbd586555e92c841a24eb13eba0283bfb68a2ad2c3b0c7b3a3f11d232161a9905e8ff1203eeb0fbd929637a21e8eced16bf48d15d77ceffb0909ac00abe02155533e3329ed68adf7715458095352dd6361f82b9ecc16bd2635fb9a2e97d9777f1bd5ef3ac2ec54094890316726e188b05f7079e2b970aa11dfff3b697a4803f6370b0830b6cc6f47a7d83738620033f345d1b1de1aff1699f57aa4bcbad6c18677171a850ded661f02a9dd24e7632af9745b56e64f76a7ccc6b075845915947a11af9699997f37eb5f9bb391af803cd98eb12f5ed83d7bb4def251c94197371bdd3872fde7d5b4c515f0f0fa305d40cc76b4826190677226e38f1c943927e5ab5360da700d5587076482b1cb9e44b33d6bb0efd0b53bb4b570824a4809862a45f9f29a1f0906a5426661dec45d0ee230fca177ceb0d1c72da9cdb6fb15499eca6b18fcc2955bf4756f7e257b6c2d06a7aa6d9ccaced211e2758fa5d572b87bf7772267fe7c4b6d87f7b43dd175ba9a89d433af90b6ad88e92a0b992b428aaa7c0e29991574673f093e14517a1943fab75d1b62d4d099316baf712cb98fbbbfc2ede92efcc5ec68ef79e5394522bcdd87a524bb8c520de8017189bcea066827c6a27334f4921e9757e3b0e6b4795b8bc4a334f5ddec203afd1bb406f62ddc3467ca6535f3614c7f4f62128be476819dcf84a2dc284035c40f6721febd004313a985a951b50b15d2bf0766d486296e46911a6eb10ce5b36edc6cf3ec64f40d112be91acdf9e52e42d874aa0f359948e231349e86ce0a99be0b9c4c92e3e3f33a7fab1fb18ee33bab4dbca391ccbd9e454c5bd60c05a828a88105d8c5f651b06fc396df043241db0ad5abe6bc053e0e387dbc1a7ec69b6db5c43cd7bc277d0c2376506aafacec76bf4a1ea7f40e8be91abfea83b86f0769591ca7d02cc775a4db63328e33e60d1eef1e9c1febcc2c33a3141d675d9b55c6f8e4dd9cef9b473688ae44f6683acd3be524c64165465eebf5f810384c19c15cf812bfd24ea4cbf13d708c65d35a593976bc52bb6234af59fa1e6b314199cda5d99d87932013c73a56ba639723e14d69d00c220be6298e7296e0f4b1a6861365d80db156dc467c0db569c4aa297478781cb54570fa13f8d99b19fb4129a4e6b5f3bbea90e942872b16f9e3ada02e3cc4a2568a0516e9e436809d36bd236f4a0f2127f7dd3571f04a970ce8d7409e06d2e3f5d7ddb5d7445e14d699a0401409abf4ad98d2b3ab4566d2088d2ef0267dfc3e47db6f22810d7ff49ad1cda39560584573e1ed942dbcca4b518c6451a792558c7fb8c8af449f96ce68911683392a3b85f18a9b650e20d9815096da2c69dfa1ad2deda3b158498703f7cf2d8828539a7e60039ae10e404abc6d750efb1e6a37dda1497c042e993cdd3f4b9a53b21a6cb40a5c7934e07e8b6b1d0fe4e83c671672311a173f8e29d5f397f25c3252939737bd2b4336108dcca1624de9d7cca479b48564f2b8a075229b43dfa2d6c0f16f54374f09dd7024766ab11efc0c4f15e1c53d32537f448d9f282145d7081b7fcf678e6d1c55d1faccece0d6ac4e017182abf024b99e84cd01331ba2a612bf9725addbc46ef432e8951b95bf76f79ade01632fe5836079abd7433e53c8686a7c079f225fa7c1d5c857b41e36a77464ace1a4497eff1ed695097d2dd9e036b6f7c64a58811fb9779a4e63ebced0afe19ecc49a892e6b04acd05d2e7f512cc622605e35a3cf2ba7f9f90b3d134743277adf87bc11ac878df64111aed44084b8c554042ac89d744978472c3be00e15ddbad8c748eaf4c2212360bf7d73ef798c41dfa795ff19df479a8d3bd90397e62d1b11ad13cff15147e4eabbc8e6d5e22079ecdcd2dd489d538c0d94430bc4aab6ffaf17c35220c971f0d6b77710af85e6830b1ded472a079be98cb057dd03769976e8d5344feddbcb5a97ddc861359e9e204430075a6fbdd3aaca0a355b797d4588883b322a72f4e227fec22d6898eca9009b9fc61c8a4910a0c6063edfb30974f8d8a47dc950c6cc9353387e562a046169ead89e40f291ce09132d771a6c3af77ef4c1ffd213b548fd41cd12960fd81e96eb616a4ce650a6ffd043aa6cd2795b5ba46f072a70f28a917b42a234f8f961884d30a63e092dd03059e3d0e5796e496ee299a870171c40adc47aa936a6976abfdcec0b58b9f4654056f4c86316928cc8ee385e6527a7a1639f1eb1441202608691de70aecdb394e4b82700418c60d78f3c1dbe7f47f62a9d53ace2d8fe3312e02e2f3085da14e185d0d5b12181134f8b322e659a6db934377b587aeaa279cae3031a9580ff68fdd1583b28c97f69a784446e5fb6a6f3984aee763382b7ee0cdc70e64a140eabb237d6d3f766c10c3aafdde5e8355b24be88174bb84a4752b90429b13e35cc92d93e343c91b8d757e7f90385b8db9024c2fd64e65f216517592771d7d53bd2db8d70420b623447772c6bdf3e943dac9526982dd5a17d4ddbec8294a3f9f4b8f1b7fa10a8672acc3b831b322fb82cf151533f14874a8ab5685d8788575bc6ab622f0a42a79193204aed4cf948eff76d2f3a419a8476ffc01b4de22b4de9e1bdf13a90bd563a4393fb56c6e3491247b07b69988b5fafaf8b040bda6605cb74965be5e52c620774d24a19789da9c64ae10f2302a455ec54bda990f04ffb7e0392eac9310c452ac51d7c93e2c03f959a1151c02f5cc410547890017b6c2fba1634f0f43a0dd335dcd4490c4e9a37d43e19da74bd9aa9220120b074daa8ff57cdbeef2c4b6be63094738747475a64574d40bd377a96e66a4e3a9b464b6690cc73b74113e391c4d9c056d245e98f9b2b0f46aff6518351defc9bd15e11a1bdbbd246767f95e43c2a4f2cf48658f36dab70a8ebd708894cda4e33f4b005a61145896f9bc5456cd07b60bb86dea0d9e9f6428fdc33ae90bfa349bcc4a7eac8b17ab170023fe6d898f11cf7a9162254913909203d215a3397cb1a82bb5c9677264a459447bf9071c6db1cb54068a1e05ccdccf95d8b7bf1b38c8ba4143c933804bbb9562661de65a0776c3df7a475e7508538ccbd96c3df78eb7b54b02885a4145f57e017a4fcb2de34405850b0408f83e0ae7e3d48b44e9d55640a0c5cfef17b5e292c5bd346e75771d91a9edf209d5b43087df3909d2e7aa2fd7adbadaf92cf6c75001dd2b80133e450f9adb173403d7e3dd568ccd704c3bdc3c7bc2b3ff28522fb8c0ccd19f71c8bcf88d5ca3dd7c557572af54ca45a55609f3eba652500dee8f55c03745441bfcde57dc096806378498c0269da87741382daaaca06685b5902346b4cf7705558614801c0a72a9ffa2ee71752b3aaec153574dd1bac26d146fcc1492291c47029833a359c12f062a98431842db4549bc65bb7f89a491ad8a4f69bf374392a2da6f9853017f16a701ffcb0039099ae78960e754f6a71a4b37b37159b25d6a017bf8609b3219283a7c65810635508f60440f561dd525e0cb468108ecc492fbab6988cf47ff1369f094084f9706bde3610d28a922474867dbe103bfc9a8053144551393b3fc333258c1af4e9a7ae64f26c2bb3ece13240604485a690a9ee7f26d0451a55d235fd09cce2155764bdc2d17e577b35e7f9463ae964e99f755eada583a826eb43d0a773967c11eeb7358c4abd86a749f4d23cfe9102693cd17ddc6fa02ad8f94b12a86215229fb48cd96e16a13bc366dfde6a523d6d681d0f600680f8bd00babc7b86d5c3a7276c598ca6f38253fd9e2a86800c671531adb4f6bc6f0cefa6613f87bbfe3235180a4f35bd89d195d31f1132074c063a2d7f748338b5d36cadf6cc7c384f8e5f5122e664acc6d21dd4dfdd34d46018dd1c64c21e334af50001ebd775d2fb47b808f421a559b80d51443d488b42f15c106cbc12ae7f61ae8d7313c0677396af48f86a7b3ff5a7e15427e94b4a23a3725fae808a98cf406fd7bfc5461db1aee634752900d406301eba2aac7c00690bccdabacd398de4201e04ac6f13e3f7c281769595a87bff1691f424cfa09ae358d9aa84ff2ab8b424d16ed0546a55be7ccd539f40cf69c9b23623d03a59719edbfb3ff3ba87ecfaa6365cd794abcfc43939c2440057be82952cdd2218e759fad53dfe34364e826b8b7e4e5cb01c292cc51b5dd159966111bf931b5045c1c8773ead4b7d4ba86a67d0f802bfa32893e16d5ecd64229d90c6b2de7092447f0e385523bff798449be526cc924425f99fff7c3853e20ec753aa5685e622244a1db5354acc03ea7521776855013da8da7f75fce0e3ff23955f829a62ee55da11029894e918ec69301a9072201d5c69fa293d3f0e31de712334422bdf4cbdc9430c1a6dd0a5664ad77e7bb73aa6afacd532749de8d5260bb37a9b0fdc1e3419385f67bc779613cc00b692921766dc00d6f22d746c488776aec88ada403fd9c350a3042a277113d60366da4516b24322ffab91104e34b2c632847f0a2198022566a49b0181b73de046c6dd50e43603f40422f7b7a01fe40e94beaad73e69611bd74b93e6a63ecb1b610a5fb4bafa8028d5d8dbbd5f860d31514f17d3f7451d691a570f7cad2c8e7db5cec6e5a724d926dcb45e02725105d8b10579d37ece2817e8aa607212719ecf8f2ffcb5b4f98e53d7c0759b0c7963f4440711e3594fcdb628e4f9de9439c7d4f741bea099b94746049e72bee74f5c21da9408b147406d1ffea0b4405f60d2d7d27411a32a18d9eca16872c413766ab6efe89bc6a549f4d2a89c1658785ae5471a8efa6ea8239b85f0cec64be8b3d3103424e72d7869523efd8e884f9366b9155c2c3ee1a57bc0a67aaa8b3fe8d6052a599c667d8326c01c7ae4b3d8b94589eda6769835908fe92dda5bb23e85db334e06285dcd365b58f11328a76389054ea81dc9ff1f54c60da507e7f64fb992ba8668201d9c5b4bf2913c7fb5d3767b26f425189ccbce76b02b751271f16a25b42cb8ab3fe9284ab3b3aca0003a01584e7bba4af0994da1441223f393711d194f0014aa8bfe2ff7589341c5b96946e329e6e99d0823fee7cc9cc96a6d43e7f71328d2c5163438a3093a16317cc1174acb1e1c550770ccd2e5454cddb7ca9d6e0d57431782092eb5511e68160c2d8c5acedf6d24e1c5c58f3783cfa7416b990befabce0c80b7222a427eaae8591f0e2514c517a7a4b4418a7c690c6d019e3b5b1610cc6654d747e24347d0c6289923bd107b065859666c13f08f791ef57c76d070a1679e68a1d9a96dd63f12c73b18f4e555d5233cdfae389c535d9c94f2b77791b79b9e97594bfbc284222214e0c86c62893e82d4a55cd4bf7063df0d45736ea04691c419e51016d07792f0ebdb55ffc5ffe37d69d2a120763f9d9b773bdc306cac784c447f6d8bbab081f36f1b32f5a1c1d6c1436ec1785a77799643d3a0a42936fc49ad43c8520746c984d9330cad74dc5616f8035362a54b77abcbdd6364d4ebad4c2e4f2a8f52f72cac68179566b44d22bf149660806ea7c378a1251a6a15a2cec289348f1cd0a9d549a62fbe8ff708335ede194dc1ea53a76cf74cc70af841b6d4a25dd86eaedba780559233b3a75c28139f8266af0efdad31c03799f0c2d7dcbec891ea75702436d3149323e550e41ddc735da0fb28223cbd03c4fcc1e665e6d3db0b482e17912b7e0ee5d063f08fa571bfe1d40279a45d0411f40771c68e42eb1daee0783a43a6f5ea69ac4b40096f5de6d61dba36897000f8685425b58402b543ee8893d654c082247db7717b32e17c153e2b81cd836198eaa3eeb23827e8c875115060a48c544fd0047889263a42e0faaafe5285f0bdb85ed0d239d167c2dbc31ba2cd79e5813077168d28e54ce62d4b3e00add50542d255ac359e847b0a130a68122648d3cc92e7dcb5ed4dd3efcc90395dc29fc525d7bf67cbf93ee696ba64c32142efd7522813b79eb5fc600817c42055d742ad79e2a5489576de557da5649557b06b4c5d07ac551f97024fa019a0648cef6cfc13d9cd9571187d6bfa639723c2c348e27670feacc1c7e31286f68582fb085f012e32c418e508c6c848fd317cc2543c8c3115f4ab728b2d06eafd078bbe6e687a65c17db3f1d62d48fadf32802040330319355d09cd1c26862078d8455937f7246e19dcab6437e37997e03a4aeb8f2f0fb37f1754d6678bd300a954c5a0457071e2cf469042a757edcb26a5cf2ebef0b3f235b190de4bebc379a01f56dbe83fef3f45c64fa34914013b7a883bca0fadddcd159c1816dee39126e1b9f231e9d190c2b8f279fc8f8bc2872930e2fa8181f3988bedfc66073b17ad581e3f2ca14e79bad254ae54737a1fe2b1402029ce8a9a5070fa4ba1e0fcc14b3b136f0e082f1fff6ef7872df3c84a321f7eca41b1b72d29f895ae8d3e45e0fb59e912c2ab1fcbf200b2566b99f12ec2430288e7d27d94e0f6ccd6de31a61832ad470acbdf1cd665a26a6e61804078e721f56c6c69eef2c57cc08ab102a54e3f15840f29ad6ab3f99af9051bc23ab383f1ecb19ad2bdc28341e4f005d97709ca3c0aa001284aa0843da8aedbefef184944db53c2e8c1c4869dd5e21e3af5bd52427946fd8ce7a3bd5a36077142bb3102bb32dee227f52dcc5be456ca5e2b30321fcecd74e6f2989e665d269b5a6f6d0fb0bddd1ff808e34419888edc40d3077c13bb1e6d07cbe7117dc4ddb5fe01cece521f5c0fa37b8389256f5cdfba11d018fe338e13caa98f09290a4e5cdc116c1b527916c4ec0e737944e5c31d005833f12b8a5fec685bd0ea1b2cbf69190ef644b35f4bf41b81280735217ce4105ea9d8ff27a1a990d00ffc09d65e5ebea6257aa46418d2e18b42f1e48b1ed7d9d3458dda7b8c77205c16747d60993dc27a4874b3c0447a2fc436f25a64f5c01e83a1bd1b2937ab8cb5269763129af13fe53995c8cf00afeadaa1354c39fdbb60c792916ac2e9d3ec80ba8918c470b39a795ec9fa95265b457ac1cfc090ba0f06290409a25c559b39bd2af795c56341d26d61033abd808b6c38babcedad6410f68d5d283a98cdc69ed09d185512942e6cc9194a46bd57fad75860d3e4bd5463aeaa03179e2a34d6e193d364882d5fb71e0c42a06243034642e4952af3d0836fe4c5b34a2c1ccffc318adeaaf8900c12e9abd00d34bd5209e5d2f70a5c187f3a89425453bc6d9db810da4e5941bd3c12af442eb96a92a186364d16011d771239795ceaa8623f71d240202f418f0a80bfd07dfb4b414006ec587b314b919de009f58345e829ae05e5328437236fe8debe055f2743b299223fa2ff712d8e46e7f0331ef8092b6eee6366e1aa68eb01b7bc000aa452021fdb3a0d0ee0b2834d140ded53943797d28359ce441d2feb664a7dbdb1aac8786b0ff5c6197259246b826ace37bd916515efcbac33d4ebde61bc09e1b31ccd5772f2c832c985ebfb3e3a355c3dabd33c0b7684db788e8cae6266857d88ce133e489038babc22348ed38b7bf02d8cceda5f753d624b8caa9a3a03bad973cbd36b6f21c077db2cbdfbf407872d5d199d7f6cdbe1847522b61689defe4ed78a192c009c9b1b631e4de39a253b6c8d383a254073a91827c800a8a1924e5e3ee33fb977e402318a84ee0f623add1edbd86eac74beefaed31d4ed2db81adbee2475b8b785f571525a4d12228f4c0d1277408298d6c50fb28d93a3b1fb0c1dcc4d28fbb01a543929e8ece4f7810d54c1cbd13fcb5d92becf0ac245535b446bf25b0f428db0a938d66dac999f7b8a35b2628efc448c181b7e740ab42b1375787abcd352ddb32e84acca255c690afb3e0df98c306d2163fd8d22fcb5b53f00df08cc72491118e0d5ce3f00049b3a22a70836013e165e9014a16f2023b2c0f5a4f6557e7cd87d4aed96f5d418e7fbead981fd9578f0ebb57f32a730364ac44da97b9ba8eab845105b04f0e4ded554d3b9178240dd8d25c5b517d317336b9087486438c0efccd7fabc74c7011c2aac015b1e460e788c3dc101b1a06d2855f038a67050dd817887b48f5766997020765fcb216999d90c15faa92b1f9da22e9417e7e84fc7ad4fae0d9382543ebcf715533d8e41f2674bcaa941bbef2cf0c9f7b6ee34b2b0ef069a814b07d5147b87054261699447bbbb71a26327300848d8be8cdc9004626f507ebcd972b88ca86a7098a430b7d145175676e5de67c2bebb719309288b9ad9c3949709c6724fa0419317e562d45606bf119007aadb1ddcbc73bf7ac5a19d2de0ca90f9f7c537e1ff4677b900076c768f9ab2ecd74d97e0a97677680105fbb68327c39fc730620f15cefef415b5e8b2cf2ecfd4eb33b92f842431ef77dddf6809eb02db6a04be8d0f53b1be0e82c934a4c5503bdeeda42215eb7c5245673441cedaa97380a448f4f2cc99ad51ff4606b3b0e0ac0fe6a8ba30e3b7d83cd5a2c6ce86d01fb63d916e0a24353cb696c8df62ffc1eb21f2cdc4686c4810372c5bb87eab404e138266d1ecf07adde2c24a43fa7939a8588a4f175abd7821c14ffca8aca48d11c50c9a1d770d70f47a0b86a5ca9402b5b45207a2dcb12b502f2e447c04248a293706b9ce79bd7438ce0b3971fadb22cbe66fad89ebe78f3caf4babae5973dfe3cc96aa68a7a88e7dfdf93272cb869fefa97e048732a5263bf2a585a24269e72d3f9e3ea87b0f7d7dcd70f6797475e92d14022f73bf2a4fde22690ce0532dd9ed3f36f2c40f766a1de62e90cc63581d9bee78ef98e3db318411317d65491f33c182a6d27f9457e08c5491a28a246dd011c08885301a4f48f78bc5909e0695094d4235e24e7c8de147f582e636f0d5e90a1cf2bdfcd4ecb8aff621de0df6bf74adf7654aac62b2e64ada0733b5819ad50cb514dc5f21e518d601def6ce728864b569f831e385efd6c17b82cf40ec3f3d691ca39da3cfe9433c9151cfdc16e7defecbd011dea58cf998ab593e90d18bfba20d1fca8bc3ba1e44781bf5adfa973bf3044acda345c3490305baa7129be08ca5652715b64838d1fbfd3a1c848f4ec1ab920a7c75aabcdd4c5d3ebbdc6831054b1a8f475700e31bbccdfbc6546c533ec1d39c37a2d62c9188259fecddce24f4cd6a077428b304f421cf0d9fd8848f4c40932506f76d5f5c573f40bbb751f11a5501f204fa18a715f79381db8d86006e4b66985b63d13bfe1f6f0847ee38bb719e1dc05500a7e5db3caf9267d5bfaf35b01219d9fd2660e5d3d56c5731d87d195fbea2bae4aa5f5e129634f2d71216c4aa34597ff2109a74e6005bb68a4339fc4c4f38cf2b2cf481d67ea737d44375f6084fb0bbb77149a38a24141d688007a4264808737da5a0ba7999d3f1ab7cb280530f9e44d3140ebf66e40b49e72670d89703a4c69d0e9a5626f9d573bcb91c65b7f4302b1ff2773397f19dfb9fdad272b8b4f5342a36183beb21b8dc9b513432bfd77bb71a09f8c10f49cde06a5f51bbdb0478d1949043776f1d778ed3be24b728891f44afd333606a690447c0536be423de893e8970a7035fef926c5f07a8e06492955b70fb940527c36ff4ae65d3b817ac849fccc1fbaa3551d2b3522aaa54fab284a8ea297ebea7d03e2702b991761eefe498e2d52415d89e57b00669ddd39f3642d3363a1e80425d7b5e370366b45baa03bf0ecd1a8591796cae656cd48da03b973f7d5466a99b4615e501e5dc653c87e2b9228907c178c053266e30de51e3ab6056c89033a6a1e2a0b1d2841b46eba1b1754fc4866fb0a600bd97229914475cb833e281df2bc06fcd29561fc18b71a3d831927eea7617734d11b4b09cd19b0979632172d4eba2bbfa822369a95fdc630bf77d1abaff1be27503d6a54e55cc00e2704253825b7be51ec165f34a73d578a7e1499b2de897dd0f6f29ddff26935da9cae67bdf182d27a95a9719b01db7192258d49eb108e9146bd52df4ebd783e085c7f6f7c309e76bd9165cbc93e73385451c1d2c5ec98bcd1004fbdfefb25093832dda356a0d4aa904102456989c78b4b557993cf052125ecafbf28abb17269c6e927abfada8f168aff8dd1f4ea3fbc8780f1cbb63ca3b271015b1f240c45b8fadfce5e258224dc0a7ed52f146f17acfb57e156c1a9195b9ad0998f772568b1a976ead3e060bbc854473947093a3824ebe19a787ae1bab08ad9bb203a445f720e77184a16bc6b3ecc28e14aa186f0ed0e83f4ec9f5103028ee7c0f94d7b0944315d5ecb8222f2d71d8e15f9b781ac488420e560fbae28ffd3f0062dbbb479b68d1ebf72f557e8f6afb0e11bc8cb995fd3802fc949a0acf990816c881f814b276237c4fd66fd402d9f957cda2182ebcd574a58bf023deac7b36f0acb6ad3d597635ef4426ce47983b78b03ce42c4b334277b7f8ce64749f069310681b8f4146778d8d10642d0a0689e035dee9ef4fe6a9bfb84780da6543d4fafe78c6e35968b812a79eb25f17ed3806c75abfbf6dcf379362067c794cc563afac816bfe20422a2eb20cef24389433590e7bba23357573b19aab550503df4a93b079bdd318618ebd4d8ec33698608e97755b1a6ef48cc3cef552b2524162c9f09759f1bbe9aebe3aac7b79c518dbaff0a50fcb4d30a38e8c43d8bf41934ca3ed93fcd2cc3a7637871cf28a841ec2c010f1c29eefb49e32bf561253e78f1f4f089f0498319aab2065406409f371b426896a88634bf64bbed77b408ad7695a0a27f779eca268b171d615c8ee69ebe72998b5b8577236612bf6695cbc169da814fb3dabf732de01f3d70a9ee8152510524d9b210ed787bc2c2fa5f2eed9a10d87d5c1bdeec4b156886d8a417afb4b423ee3412afa78d46d162e673911426b3f7f97e3d8497cad9cb00b9b326acf45907661ce039f8733ffc15e6f126defac5909736a6ddfe63e966ae63ccdfd949d525c498892fcc3e23d80983057a79839b776fb733665b390130926cc64e0d24b26d6b6d6660d2ec7dfc1f4adda58fed50fc0ae84dcc9aaa4e705d61727f062f31cc8abe0e4c1d60ac8cee39b52beecb42c3b18816817ba227191764083011743a7a7ccbed6263cd32e8c962df52ce570a6ba764a113e2a1cf53a922be6ca4973a5825136d78bccbf00e42089690937b4c0e03ded5855e7876c38de15ebd91d4e1722399a9b687654394b4ab218be989575c159e87ca7c1b7f3d67189909a7a68ad19ccfc9c2d00dc3bf0efedb89e64e3522a561a2afc1d93aaad217e0b3aa2e6d5b5e9c56fdb5847e9fab3a48fb65eb32589e36fa9f307066cba0612b889a2dcd0ebd37d020ae67be735d805af18e3b2d9a13f530a428ed8727bc03481f9094fe03a731ba244b1cd159c3a31bf04f97618a37db7a6b4d09a7881605d6d069e4a5a24e57059d01fcf02f0cfbce8d9524ec2700cf1d5f76496de105ab692b9f16fda7d1d969b82f8c4b2b59e5779bff09c72507e0ebbf8054577614e89ade89c858e1b03ad4463d8d60de67d5597f1af7ec2c2467020278bd13a98f1ca27ed414964ea6e365d834391f7a83aaf826292fd5f8db2d28381082a7e744e72b8aa6f4992d07e818c8ac4e97c4fe9ad81d62a40d7734e208679477491a17b97aed350f6c70f2432797bc62b16d5fa46c603c0be8f31f680483c512ce9beeb0be243fb7abab01d650d9d31339386ea049cfce304ffc862128962c5098b0662cb63f75ff0f7c1d7dca5f9eb81b4bea17860447ff710334f1528911632d6304531e3b57bab3d50bf978ed70f30510bf2d69aaa735e057ddc376f16d6418ccc419bc71e946fb6bc95c13797e40f5c66a6524e4770c0fc99ceebb6c87213286e63a8fd9ee0422a3dca8a6666ed9e63ac172d09a0184677d07a3e8951c1a6e6f08493b2fae5b42de0801c47bac95ebe2dadaebab3763060b9b0f7c0c907e146d677f0939f7466db147ece9352b49eafd96e1fbf41455d1a8fa4abb3bd82bd8bf534569fce58a9fcee7a9616d417e2a95203478b024577e846965ff17799e43c5fc13f324dd1af6084cd7db671bcccd17d85fe9b74114e78a973e529a3b65bae3020d3fbaefcd30d0449a73b3684393eee6130cd949e2a887613c81eacf97f56d17c901b2a7017d45c168e9448dbc87bb89f2eca60aab6559781aa11ecaf8a27e683e76781be41d323e211a2cf90aeacbd975821b4206deb16e25ab6b1ac2b97d4d7354c144ed72caf99ba0ee06250d26ffede50e3b76e4495049a556a6ec365f331fbd5756f08cef1be217b7c2eff2368b7d771015a901cddd570702b0b11d08cba74266ce999df6ed1fc0d60a39d1f0a179ea1cd174d37876c511dd698ed61d340ee84e0d0708fa2df45afe2cd24cd3895884d0899de211b488337fd8cad12c3202fb1b8eacdda3939318993dc4d77623a1ea0ca83c9bd51c7c3f86cd6b0fe381578d861dbf875ec6cbc40895199dcbd36ec81909547f9f8fd11da8b43be29e1d2fb6e2141a51363d2a513f36d9d083cba9e8d77f2851a2c87c0ac9c72ebaf728dbd65c691896c092afed70c6b1ba3554fa556285e0c259ee181e2750f26503dcbfc1a5d77137cce9674891732205bf0b5d33a6468ea472e91aab21c731b6abeb4c54e2edbab76f7b65706459690522dc8e76be0ebaf904dfab2f4e5eea45cb3c9892cbd3149c920514028a796eb5088add4ff767eb8dee4e4294c9188bbbbbd3867130bca45750fa17270e6f05ea8dc742c15e2f3f003ddadfe7f22087516b00cbae655a2682d17cd58ee0877441f52ce20bd55345d2836dd38317d8a61a4fedf15605ee7355160fa9f496222253f535fe6834d16c546fbd1a01ecb50c40b2ee0485266edab20d47036a87ced89284a12f8952bcfed0d845e17b8adc2ad297f638189ee4134ca3f34d5ccc0c33cb498f991cce33647b719515fb513e9a3f5730e571e476b7a0c91455e4021be520aa1b86fd2fc21fc74a4f9a1f04e7ba57401aaaa925ff3a7a6383e3a9d09a858575c31e35d1b69adf02467e91d5888e37e8427fbdef90a00d5826eb53cf6634ed873d396f6ea532cb9559971127596bcc37965a48939af9512b5a21d8ae4db8e326f1badc9001a780cf9028aadbad226321c5c771a1ba497ce1cf9681aa75f69609db8dbddb0be6b205a126c5235d6de00f80213a6638debac24750283d2e7b0c893328b4f439bee90c7d281509455085ae5f3fd116878f3a3cce5320881772268c955a70607a044303e9fa6133ff151e333d971be2538dae9ee76ce5218dc384b966f6b6f1f2176d8ec857515cd0b7d9f7235de4fbb7e5d8ad44858666e6622d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
