<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24b04df7a328e750c1381e8f66a887c18eb6b600acb421185d4b1cf278646b0e4c5147ea89ba6f205d6408e72ebf6795b2616a6e62af95f580f0ffc9f36c046ae2d1f1b0ea82016b9602bb3a7f4325d192dce329a676bea069e907a578983d0488cb0ed115a548d95018a19f1f78a1ceec5f7a4d1e236b372fc54553e1dba902a84e129fd00ce286ae09539b9b55b1dc71a8187955fb349e39e03bd5a0955ec7e428585750263c2da24d343eff7117546eb5cd5129c1e931e6847599b49196189138c40acdebe6d7f5abc25b457a2d5f51021fe63deca2665eead289afbe3d47da9102a9b63d2e3e8491e5a3d9d93b0ea3842fedffb2d4d35d4b5de7bdd6d3db060ff3699e0950793f43de26e1e2a1a75c4fcadde13dea7f0d892238484152a646cb7174aa9a090e114e5aaf3cf1cd4d175e8337a3cb3d6982bc812d33fe19c40691bf4cbe2d893c454893ea550bf28f18e2d8f7c50e262cfc228aef8e3d146ca9c6c6de3a50be5327700a7e1097e3076c154d0d27d39b52a2e2a32a34a672bf7fe611345ab9f28c00197f50bc73147a5ef288c6b770d62b7b0651630e6ff03a358737397495043083941e760ebc947320d0c43367bfa11ada6104c4fcf96ab9fe401bb4180e4ef51300196a129863524c54b2205e8eb67898ffc722c3b85f1f22a1c5373583193e0f0ee16474779a896707b66b694edf074ae805f4537cdb4a6d36d8e8fdeaacd0ba67ba3229884e42795646d70a5fa73afb176473088fdd9398483dcea691eed64a91e02198e59b647df3d037b1011e962b40ba9445997793ef633687d1a2a756de1eb555963b6750f6199f97ea15a5cc8db785c6f8056af18787b595e93fa36457bc6f33cb9ae0408effebb50f4a06233dd7d62848092849e657d582b2bce103591ded7f9860f98c56a550123e15bd86250dd2f1963745eec1ebe70aae2737c4f8f67d395c494aab03278ee432a1f3f613a659765bb16fddace17dc43a9ee135c63fe356d9377fcec615db211b1f51155ba7dfe7a2a72b8d9ab6ed7e899afcd249cdc3cc680f76087789137b5b95d516b4ef6b5108323c0957a46925dd96c66198b0a42e9033748b5e9e95dd10c728c8af693f2ed600c54f859beacfd3fd0a383749f0daf34a92994ffc7909526f043f495c45c03ec841e8211123bd65f145063032c6d3e1e00839ff6f6a24f122d252259f9f071f025771ccbad314c2ca40af3d5ea84934da2f4b2c977e58ce4cab11014aeb3097bb1b119686a287ad8d0f15e2650883f9cf84d41db2ccc871256fe381a20da0e67045fbe39791d1702703367b5214d7d6cc0e7f16d7b960d4df959daf986c54f7e6b65d61c8cbc588d9a7bf60ee0b92403ba89753b660d785276f453e1092cddb35cb7f8e9d5a06e2e8858cc2e94cd5bb77f1958f49e5fa67e985c6f48068c0f3b7d7f083d7a5cb70cc9bb4788434612621e07165ce6cdce0dcf9001fabb97ffa47aebab9ef0d89d9167d948af891b3d31bfa7b2e2ac1022ab083de9140a09c5cdc29cb7703aa1191efea7ff8c5914b873762149f62e7e1e1acf8ddd4babff66f24df074ae4c608a0fed489548e0bcc1842946466139d40f5e3795748864926eadff9fdafa586319c94d60f8246fb4c3eb62263c603ab10dc9f03aff9ad81ff0827bad7b5c2f6fb5fe9023db275b976d99bd666660f71b312b4a59f5787c5e131c5bac7577fedbfa06c0ccd7cfb947fd3fc536fcbad9b0e519902e94fc9fb19c1a0f444899561d9bc652510c88a8b14546033db261a4c55396b39fa4e2f6f9fb409861fed3997617682b0c7bc15134ff395755468e85d66a3fa5c97488c86921c084086cbfdef5ef4b5d0b9cdb59c5bad1b6711470501973c18b0501cbb1ed19cbba3e70245c0f81661a2fa9027097fcea75486ac5c0be8d0f52edf3fa4f307e7c56242dbf68e8caecfa244abf1893865de51508dee11355fd41e9e47d4e5f9eadafbdacd3cc7549f3739ac92c9acb9e50a6e00992e2a125cdbfabb293331f218fd3a58471b3cbf6cba34f7995d6dae694d415d4b8ab72d44f13dd8708375d92c5cfa369be18e5e99f7856d1fea768ecbaee2ddc0f85b67e2001fb6d462504e96b3cc925153e69be71f9393ec6b21943a6aabba64df1717b14b4cbc3f3817b8391ed383adba1b5dbc1467b19846b8d0857ecc648ce10379f7a8d1eed46d2a42fba36cd1eb8f66bc457d58bbf0667b45558725adf4fc22d2ec60373c8ef20b2637208d7652cd86cfeccce25b2b83230d2fa312d7488416dc1a973759489ac6098be6c8d6860baa6503910657806565efcc880d25e4be866a1fee169582588bf4ce6ab705bafa0501bf25c522cb1df3c5a755fd63f3f250578014eda32d71250c17091c5e5b8f0a6f790f9f2bee58ec0c1c00b9d9cc37f42273b561881fa7e78f37009413f3873c67d822d13cdabc2bdeeed9822bed49b3a0d6e19a8b87fef6af7cecd3374b7c3a3d03f1cd4046d77e9e4aaf6578d5cbd19f3405b0d0cb60d66143de9af47632e0492409563fbfccbbdb0d37100b12928a3001fb92012ea9ab2ebaa9e47976e71744fb00072ab6d503775e2155b8d6159c01393999eed9dc95c82208488fede1a5c2ccce78e0532b3ed3cf75d0adf0f46003a4e81d14b1a52cec900b5cd8556a7ff99369e08af363816f618758c5ea0326c027f8fbe0df668fddd729bb9801c72c608d3ffa788462003050fd144fbf188285cb516a666d0310b0f22f0e043a9cad6e75f48dc445c08d660359942a4f67e8d109a3f3046e41ed83fd68fe203b65a2f636e086186dcb90236e0922a6cbfa2667cb4a6f8abdd08e7830afa6d2b2a76c3c535d3cb18b1e13ed9118c85891a72ad38e4413cd04c648cdc6591cf0a9797f643f9172711ee8ba617965715622ff8e3a92de8c35ec5a59b034c5d93458808cbd57ca327c14fd025941137a6f3f5bd5ddfc2dc82750e054ed3eb52fc8985f4d8120db9e41d1a6795bf6208c7119e743b509ce6cbe074f102554437b55d5a59e1ea2a8c2afe764ecd8c886c1655dab9b97aeef1d1f1a4ad23231a3d2195035243b20b86f2c2d121eb0261f576e9cea69f5b72405c398014b8be81d4cdb59af4c6e40904a70de6f5e9e7e5543d76ce88c0c7e6262c1d5c6a21ce3cdff08eef2084e2aeeff241cd91d28ef1cb34e87c93393853595592ce308da36d75a0b8b1e8a0d714c4ed6029e839359fd86cac448f28405743f7bd727366bb45635038410f7597ec21b5927c34a6e3f2e336d72c5a625af14bdae2c96c0c183ec2b7ed4fafb2d10be2c73101bdc648b8fe821c3f9193f91d17abeba28f7921aa49e15f1bab5f971ce91c53f9ec15bf856fdc60f807dc025504f793f550cb392d3a40415ce7a73d4c196f32df091b6fa0bb8b3fa147e45b30f313c77df613ab97123ce2095911af3472b1d8257572302ff8109cca89720514dc2ffd11fba1597484922b02cda7a7b216704304c825f718268eac5c3848d2b363abb3216f31b50f4be79cd1a539685b9dbb78421197db633c7108bd2ab6b3dfc4a1e5ec95a5d06aa98633e51e8215af8acdffb36ed8d94bcddd3c189664402da639feb52d20a20fe0ce7e4e938885927cd91b9cd597aa7da0cbac2210dc27f9a2890b7d6295b2da94b0fa2736fe989a2d3fdfeb3fe01549523f5115219f6d659fcafc29b8e41150552d795466806ceb03abbf1146b4b25dd6a5f1d9c40c8ee367884ab394c95e474b217137faf90d5cb98a455275aea97c4264e4c370e5c8f120675bfe913bc07f85d1ab20b93ffc35af41769afe40825bdea391a1fcf644f4a33530b77f48e3ac00a32c4deec915e717b5b8a57aec17f3e72cfc3fec811cf503346feb1d070340baefb99546c78fbb5d7b314e1ac2d85646b45fbfac15b581be84f612c8b0c10669cce82f01292342548d38586ff2bf917e17e6b9a56b10fedae2c6d15de6953d228f2a165054f3f0a3b8490d36171d52a56686fdec515881b386877a2a3313ef0fd56379e5d70fb93b6d682e3ec0e69f1f968d9540ce043610cbd8f538c1d97fbce447f714372f0cbbb4b21e9a94bd671bf57016e93c15a7e3664bd911c9a011e4a0f7b55d48dcf5343459ece361a18140b1cbb4a3591cf0576c76797f032e4c931c5c7e69690711ab0c5cbb8bbd2377bffc2f7689097f0e82fb3cf0016008335f71c86c10505e5fccebe213cebbc571a86a829de2a8f02053d05a7985459e4b323042053527775f362cdf882a14d37d9e2b650aed42ebbd73b31bea6b3e85ae0410e4377ecece80895a85767401d2688de9cc24e2e0e6ba4d0b22572d6f00652d1929d9b6cb7a1d071d03e1efe6a9246ccf97e24d2b5df6c723b6d8009629a55ea413879e6f7dd2fadc886c8574d3535aa795c03159fa511d07e5d0c75dd262f55895f9d38cddbaccd804321e8e79515231ef28f029434686ee1ab231e191dac7689bf5d326e1be14d9df870addf191aacc4f38ec3835e2211c57192abe89977fdbe14983eb1a6fc7de5533666f9a3d2cae2e47c6cbcb289aeb8b8e2cb4b3a7e6b81eba356e149d2b8d8fd94e6fa6de159ee6ff802b1b9c722784c45d226fd46449fc53538ac1546dbec127758a7a210cf08ab795e71ca83c0da2b7f816c780ef13486bb5d2557237399fd9edcce6660ff6d5edb7bab2af6ba7565d4795d11071cc30bb26f93c4f1578f3ef693998ddeb6ba7104831f80ede4fa456f36066371f3d7865aab10e31245251d8a04dd38a6e8067cd548d3c0366f30cb1a0a9fec11de55bba094c50a87ad2ae82aaac89b67b0f4076690df572db437996a4d8b773d02b1f4d4685cf8bb66b6cb1dade8285193898399a81f716ba891d992c72172563b45f51aa91f5fd44571335151c107235596364c691b2ab6e02098f82ffccfe7af435d9c8bf5cf6043338a7eac5232f83060afd4bbc71123b490f29763836b00583c968baabed9366972082a0e767c7d88b0b46d8d5c31b080783d53a7aff14a3fd6622100f933dbe954e72120544dcd22ca9eb864523778c12598f388beb3f48e079b6771b9c42b40c52e6042ba541fdf081871735a148a5a9593be6489afc44fb3b209b343b55de03a59a1bff2be720c227a8f83ff29dca8b9414c54e45ca36a124cb0f7aec7049ceec43a986e95375d641a603594a17e22cfa84345a7dfe7fb7477e35f0416f7d3d968819c38deefe51039ed6e026e90fee0ab59d02f823e168bce3796c5a0be0224752f13c93fb97fbca580c24f374428019df37ff3e4f19f3262d3fd0c77fb1827f29b9c60b49da5358ebc0d936d396e81f2b0cc55685960a63f44e8766ce341f069d0fc55ddfd35f2fc0ae324d9598516aec340110bdbedee953363fd0490eeb02522e9cfdd1ac75a4cb28e264b548382b6b1d0000c82568d7536ddebf80737acb79daa5a01f7872c93d380243bad3c772988ace56f5599d92061f0a693ec200860b0cc776177dee22b9d91af76fdd509d3e309f8cbffca731a4208e3d9b04880422bf4195fedcac3a8c882a0b26456f7aebd87905ecb066dd8bebc4c4af73abaf12ea244f6259d22c099dc96b064773ef75564823b6e95ad286903d270bfe92df33813b4b7cdc365faf05a78088c14346b9905d681380f4d44865cf38044cc1c7d9cd842790f9f71ed18ef16fe5ce20011c5ba7ffe93be4ce8a679fdecdbe0ed44e43758360663cb7da6e51af3092ddfa1c9f79987a6d42adda3fcd5e5916c354274296afaa2e168004b9cb903517e94496ce7af5fa42d3eb832cd72022e3ee44a6d311ca26da36f5c146dc262fd3e507cea200cc14e67e55d407fd2027313ec6e1dac46b3b4a6ba21af81c816772343a0bf55049a8f2971644e72af231071129b9ede4d564739dcc5f3867c83eaa7e9dc315eaba0871a9e3beb1a1419c7a28acce3e470cdac6b503671a04f77aebef018419f02e86167478566392f64ad87a1297add8a692223092f4b664da93b3998f36c8fd27bb29821ed4c24f1d38a2ffef9734003f91dd9dc938a51ca1e91a79d028c23dd5ad7bbe4cb87fd7428d7e42b281e6eb9c1fb6f965113c361d848aba737d979ff484dc501c208e98ee52c9670d49462f475c592d35122dfc82b086ada0e8e968ab90657e1e9b260e546fa19e5870b2146f641dfdeb1039f094320f0bea881eb5920e26aa3776e1a661f2a9bb5b173fd1f5ceaa01776ebef7f619b53f35b504caa5a515b55c177e199dd3f13f1bc7db0c882cd6216065913c7963f1e9d3dc6b59427c0fcf8572e1a4407aa8d1ae86d20695384c992671893903bccef3778cd448a297464016269a3ca7d6bc5bc49beaf4e37e5f77acf47fe2e4781d21690b4f0e669b291f1a0f852c855a7dcc33c0d14c81b12b92be65e88060f4dda25f0822f34dedadbb2e3069df5157dbfb95acf06ef42ab2c50f8d79117819857176dc1ab3b0eddd7514ef7e1a83e597eddeb4ab6871b6ec3a746c84820a23c2c3bf3a090812a7efd81025aafc913ad0c0522c9e5e796f3ae77d61c55a7683a3c70483573230fd41b1cce28d40c15ee9df04ee9ed84a19354f7a068261d1e7be04c133df45f4fa3be791eccf090b1382cbc7980201e85632bfb52cda8b4a69de5b128fbc4524e33a7d9890633e9b0032ca9902ed1a781a89f66d1f2fb25c500ec4885504a9f0be245cf35c3b5935643dda3a61e1bc245921dbe89bee6c9215b9a01b81e914781584269df17c5e3113cb99036f59b275b9877edc671e9681b8ae362367c65890a4304514e152ba139cea20039df7eda380cb123855fef98ba15aec11baa15649c75de4a912f92155cca50414a2ce4335afe168b92adb6384bb87102c5ce3998ae25d8754e1017fe46dc7b8f3accaeaba40711637bdf180163d9431e7fb40816cb283368c442d35ec35bd661b11588f0e78fde18991988e25de78aa82975d9eac7d44b7ff813a58d74fd15f9d6db01f40846766e5d4e0a40ee2555961bf08ebd29a2423a6c38fb7ec4553a0f028f0c9bda2bc4bceb0dd9d71ad4584fe0c427466b04a93df870aa0789e13192ed1fdd87094e545815da6cbbfc3b3fa7b67805222124cf285e96217f9fa931506f2f98400b0564f996a2606d93626e3ac0ae6103149e18c42dd02fe0bd5c01fd575f89ca777e1af0c397ebcfc634eb12ac236ef82156aead024410163291262b74870546499dd56e7ad6602f828ba78a1bac7eac64631e0c314266cdad58e51738e9a8da726e21adebcf653cda9d0d28d2f38f1cbb4702f874d31f932a7b5e015cc736e4d4ca4c21011018b58e8282007f663df99d8712991a64f3ae398ea42296ec9d0f0a47512700995f19692b8cd0e2bdba09d4d137ea1ada716659343e92780674c9d3aa6f41c43af8c10ac60b25d987e3a71cdcf3d7f0ff07567904dbbf2d7f21fb30c5433bee8e864f02daa73479c19a3d4c988612c51281b85efec18822c5f83fd4bfc042cdebc248ba0970ffdb281de3b174a93bb8cd0437e3b8bd329764c31043a09edf593866b2b1b4609eb483c2cc085109391f5e3fd9795354a8618be57a814dea174e91f8315c7183a5f367c58c0db9426f1e42964dda3ea2e91bb284b2f6a4dc21a16fa87912e0340bc19682bb89407816c0c906106fd042accf358caf07e8db58699236c7f542a320b56216e8cd7b3b107d02f06d7a1b097d2af807e7a7e4b11efc190aada874ebdd0b21fa955b9905566c6d6931b492d002c70dace7b68f0c7ee8d3923dc354007f56fb1c6204a9562f24c367297139feb3c3bd6f080a95f247d6ace2d1feb5bec4924d15617d5e9903718e4568e0f71aeb54fc4959a6d1efa3caa27de56c02ea5cb2252fc0baa4535782a04a9d42cf62534c6b81778622c02de2cab85e0c9cb1a3ae68197253e7801b40619c7578e2cee9a95627bf105b4ffd27e9dfa35f6b9411b7f3c1caef067aaedaba0d23da175d6c7d42201e721a6d565f19a3002f7e72849a864eefcf5ca3aa9db663309f5e6a69852c16016afa0d3bd882ad659f661f3fe50fe2917fd5f9d961fb31422d51007385878501645bebec9e08e1c4776fa8dc0ee51cbc1d5604faadbe04f05f5a3f97324613b85af142df1a5ededed879a88d096c9109fb4f257b8d65a7358afc8348a9d319f47eefb5062c81338d023ba613fb92e4717b92ce35bb7f02279d979dfaec120c4dda8389ae7e6451a1b576cd224a1e1d993f102133614a6933e76ba06187204cef1e1b0e9bd41bde230f76b394c166b738b67d8a862d2213d18ebe00231ca12432ec0d15f7d3c0aa89532f0f987bcf0a609bda545d8c881006e4a92315ff5660acaf1210ca3f0e964e68c64a4ca8e3aab8b97d87d9760856bea72f17942c4166929eb5b0bd6bb96ce95d55e92d444c6824c1d80aa8c6c7f0189c0f346211f6f740e86867c1ae083313316aef07d7ee155612675f25ffeeba152aa51ef90f1b32230f0171f735d1df2653c8905b0bf4b9c22d4079c5a9d7b5b0119894da8b092103665c1854cf77c3c7df678c233e54519118caf9441204e96006e2a3d3f91326d18dc36d9189557797ba4315c74a098c2b8181a9d1268a15bade439a0f40f05d0c4767a1f710d46d881c3b6b93bc3bf6a354c2de6282628cd3406fd28ad77edccc5021e4740057a9c5ead95cd4fcd4ddee4a999fb08f6f5d37f161a8dc12e82948f7bccb761b79cabfa29c68e2a5d120a5db20a1b9b7a01369bc4fcc7aeca643ce27ad614d23e743f009f2b5c916c1bce96637d22be5a4ae6dfe9b3c2b558d1421ba6fb033f099af5bc9bdea97ce2936d7f9834b7b0a8d86ea4d2856f8da41ca3ef2e0ea692ade25adc4a52659b5cdb64f3b7397f33ee18caec093c21a53e02847c83286fffd8b293040b1593145479dec6ec3b3c8fee3bfa53c6965973ffd6f73e727c918bd05a3276304957051f90739a31719c0a4480b9984043fd74f9d6d6476e3ced88ded33fc6b5adc9f31c5bd3a853de66998af7e3d01bf07938ae6ed35b789f15527b77c8d309a92901ed14929f29976e50697f3f680109703320eb1d04f45ba7549b7cc14fab70c9776bdbefc1c69a5fcd1df7a09551dcc578bf2d7517852af0b92cda58968cd121f665799b07cbafd56a84a3ece2c6a6fa35337d0378ea8a48d7b361ba848890e268ca3921f69338c86aad0fa4bd6e00ff09473bbd6e1dcd2856aa3690c3176da1550b729f54043055451ca7251e2e1f79aea2b949c1a14d2e6c7f5e143a38da05ca0f873cf624b70d75a289808cdc52bff40c5153891f54f1a85982f5de0890c4705eb9dda69f181309389bb643320d89b1cc67741649401b3b19bcb43b51dc99b3969d8774cb5fe0c9390d867ffabf6c6c7a4781381391368f4cc0628504237cbecb0f9d690584363975b42f10bbe5e67fc89b1d331c8f3f47f7bbd02d24a5c5042ae0af7c83b62b3df48df075c22029a1468e529789fdde67e70493728b6500df69246921e6d717c74cd7aa9877578489137d06e4c1573af9540904ccc863bdcbdc8ba5f75d82dacb34f4036057267796746e0aa131c72cdae20ff5c9844e95fe48be8bef27dac39abe01f86c179cdca954ddf730871134fb20f379d8fc91d1fb8c065fde81646003952e8972e60013e5e51c7589e7a3a6466192f0ba6f512fef93d2a7e75ba8fd833fef81d018548588bd0f68d93b5d457085bae688e252b377c4af5395e219b433460bdd14acd72434de7d3985806151e7296b9dbb54fd5a553955dfe18e41475203fd4470929b8dd20698e5a027bbf5bcf0a3cdc89bbed572f148648d5b85b208e09cc8f561fbf3faf174af1b6026ee729612ee7952acfef2b04175c8611698e76f90fef7e844c8089392f2402c187721e2b4dda776f7e52040ce62b2e0ac876c8d381f0616e2ae81ecb335f6bf0001d4f4938bf57a35e8ac99b7f11eff7a274a2ad7e09da704e4851646cc7def499e2acf6c7b364b4adbe94dba145385d052babacdb51eb5f2e6a5e49a0cc639e4f1563bec914b3540362a4bb3a5821239d3e9a9b5050e86cddb5211e169f2336a6a5b1fa3003a386c08f12dae329b17ea85e6d8f23e0d87249dcc019050d5aa9338e0e857afeb23aa3b35776c1783644e5d00d25add8589ebd79b4d023b733cd3f8a78518c69ea8aa84cc34ee4a75936622e328fb18c6ddd30d8916e048040d57c629dd0a3fbed17cf19837880be741fb384b3f3bef4ee58fa1984548745810becd2a2938cde2e9cef928f3176da7e76ee7cb7d34dbd2b3e55ef15f1bd40f2eb71fe993363e97126c363ea026813143790805b3f553bfdf3a2cea9c7912a8cf3c23531a9fac8c8dc8ca0494938f4946702239670d7939764d03563c3b8bb63a28f75b119a322876482e42947564d7e076b10a88c3a240e8f4141cfaf18ac4c5155a38ab09b0d07e6af90be56cf2a7e515daaf681ceaa390417d7d003cf069f12bcac9e6fc3bc5b327f004a18e55f9f3d3b9aeee7c52419f8c812f78eea3738f0d4b19ed0a747d88ab8e21620f213131ed9fd0ffef7a5cffb9d9b27303b6a69d538abfbfac4b9b70ee907dfcde8166b6e809091573eb8470814ca304d7a5455822b197028842771b6e762c408391f9ad23367e40e6a83cf66ba69842ad105bdb6732fc68457102f7a4b2d81f418caf3a4bd848fcfd4a6ea1c00c356aa2adeac08f4895e4ed56ea43d5892efbd987d08808b3b50676d8feecc02d6e420ba846aa5a1c5cd137c55a136c831b3a2964c559215def868499f1eb8cf52c82b80dd31682b7664ba4aacad683e8c5965964c8963e9881b0a99e08be71a3cf4b27e0c73dbd647a5b33e4faedcc6b42da5250e73588e3b8cca9ac813f64213a3f5f11026f0bce48e005c0a700001a14528c8febe8b218fd6c34fbe87f13f583ade8520d10659f0657429e3199865ccf8989a360de42407a4812c625d54ca102e1b67e55c1f70d894b9f440a0c989b998d576aba94ab76460ccd05b89a766d24f34260ef766fc42499150b988d47dc5bc51a9f099c8009839cf82ec8d68fcf24919b143088af4ad2ad3a4e3bc85e497f3509f827282772aea20046fc8a08b8d292b579d57cc754aa26a7965547058fa6249b98cea00451d0e2165689325e42395d509221b776f4c5470c4784e01e8fb848dc9c142ff231960ec12fb549d33f0a33fe0a94d1fa910b9a79c02ddceaa2320a2486ed0080c62202bb7662b038b46466d4e2e9e7b380831a2aa9af9c0ccee16cd3ceed2c8292b2b924d45e41eeffdcba342eb40faaf2b156ca41a11808f8542bd2b634732259b3eaa96e439fae261906c6c72257c642ae006946a0b25a9a7bf7d36423e5e827cf1d7f7d3347cff58dc55f89cc50dc380df774bb48e877e3212b39b227cc625c13236c17daa055d8e8e223e8e9d9e4e476a016fd2de9d4958ad031dc4e5774dabbad55a115adf1062e5650e02b768de689f90e16c3d8b803e0b97a1204f3c4fd2351d75a6dbdbd6b8a268381acbcd248fc97613413545b640286cc5d06d122b04ec0b05405181bce68bb23546977e0de791f9f7ed543c9258068ba740c706b32a594eef7c5ccbcf37a4569ec7a7458f50cd5ad0cfa4085ecbe10b860b7bf03dd4f5c385aaede08a1c50de485c27af33162fb8082ebde5d02cc797ad5306783b2784b9d2a05272eb6cee9d8c91600917f0c72d2b0ab88b5ccbbac4e8fc273be6478a13f559e1d41b0c65a2273ccd9c3f7f918de402f4c0969312287288b7585e5dc8f1674a48c3755bb2c497200ad9cee7b6facaf147d4c7c6dcbb5de536ca4ee6636cc6d61e8682b1f5eb95c539d631e243055f7ea512f1c44232ddbca749ce4422b554a8f847452717136011a9cf054296398ad7a2843dc7bad254b28d9f5897c411d265010005057b7c6ac19b405d9b039cb4bd7132eeee5500db237cf57ff931e7c465b095932495be4cabb5095b1890791599b068e3a6964a7d2b8daf357d41131f46998d7f4e53484a6a5c18dffb8df135c4017dceb7672aea9ad1bbc59e4fdb9aaf5c6ef9a85d13bb9bf5786d5af53dcc7d680faaad90b3e2c564e35b982964f0bf250bd92726d7620e274a2187680936e7722dd87f900753a4778bc26e4a707552e89d946b96ce1f9d32f0c0c0845f697048c3c373bb2ece52b677aa4a834026f43bc23a7844a3de3589d64eaf0fb7ef4a47a5f487a27be42e0ae0de439025a7fde9356fcb174edc34057699b84cc30a0d6d04ed57faeaddee395d80ff4b474077aa4c7eeb3445a246abd46c48aabbb24a7e465c78dd2a9f49715748fff7aae69943f357227e3cb52601dc9ba4e38c5341e142f9ba84e8f7c830f76622cd6c0ea1bcc32a53e5104b1b4c225a182d38180d1402d57359b06606ca7668437f28517e21e6cc030037c18cdb5b1bb7b7b974ead38fc2e752bd5d137592689ed58567eef3a52a4543b9f3b583248c52d5ec4203845a9c213d749a88aba2dbcc830fe67f4bc55beeb43b387098924ca4757b352a81b22e955740ca30c7f211f7de546d1180782302503a9ed6e6afea1f9d4095835af5fb1d14c6322aff3fab020b14b65bdc4d889644d803140032c6bba37b84067f97865b925313cbf9ec486104007acbe8e615998e355509a322c76993af38a6c6babbf84e38247e873015765860581e4af8b693f0b91a401969f682dee835c60c2e7d3563408fed213d53c64e17fc752f2da8423cef9d552fc6e474f854de9a9d1bf4b9a7de29ff299bb66fb4f425e8b31d37518ad438935f7d4044afeeee2e150475b9eccfa87029c11ecb2ef0c847544e1d09a80f19fc1f3360b71c267fa0a61d0ac9007afee1939509068fcee2ff07b5adf34a58e31f1bab86674657a55f25c320d605a8a5603a857a9d5f13498d1624f3270c5e9189b2b97c8f1e98142ede9db2fb58e2e58616ecbb500b520d5d63f4d07c46654ac694130a6e50619981e6da5c46d24a34b146c93eac41e685eb9acf33aef5bd4dff2e31e0532a769a9b4795a460a36700b7e271d601471344394329764b20667482db40ad47342ddd15dbaef9e892ee431b23f3b65c945e26956a95c31d54978bee913174ecd9af6462ebbec0cd6538e12e47fa5517d5b82c1105ece76f279a4da508ec70e63db8ca0652c2e413ddb975678b77c65c6a279bf9713f18764420bc5923512847629dcdbb7c424f70fc88578a62ca487411b11c96d3996a5e1c4b19070a4a732bc6f3ddaf00500d1a894c1a4804c8cd18ac232c9b684632edcee36dad286b569b65a4c49f05bed8041c81eb085ca29959ff655642fec1e0ddab149857507426a21f07e8684b348efce3b733733f35547fd7da67710b6bbb60e8a845e121c9751c30a5cb92c8c83a537646f77d366bbe68b9e56fe267a7498f375493a6c5c8de47eb074bdfbef6f0985402be876d6e9372386e3efe8095e2204fd451d16dda7eedc7eecbb66c9c5921e2c4b4b69094e422caba4d5fa33af9f3001221756943167b7c19e42f4777fd068f810b2854223041952b74f4f74cbec4f6b1773bfa634da128b065c5d1125405572b80ff0bbc84dbe668d0e05a0886866b9e6c412fba718cd1f2aec31ea29889b54af6b9b3bc9044ff6766cc472038227a06f6c3472a961b2bd4bd9315ec67a9e51a8e57b6fccbfde201d60ffbdfae3e908688ad9929999d7268ffb0a6640d95b14e65be4b2eac416214260cd8c58a6f4f1276bb3a14e42310a661a3d5288bc65ebbd3a3eb3b1e8bfa9352eb29dd71fb40198e1e5fe4154626617910efb7848dc55a2b07f97984dee4873947ddc4761e315ad83fd8d980885259f09583bf378d479fe605a2d58aa591374f62002a97007c8af593fe5f8a11944416dbc26debf968a8a5c40850cfa81b2633f8b4e29ed3811564dbad16745d29ae8f9171e082fd0dbba8233af06a129257586334f0de86e4afc1d662076215506ee6712b463ecd40ac9ae9a59a583f5dead2258be2467084902202e66708560a1641ad2270b7b504c73c0ee531b1a1b062a274311000d857b9f40e94fd7a7dd608fe08291960136a4f2f7a78d1f12be377946a25e38293d80cb78f9a55b03cf502c10511332ee750670b6e0ed129d0b3ba5269a07598f594568430040bcb52da1aefc17e1f29d8e577bb1d925389ce100fc10f752330f3f5032f73c3722e61d2f1e4e0afd19c3e1d7f595062b8818d0e8c45aaa15cefb467ea59f872bcdf9a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
