<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6797a27268df3d998942350c7e3ecd6862aed1c8058a57a6c8544b7a2f3a196b4ace087eb3601361ea23b3f28fbd409e6de3b9b2a14f27e0458798f74fb6681957bcadfecd278cde6d5c0ca7952aa97e5dbb557f96f307498d67d8fe4c06366bb72e5f4b83ec70421697a2aceda52621a14ce7135e1159a7c65230890ee82e77ea769ad94eaaac5057af7e05b30a6b7d1b8218c78a2a682b56865d1e002df81f88c73c9b61ae9a92eddc2f6cea7f34b59d639be2e10ca10cb400ea2e03b37d3e53847f6dd6e9d986d94df51dd30e9b2a2fdb98babc250904e433622bbaa7916710f089a9d33fb2e8d0252825e82b3cc31d824ee82daf45dfa87c844b4059ad0ac6141b6dfc3059d93dae667042d17800c48da3a03e81e027f38051a9afd39c9db51806c029eb41f4d7b59193ebe76d09c0c943d5477ebb59cfaba3e80380f9729cbebcba386f9c0e4e2db35dec3ce93196e99128357890858b0f6f1055fca89dda12b7d7a470696a4678ae22a937c0cbe1065e049c3b2fb21dcef66bbeb2b7cc84c59f400d5224c3bb367810cf0400f6a518ad9ae25ddd468062f228b45edb36289c25d1bc2f867761923a77b1b8cc95423a5d0328d0e5f3d2691334895c948aef296b0742c30a1ebd4fb817cbe1fcad5bac12fed563ef9b2fa5877127ae2e63beb0dd227bad203270b9cf780412ceb1ccc70306e38bf43ee2420fe9fadab0770a8588acb04f0cb64e5548d1c09d8f55625c830d6fe894201337ebcb3e1bcde7c1295d7682a122282a423208b86f6811196d377cc439b62fd121d712d0a381c152fe34dd2070284c14f6a8d6ab950cf0324738fdfa3f84022d51d93d0baf3cfde5256d71547f6cd1762413ca429f2978c205f2fcd10fd7a0657564f123b189cad176f2709fb0c77693860013e7ee60d3cb156191528cbae043bd67e7804f71d1fa9d0ab853efc7c49f361b1e462401a00c0c952897ed7b3b56016d1915ecdc223272333a25d7d725f690b797723519a7b4a55e9fd9aabfc742f2c124fd3c508b8992fb80ca833ced50ab43b6b6e1dbb1ce1d718e856a75901532622f2bc7eb0b122415e524da7eca55b278f28e90a752032d9adc7a913496220249c133e85df613dc5e2836197dd8da92199628b5a8229eeeb3d1bc0680bd76125a23c2a0d957d78216eb977140255563f7a9807add5b26ea7b3a75eb541f9cf94be10e611d42ae58f96af8ba2162683e25ade2e7557c17bbd46a42bb527fa225df8d3618f7d2396e6dc5f092db01909f7ffcd0375652e7bf800ad5b78ca5ead63001d376c8a4045a5505642861e003a3cafb30801fb41369b08b623d13dd98ce99322a63204bfb85cc83a4ffb54e040207f5150ea14816284fbab570e6403f2e052b1889bf0f86d7818365de56bc6bbb2da33d42c1c4168ffba2050fae10f5d1ee67c8bcde5dc558265ede46872d9a52f3890f6de383cdc40f2b8e2e7cc0d0aebe4b1f764ce874d9da7cca5e3ae8cf8d2da74792420627d72b4a5afcdea579e63d7608cea34c5d2e01c414911bb29ec7aa86ce27b859513cfb870fb2bcf30db2216fec7fa5716ec70d70be77ad2ebcf17687a7d158e8fa0bb4aba589619e21e50f1f5cba932e1326ffeb8e2ea1944705df27ed81c7808355dabf4582fff123dfdb859bb70ab34f48428121e560bec2105bdeb452a28e1db379e89bac2a192087e27df0705c7ce52df41e08c2a72898ba660fefae80da9d43b32280587837ef64f8c59f751ab6f04945bd9c9ecd35b7de4c2d59377163d5f3a7369d0bc9c7373e1b9a66943ec9c56cd434df5df2b4346eae260380fc3e49535e748c328b175bb17ad9951033ff115933aedaf8c1e134f3e9f4cbaad40911ac0f7ea5d9b4be48c2bfea4009aa31115c3e4851a6c73c03e9e60da7844e49e59b4830ab27ec05a1a792bdc9cfe9cab2e4ebf991e3e84ab7d5f5b15fcf2f5ecb6e90c13d51c572d151ac629e8dec9eec0b37299703005f2c9eb599a360fb93254a00c49910fd8e4eb1712bae916ab4904ac47420c1f4030e0c1f58c0784f742675265ad5bc319e1e933ee029701cb368a1f1c43e7bc6c2b3694aaea08864b2c8029228d8b482320c2b0d3dcf8ee03ff2e8a231189935a7792e6f2b3f595cd0e402432b0a7fd91376d261e595ec6c213b5dfc5c43f2741d2b4f26f5f90e85907541f3228ffe45c18621df160687bbcfe056b2c487075aeb388a6b5679b46b9c6ef3f38384f6b6ba26e0182d0211098811c606c650ba403938e0cdc81e3e4b5824df31d2fbffada518f75b3e028ff47c61295a3ac44376143927cde1979424fac1a3d4ffdad768f83db8c7d4fb25b53a67c5345fca72ff179a84ff4e32f218199f5518b237f4a31aa2cff72d32368bc326c448c007b8138bbb600adbf4fb04afce2c246127e4fe86cf62ef872da3f88a1962c50616350204a6724296baa0ec40d5e6627eddfc6e02b2f51a9d40dcf3bc664153a924691c237a76b420e25cce359d2cbb893b5cb82f72ec89af1019f691136fb691d27855282b2f5761500d2845348e0fef4594980e5de7a5cd03d0ec79f68d90e745c27a866c7571bbfbc13fb972cb87779d4771cf512e640390992b733a3312849ef446859c9721ca10c96dbf42bf60528bceebe5695910053041f9de669a0c49b5801321b064da483cb1395217c35031d877b0bd9c33aa104c098aa821eeb758443e288964e41e57608e4c6576b7c751b0bbf2d77ca1f5033f859270c91c9efbbc3eb2f9caf2f3f5d51f621b9f67fc12cbfb3c67f5a8a71b6f1785fe9c9b543d6136f1621b66bbf00528f1ecfae73734f3650faef6f7719c2335316a6faa0f2e449273c660ababa439fb6b78a8120c3a0877ccdff9f1cfbb0895794021132a2cf816df52811ee4b73b9ddde777073645865be2660c9ca8db2111d4409f620e6e880794d336c3ec3948a72c553b1a1e16331775772de1107c1717a9814356c99b2755787fdb1b147962e1497107a1572399f80914c77cbb1a3b22c77e763fd1e329a8edd7d1c193f763a11d461433f3f57ac62318013e20fdfa932d3c83e71ccfe4aa476054ef8b9eb8a38c80443d2bbefc4fcb8f00ac563b054eb2b2e3e6afa5e9bcd8e4ae0f74c4495975a27da5909f7dd03b82f590b0a57e0372c347b6574c03ea7aae27c16da823351ae46b9cc22bf75e258834cfa11624ba6306a69044bec48cdeee08f93ce50dccb7bd4d8f235146374404ce598006ffdfae24224dfd63b6687016431c65730061b2f27b1bd3bd5402a14ea0e1ccdcf2a80805db7c4af049a8281c9526b635f2ef4666bd67ade93e8ebf31608d7f58b664b7a900335464a8cf016cba74b44c948e897959dd9f64a686658f04aa69ea3a26b9402dc3d6d85b2a34b2ffd21f6d00e8e20daf91fc51ed14c8369adcde5c2a0cb7c5ee170337aac3f6c815b7388b1e1cce7e84dd254d5b266f84f33663c0172333dc30bde48af61701b0de9e37dd83c2583f871cd85f053ff84518efbc81c9a7ed803f6c58ffc018016e7e47e39ba68a6765dfd9816a29ad6fd8d4bbcc43aadc73df2e0802f677a31dbacbf415aa8f884929744e7082e893d600422b5e3e5020ef2801253ece378c5c1d123c598ff903819c85848816722e950d3572d9dadec26632fb9750fcc80e5bed59ca7148dd60fe1ca28af35906f7e6380bf4060894df45cfd9d1721ba4b79080d105e15b271cff72bfd9cd7d594f1332e7ddf0453f30740146aeb5d2bfa39aa019ccf02f34477f6e03a3f868064a429c06e1d484857eae5b9f221673d7485484bea588f9b643e9a3b239c058f562e867d3c138e03435aecf88fedd6944637ad3f93c087d8965e328b098332dafd945083e8ceb32eb89f9dc075937268d0b2023b63264178974545620dd06bdf700f1db73515113a382c21ab20a7d34b5fb292f98127045800025d595fb4a954d9693150056ce998b85db26246ce7ac1e42b09c9b62f1eb93a128102164da5357667f31025f898d27a955e573fc77f6abf4ea29a9d6808cf8c9a4cc38b0c065b5a9fed11ed1c368789d45f0a889612e6e6b9efd762c44d0cf8e9fa81299f7931981769ed97f6a0a2fadcd38bd6bd9043544b33c6883ac62c99c2be8d7674e11f8590d7baa42dffb2532222bcb2a84bec0009197fd2c61150819b6a351cf7b9a60eb0d4fcaff5cb66d8b2c017b2db6ff96f2aaa1d398d3da043704fcca1c39ad4d2d48f1352bb4c9150f76ec64b83b094970afc9fa59888c4eb23ed0aabaefe3063fa2a5e9048e62510c293295f2307ab5265f21a75b391f261e1d14c1694b70dd39e5f2c982891f779da5aa9c0b59d0b760078c2d5aada802f0cd970e31c9b0927014f01a1e536d09d26d6b383e30588fef4cdb8e86b2ccb4bc7d0a1c7507050acef88327cd39a4d0323d818be5fd132b3bc19fc54bbe7ca467b845882ddf5f6ee93d53d787a4aced5eae34f17876ce96a032bc9dea96cb41c82007da5ddf30af76106e333870024fa9b016ab368a8c02fbddaf5d54db84b8cc0cfdf0679ea942610012d67b5c2033ba07413cbe1d3784e480ed737b59d14fc973b07d0be3d455ae74a95cdf1e7a7e8a8cb586c6e6477df5e8eba2b1355d17746c47a5bbc9499b479182c6311f07b5ea27f23f2d1c0736e8990305f2c14ba00c0dbf4a301c9a0a3d5f0a54127b087d94dc96be6014eb490a65010628ce609d106cd70d6e8dd6a1e59e0d6e9e92ba757e033499ccc95479bb785959f0dfc78321988ce9183259bc856c5e5699b5aa5ee3e2169519d609b0cc93927526bcabd15a754cf85526d187e69924670965bf1621dc0dfa4c26e99ea400a8665075cb184928b37667cc9b42bfd0ea3ece9c20930ee2d57bcaa6f81f173dd031d6f578262287f4a0a5c8076126a6bd0860bac2a3f28365f61693e8122c654c9e408a3f75e6f7638373043b0e36c84ccde8d346fa76237c5ba362dc0da80130cc9a2a66c462dac7cc1a874c0b0922ffda2c10483013e0be6ede028c5b3494c3612b621d5c8b4ffd3d02527af8652888d55fc6bd874dff1da3a925e0295e7125f46846c45f55ba7c4708ab9e4045df582f4f76072fc6f2754b29a340fb2db1f1a2bdeeb476ab06edb82829c8fb5d687509c746f8b32a7614fe24a146cd8b1eeaa9a64910104d8fc10b6ff35eac2b36fdafca761624aa648e01600892ba042d66bc1bbc72d8f1838147d6b1fb20b53531a32de736f6f0cb7877f37047f6364ba71a8e4bea912226f90fcb4cab8e37fc33149a4fc4a0062a152937c341dd2de97fb6d2d6770efc620fca7fa0e9e09eedf1729c6139578f0ba9d0a1891c80a8ba5e2207e717f355354a4f32fb13d667b6e4df58a1e1d3c179a6b0ccc0c4243998ca07dd58259f9f0ae2d27527ac91753fa9daf5f0e0b3d2f23aa6d25e2f067ea1d8d67f459e0c9dab54b8a42e45011baba9c4336f06b6383533b38f9af7fef1d2c71a6d95bc0c3918b6dd73219286dc94d47a60692bfaa858027c7ff3dba1a08b11202c2a73826db5c17f7a7b0300e84af138664be064e08993d852c54e5722e8f8e3538f41c781422040e674b3a7523586f48cba7c54c19ff7a45ba799fe451099e48cc9e6f1f17b70888b026b303e32be62bb946c939011d241f814feb4d90fe477700738086169e53b71695957f5f8c20c3818707c9f1dc3481624b3b27a30baf3d0ed09e871cf0a8171f1cd61a9da656da13913bd87522e724c3141860454bc2c55fb421d8371d962692992790e48743b534451698bb2f3d4a1fb0e925728c22b54f7f441c8b357f02890af13792b2a2bfd12cb8e21aa1f799525fd8f887745970a2385f844ac41e796eabacb33e312edfdc5bb33b98795754793809eaf9a605d8323aadb523db2864c5d091cc17d6bca9c287e7ec54c026f1f7c2d6d361711f64eb990e18446a2b115309c4ca591b22a880b67009c4f32ff2d2434a0f485dc0473c64c179cb93b1d053eb5603a61fdffdda4bd1dad95df4b3f884d4ef37866d53a5c6a4faf8688f39f553afdcc3d10b40f480140cbdf725a07b966f2f427623b541a0d19c8c1bd9381ca603d111c33e272eb860acdb0830b2aad5993490ae0ab45c2ee62d5ef3e5bdf6a949f2b388342f97e8929b2b4ead097b1655f6ac480e1503b379f894623ce55141dfdd3422e29b1d3a86959be0b536fe865cb5c4a642fd047f2a10edd88f6dbb37816f00b8d96a32349c2b8f0005cafed91123a2d7454262cd65ebe53ac980408a2ffc14769fb238251f54f6683e4fa97cf4558976e1400fa32f250c73c2087e74e9040fb3deae6f4fed18882ea5055a3f960fae1b9847976c210f4ccaf5c648cbbc4b8f14407f99baa199b005f43b0268f0a1c7dcfc0b5318a0c571b33436767f60290c585b0439f661c307f77127f6ae99b16621f9042bd4fdd72e40847bcb84fc9f3f68a5b130a95e196f986adaedffd33feef3ecac1a10bbf02b8d4b411f546b0ecc5e6e8aed80155951421b3a3549bf1893b8978e5bfb0b5b57610e66e26489b7f3f85c511d04da6563874994ebb97e1acf60de9084261ea4ee4cf2c65c9f9105bff5b221e973820396bf5b370268bbd5ad425b1207a5b9fb0324453bbf739b024db336a6cc1eb16c61ced1a7d152799d9006bdcda7ff782373b0fac8be5bff9b2454d579cc1345b0ed6486da619e2c9adcc3d69c688aeb96a05f6a1a863fcc65e6937502a72438463d420170ed00f959c8da4b278ac36e74e73d98ec574b712a709582242a52cb303446f9d88a2757550baddc12510da6309760c8bded54eeb05aeb0dab9eca730e2488a9be27f12c8d91846b8e69679f08cf8f05352505bf9d99810f8f8f776e9bcb04a99938c03614e1cd169cf8908fa94f49f6330e6dca9748780ab300880ed4288939783e47b0e56d5393da69b2c8382ea6e01f8d7472a0c3cfff7c455ac5a303618fc12cf0e8a57e4f078fb1770e677a8e07016e6523de2e0153b164669dc58b53254ea08ce43ad5718765091f5ca5797bb5e947c9f1ab6d8be6b08851f90caa9db1884f03bb206605ff0528c0423bbf0fae7673156066d7057e6c53730123a893e0206f5b23ff14a8aae25d1ee2ba56fa8c029e3c90c6cbdcc0427c11fc4ba96f20000899e77c6276bef5ba0aef59ebcdc75d55865bc0b8e5e01892e027ec18529d4bb80a75fa91008de6fa121b16ab19a94a78d104a481bbab0ef3782b3b344eefce2296b7032600253defcf3f4eb96705955d2d040a45b78c6f13a5d93eba60287be597ff1a6fb3e02a65d61de94af5bb653a4ac565c29ffee7c732aecfe4a2266ae047d7d0ce508ae78e829eb0e3769f965de93ce9f3c8f8a29b602fa001f9d3b0a67fc13c12d1fa4e213378f3a9f0f6739a4a6a476cf586e1a1b98dbe7f96090433f5530e37805d2e9c75aa3d16ae5286aeaf7047bd08763bb461e1aac8da4689a9ca02b1d6761c430f0d79a669f34f78397fc1f70ab79a9f5ce25602dbe79ad82ff1de78f70d5570da0103ba4fc6c626ad0565907bd9f71a6f6101ec10acd13d5c2062bb44fb97d389b7e085ed8a59375c9dc3b34e13345f6893140c338c2fd2bd40e0e3a780b69adf7a09b75674942ba829b78a140f88dfdba02e2ffa188011681b79b0896915e1ffd78cafdbf86d9bfd19346d397434ed76683e8a53cf03817364d38b62c9d77454a02a45d5e8e38212531cb277d0b4dda4da7e21c4eb251ca4e34c0984a92b0d071220c036b6cdadf01ed808c1778b4769ec52db3804767e745d895b0154f4876c51e087be41d6ab409f834ba864d99ad6d2bca755d58acce3e7766e0f862fb1f0352af3ab1276064039cdec47c4f995d946dd83707057acf275d071751fcab7e9812ac6e003843418fed1d7329154526d8a3ca7f63dbe4e942a70ee7cd1a79e1de9d6a9156ecb9a7110a73d382710e6dde18a58398e4f46d4344ebe56a723ba8b7f988b8c8ab81e2b9d4390989871bd24afcab49e4d3479c2f31f7a58a0c305d2494f5942dbe66f510f3b1b8c11ef7f1cfade08867bd9ab5bd54408c7003b480308bb1b6208cf1f310a0f09ded3027145b195d827d79d563c9ef88df82e8c53cb17c06815fe3eefebf326e4352043cc1d6b7d953db6422d118cfc88bc8ae262fc32bf2e71d0ab58a4391055db199f3e4d9286b87d1b10e899510d9075084d43ea98f7daec9db8ea241bdb8d01f2934ed3e1b1358823ef6b14887ec476b586eb7a3785318ab5ee96abfb112b8d3a87ec9a6cfd477aa776c57cf4896ef6e81e6162e24fb02d34e4d7cce10e243146ad5592a55865ef00b3d41ce555edba8821a9004e234d7d3fe4ba718c86cf611a2c8d94b98892ff93e4f09cfe31f626b30fb169a71e1e5b6c630498d296c172cef40b47a989ee7539ced1d7cbe4999c39d80ae1175d86d2711e3a88176251e2628513ef25721aa7107a1b02fa42034978d12eb0ff3c1f5a2dcd593f5b5e65fa764cbd6fd7077a509d76f01f20723a227da0eac719f7cad1f666b265b6c08d47c14f66136754a61b60987d9922d3a2823c644df94c1e2e08ef7454bdd3915e9a61a8a106fe4c125c18789617604256326cebbc89bdd3e13a7a822cf9be9c186208f30d4189f696d5cf8c5080e0403ff4700a6a5609f4b3b6c331b0a9bb0d7c783c4baa0771f72592cd7f77767ad67f9261cb2f1140c5bae005413f7d47680ed95e2087998384da96f1be65237218afb671131e852efeb12e2a726223fcbaccb868fe67133d7d1b6fb95f217943c493b387e4e93a2100f6f185ff519beb7dc7fe7f7d295e89625ec55fcdebac68c5e3bb17879624927c2682b96b7a7b6ca5f4e8423d44d3f4decd6e4d4eacefaaefd97f2359fb6df849147026a35b114baaf28d385a58fbb6fff341865f84bb2b6789f6599ce864d2ec6e74370913efa173de56b686f9226e5ca8a0038a64e3caa822f48b5e4cd3ea35c22f887337c9fe36987dee9340040ff54ae1bf0a5a0e099ddad567f28e1acd2cb17801c44f4bfbe00a0e0b0a0236c116d3f05902deb58adbd0681faef92078393d308806abca7e3226a4d1690523116aadbccb8e230f5fdda755860a2fc665d3210aa2a91d1b85ed9b469b476bff42847d97161ba6d7d9d66742df75feda43a549bf8306442383574ac15ee1652fe369043545df43034a823dd11c71339ee0f9ced271a2b3e0777f3d183753f44f26a3d9e2f5e3b70201f78cf748dddb0f8e1fc5b6d940df597a57c47de3e6e24fb3a0910625f9d0e4d790c564171338148c49eb29b69e0ae30747da874c2f8dfdfee35d2f41cde0568456bf04834041f3c2bdd9bf501a3399e731d81e2ac0d18f48a4ec69421c4a020b6e6980ce119b51e9884d7db084112930de126c29fec377f3e67936383c19bccae4e2c0589205cbaf2bfab8e47fff83e5b253d8b69842e5a35a7119501213b54b924a4cff2f0a272bb70d1eaaa961770d968ab2f8850f9859e48396cd2147d1a13b6b4a0877adf3daf4a701afe0a53efb003153f79f3febd75d6c432655e385feb7557a316d4e8922c2c13a8af4f86bf58904784889cf4dc523019ed67cac6f0522934a22068c2067837380550bf1cb1db0ac3d0f11214ab3678dc37d0ef44242b94a89b0a80d720886e2addd5879974720420940046aa530d302d547a8cf66dbd0ed373f2f656ec49d8aef0f2ad5f45a34a7bc29a43d499487a40251dd6289cdc0ce5f3454f1977ddcb37e4a0043be11063bc117cb7f477c42970b97eca83ba380e50cd6b05839993212225461ddeb55f6a9ce55def696c274baa6a2ddc99950252336d75f8f2ed87508afb14eb50be38707bef24cec09de0cc3416291ded97b610ba5d0e3cc39a332469caa1e291fdb2735399fb0ced8684d58a418b436f36739e81840c1d8e833c8ef1ba00f7c12941428db777d20987ebf5f3554acf45b2357e83b6ecd0df0a04cd04f59618a2b46e9241115747c7db50f745e2ed2bc0a29993b129bb3d1a8968352b9c6385f2ede88ff02c8c8434aec78e1e91ae73b54058bb73c44c2852b98ead9867146575d5c42a72c1c84d05b839d6b1d3f0d144765003a702c7f6c869eaf10e612edb217f3d1a4b947c59403175d3067ce5a9667bef0d2adf94809c322620db2152ce82f912d5a41c7c336c813bb0a5cd774b041d25707b03ed1e69ab3ed38839222f05035b0e3bac8ab9fff0b90a9a8335434b8f5c772f1aebdea55d639a3c2af1ba316e33a8442cea725a11726d7c6fbd119619591fb1a6cf210b1a4290a38216bc00f9830b9cd5f78d02afb5a2f55a9ea367125a2d6f620660496b5165864c039b03ab7e14de074c9a1bcb2b676cf12772373736d36700bb5c880285148f12c7f076fde42d168ff205e3005d56b08e3d138e95538d3e1d709c477e92127218bb159d2a0ec83eacb67f42e4708d2da8fb96facbbdc729286336dccbf946f7defa72703fa72936a2ed1a08aa44695d14f13b95baf6c2df3038fe1bde5f88b0dadabc85b903d85c9d36a7d9e7700881b573e249ea2a68124aa6a683de7269f44b2795c116f2edfa57a126995afa2002d9c28a157638059185150fa77a30a2ee1ad156829bc7422d3b1faef78d1842794f3aab3dab0670d9e0391c6e80d8373dc3d86d0320d3a55bb3e61af817761f0ce2e0a1e253c5e06b9cfdec45b84b63f9f645eee2b59154b5ae0d3871bd288e998e5d74d7174724197e895297154f66022a2f36ca935ee711c18f6b382f5bcb5a024b8b1a8d33261c84b8b7feaf926787c483eda2c0ca90567a32f44c4fc5dadf56cfc51319031c2ec4b60c6b69e856a47a4e7139bab639bc5f999d641e5df1f035cb594ba8e969e4787621b0982677e5d1e61f1ad3dbb2a52b28b02020000675d815e4a4bae2d605dfbf34a81a855f02958a912ccb9f83db21bbc3acdaae290061f1d0cb82efd370d5d51907aa0f681eada5435105dfd8eb86dfd12210a766eb122b8cbde4480f8e083901f702c8b2080d6602832c45bf3c547418e41ea2b300caa9bdec5ea467b7cbbe3d25b871a5dff55cdc3947f469354b066feb0daa080f8752adb8391136233bb3a664cbb5135aa99d7e3e68973dd6117a03ce12774ef4634347b8cc9b29b5718700fa7df8550183aad0307181d5e400de7bcb1b5d97a2027df8b4c521438f67c7df8f7c2e144a56651e9943eb9be23cb5acb955a453ace43fad9866dd467ac416bf52acf170f911fdb99a0e796dc0f07d31a25335ea3efeac46e50cdf4adb596d01887d4f804cd6218f7e9d82c77a1c7a52d8faa5ca7344eafa89a06e5b093cf2294036fa953bf2169347b70daf93a1ff1422487f6995ede27ca0675c159727f2c1909cd78e1763ffc76a7daf3de8d0f43bbb7f80e4405c2b5f98c57fd90ab0135246c54c5a6997da16b35e510e8c477a1204241bfe01febf0a7c6cafddb81bf1322ea2ac1c8580017196f747916034edb02e646e195539e7ab8a4a1cd531f6001f6359ba48cd3ffc68a989309ec230c39433b20cb39f03fa835797a9215dd1a7e5f3f1cbbd089e6c0658360b16d7632bafb2cd52c363177526168529a21210083153ba86729304a4fb596a66efecc35883dae02452b305e759924f1ddd5aa6031e38644c7ccf07346877d62c56b1ae958af231805a247e7a91bb9d0bead4e5d0efe3263ab1960aefa624cad7702e688341cd3ce1cff6793f9e684916678cf270f86d0f665a87041b1a2622e09f3cea395e0c18f5873f1eff4b3397a2c1d3e2a694cf711bc3758751440a21d73e5a463da097a25b74b42102461211b0076c47b4146e18fb874b3252a2fe14fe2f47a0be616a810006e9ffa28d384796baf11883dc69d70bd49bb399d0667d58ea0f9f4f0981a2ad6a6925c3048f7ad4afa4d04fbec9d33a4d0669ef2267c7532cda5228d433073930ae411f85cf603c8d97d979a8649c47b0a339619a1f99f9612fe51e899fb35c1f56dc0ae29c3224e24a2391361316d2147896baa3b39c91a611683e40dc1112192066ccc6c8fc74ea847949e08ef9005768c097fe1753125b58057e03c2b19d1a0641d23f99e3b406135698aa55e7937aa6e3b867f1e6c413ae08e54a225933b8346ae0a449d130b3411508dd2737dedccba5e1ddb6f37be20ce5d4bced2950f76142a936c1e0c44c63d882b4163bf8c724b15e1138d0250670dd88ff375fa3d86d1d94786ed6317a73392cf42db993b64dc5521723a5a2d38e5d1b2fca388cef562185d62c461a00ae530d33e8a129943b5256d6c4ec99f52d03e1fdeecc44a13e9f73a5f48914acf66019260705fcbe0bc981a129b008746d37fbb14f617d4e81f396b48a135704a94e18044449bd7f469d0220157f6e495f20e04430e6bd45c46e11ed2ce5c7d2d0dc09bb674a94bbc2a2aa30c60592e284e0c3b1de7d3ac1f1a2af2cc7c98e61ae89aacda368a845b5403f6bd31ec8db52ddcda84967b14a554eb66eee90bad5011155f98dca47ad0c8f44fc1c51543e79228d26025a687314c4ce5cd8112cabdc808d6ff38c883c93789ed28660d4050916186ebc41ee48774481b41e44cb25cfa0e7f443939c43408ff4ac194f40b165c5f374a9056a94d4cfcbd680a1541cae8993387431107ab6906fa9a0f176125b6a3c188c8568513cd7381b4e37eb5b099dcf65508c4b15bdef1107041dcd0b9f27af6e6584bba9fa9254969502866ba3cb25947b273dccb8dbce07d9a96591cb41705c9cd65822605d2736af68cdc60caeb2ecea35fcf0c1c6611b51e062664537657ee90e285199401ed94e3858c33364b3a90e94c9728bc648c94aef90ecce770572b13c374a5dc2576fdaa8484178b3f878d00b16059e31fe131b92b8ed570033a12833c0da2694b5f709f785ac6c7c53856b0be61967ae94cde70978f0c01ae8b242bc6d96461499660cd5b3d1931f681e50b50cfda94e1c1f513a78ce4699239cfd0d25646d738bb2c9d4c12d516baa715842397cbec6f6254e209bdf82942b2b9cffb8471de77199429e77e8583af0cb5aa416e5512be6041587b8c46cd9dbc96bdb2e4b71002008b0918bbfb86c608429ffda23a364ac93ab148ad832d7950a8d0bb373fcf153da9c9a082a1f0a1f5bfc933d18f5a0c42432c8952229bca87735b5ee93d126ab43df4d1a7483619669af3bec76d61b4230c92767a14dcd619681f20e47272e45f74dfe04294a5f19cbf7f918bccb12fdb26f102154e45b3546f30381c51839d93c1c76023ba14f46dff4cd2c56a71c440126fc4104f5ee74d39e29fbab65c84f59991321240447e40542722131be3f5bf219cd0cf23c19d41727e7f6257aac73c195ed4dcf4e133b6de8a212ac89d0a92bb398c2d0601c254c646a3fe9c317e3ce054abb8353bb176b342f6acfd836d94463fa7cc27814a0a2022de0fb6f7346e743ca8e914e2ff4a899ec4e8e094ff49e508749351133990f43d151bf0fb91df0ab74856de4c842b09df55f9c15517754d557a85cc534f635619aa1a12d25821283a9591cb85c354c4a2b677f8cc003d7ddb088dd25b3851c13f3726fc7dd284d2e2a08f7aff0f215f9f22a15f2f8bee502e3670336fb2f462eafe3322d99b24a0fed990e3ca39e076aee8a152d744192b88221ec118dd326d045ae27332ce7867f727752c86e773a5b94cf77f9e2363cddd1a4d4551f046ec61de9ad8e5ba623819b5db5ef5f9ceb0bb9da2caf985c951b471c66e6d04ea04bfe6a591283fca00a2b271743530eb8de3903f553b423ab15ee323c775c852cfaf2c57fdc4c05fffd28895437fe6b328b96d6e3c6bf6a0b565146a10c3f7323133c426a4fa3e0f4d4a64226d4b86be33f74e6aae2f7d1ffe4d2067b72937796f9c0e4214c71114f1636af597c655635cefd4d194509ec5cf2bc43b30f03fed8a021a8a0fe33716523b1f445da2c9224e92d7c9332020e12ee43aca90c1e74fcfd23416149a617b2c5014d65a0a049dc443d43b7c31a84a310d520570b387ad576b4c011598c6d7e2d380c5b87aed5b4dd512d30e5c40e392c345cf4ee9afe9a214b90fbb5420212c250daf81f05e094e7db41df3b5d190dbbdaef38bdbd0e9a778261ed3fa29088d2373ae8678f0c9df21e41c1ded58cef1cb0bcd748c881eebc9d299609fb2fa46bea288b91a268daa08bfdde8e0cf2fc35e3886ef3d41b7b5de02cb6a42f559e528b35c5c13e07c214b21c008521d0d9457cd95e315a367fa8a9310530000a1e424b5193ebb2d0d0623145d1fa6bba716c9916002e8cd066fd5f13794276cca549d61e960905eecbe3174f53c566028ff5804c65b7a096bbd8f009b336f6e901da3c942c88db61f52acbc7063e8fd6330a30a1ba223eec16e6582719a85859d8ee7d98742663449f04360e3754d4a3b61a5a98bacf096d7c4aba3311b022a3765aa2ee085c9e648289d44f4243750d8acd82d1351a0cd6205d5a0ef090854f8e5f5fcc4c10f236e1e46127789e3283a6e86484eb150dfa7b8b57147736c8cc2aba1f634462e67dd4640295ecf4b1fb46fbe98d526bd70883cd529543899219be25a6806c0b103cd6f2a8d96f0b8068cf15a96e92aaa9e52594594b62ed355ffbb76199a8610c6d7c5d2e7b5d6cd99bc2e39def81fc84c0ae8cf2f56db2d17a4ffd0b23abc0602d0d4ba9febd708ec97405cbcd55944892b10fd1ca0c017ec2d942c0b8a6d874a5580a10ad813aeab465cad439d54ddfa7d56b06b38d18992edcb61ca7606dccc8bed88b7222c119a7e1790398f299499bed1a89df84d9dc706b4462ceb5abd9a8629f55fcf652fcfbe2185193938e6efad99bc7989e70d7f8822f7c2d86c282fbb056c42247d223a733dd58c9ffd6c5910a915aa498293a2e93e9fd9b04cc5a22e38b7da9531f70fa6c855b01bd1337442062eeec904f80af09fa128cf59c0eafd69807982f924a2614993c4bee8188006236e81702fbac7967bce8e8aff1449554a92a2ef8621ea33ece45116d302bdaa737b2eaeabc2fc55ec73e15aa4c306c2956574dd556e79643e0c8f305261a9ab4afefdbc55dbecb83904387b5f37992e93cba2ac7c478acd20b086a138f13bce0e1a0388b8c6a508e0b00ac24e2987d5d5aa6dbf99a1dcda0ef2223ef8d92cc8a4981c2cf8ccec519dfc6f098923173ead813de27a7756c541dd9bc9b486cd8d8e7c5ab54871a20c08e49fd73d09f20a8423268af37d8e78a59818c34a2e7379e116de39a829bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
