<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0683a5655cd5eee3110bb9165e22ee30c8a9e36c0e6124945060db70c8db8451cef413cd965fb53f91e7cf9992e0fbd772b9ec190b8bb1c4cebf690e6bbb6f0baa9e8d665cda9d5173610f3b8ad05ff5fef7391569ea0a0f31269e5f2866050a082c0b8295c19ad4f8f7710de9ba20b4d577c8b2ed8bc5d432927c71e786f638400f5197fcbb22790bc8d7d528d052afdfdd5b69f6033457c9245163e680822b5d170b217c25ecb91e963433848ee03543d5a8acceb5de8d7efe68fa03e37762036462d41a6eb67bd128391cebc9888400036738ce801ead521cb8c3b057b0aa8ff56dc874753d93d4e7b12f25754029301dcbd1e92fc4e24ede1e8c868399b9e4fb0e5904a99d607f9a8a5190f89cf0e01783eef96e419cc912a6f87259387e6bb458dc021512db3b185ff5aab890f2c6c6d87fc4ee0905fb25ac07789764ba120bbfbc6aba916e377f94598c5f6d41e6b34eb5b31c70d64d507593cf28906cbf9e617a6240c1b212e45a8b9f24167e8b6d323f62e031195a198378ca659a608392e16ad399f9a756f28666d63232d83883fde3a3fd14dee019175a19063b2b0d08433ddf4169b9090ba628029fbaa1c0f4238f320c20958a5ec54509b5ca2fa6ed9adec209620f97ab038a4113af8a75e8cd527feda0db75941cb29eca570a26dd202d8ba29cc40f6a0650f878179e7ba0dc0036998a0905b8a8c942f81d17d34c92b0230104bd82e8ba7ee41c28489538f6a33a4511ad58af409711ec7cb9684da9cd4d805af20b5a2321024b92433704cc4304446083b80c7aed040124007c608fe3889dc906fc500ec9149f2c71c5cbb908d109970fbf96e9e2eb1fa9271fbcdd2472674c555346c229e5dbb47f72aa61334cef4f59fc6ca41f76b255589fa65892dff6527398f82c10be31fee22d2d6e2a237d108076f5e2bfe008a02a105aaa340fb4a7f09f5a27b0641744503386ffb6e43c5fecb7bc9584ddae61d7b38573202f54d32130c66c02a97a64f20a338a7b4c3c334768b56e688db024c09c96467397d42c6a90b79fcefcc8e5f377ec74dd8542e8d83a6944c817364b43ede92ac23b7dd19c45a7f5882a08dc0b7d0592e8818e2d83958737532150dcb7384a841110b6870d4ee0ce0779e2612ae43034a41827be533b4ee4778b9829d85cfebc9e5b7fae8172edf9fbf8c6a743e3eef34805d7b02a6171eb73c40431b01c1959d24040f0f51a3aadd3a743a69249c52daf5aa15d4164cb3bd649ec93eed97f6afd677c54d3e5e5103c2b2a993c306b047a9b390de159eacd83d7326f559fbe273bd60cd85fb7778b30dd54b03914a3f541e9bb19d5b542da7fd24f7d72f018745692f75e3fef1de4939e1478f780da3e05de635a6984c0692dc689628842b8e6ebb5269a15a3e3a280be69b5a352353fa683b96dff6538d3d2caeff114dec04860f060369e6442572c584c078ae16091be04d375172061d4d8adc76297fb10de0813df64c754c243e429c74aa76ea2c48a11528402a20eeb31ab05c0635557e22b91d737cbf5a7acbcdab9a4f7424142437a396b1cf09b682f7d9fc207cef39a475d88f75deb2532b18ef8ab34f01e5e0f2ee5f3fb1d9186bd107756b8ef1295cb5ffb67ba475271934c26015327faafaba287e916d07f97d2891d72845ff1de8b982c0911eaa263ac87c9d071268d97d23b851d5e0d372c42d5a4340a0346da315839d9e65abbf1a2d4a47c39f000be0e02e58468ced75a00988f6c41744dbc306f352e81c1f83005b45108c797804d90f8576d8c3ca48d053024a5fb789e83ff2b1a48f1ed3f49673f7d25933701de63cdfd517b6ff6933cc9702e98c02cd34b471cb215478ef5c1bfd49845a87277b805bfa41500f0b5a3b168cc771440df784c800f53e1b52f8b607f399e655450b0bfd9b9b1aaf65bc0b09282c75d07ddc4f714349ae3ec0fccf87da9d0cc33e32963df53353a1353285fd9160fe707f519857a57a5512d17ed3adb77f157b28f4b91359383962cba18aecc2ad4c6f4281b0576b03936558be88b3f98def364fddeb1c09f055161158934962de1b2737ba5101ede5a912cf2d2a5f11ec4800351b3814eff81f4319ece58c4a251aaa6120fd611d03072693fcd051ecb878f0b940709390f9598a88316d2463f36d865e62a1748176b6c4778a9414cc5cdeb6b979560e2d37f043bf57ab76e17c7ac8815874e76368418e02a1ae403bfda9b8053fc9179f8dd4d7f977366bf5268ae9f64683b06c55cc3ed70d2309a29118100db23d40e38c8cb8632e67ab947668b3559efe58c3fbb3cadeb637b032e7986a12a2b9440ff348df11dda3964fbd69d2fb67106db54dfc29b1f6eefd1d5e829a65164a2548b76e72498d9933ee5e1bfa06a458e26327f94961de5c3483ecc79e62b849fa6b423f136ac3af0d9dedbf96f33dd487b0812efcd4556f2e17f6b84060383d4aa8acfd28c6c0cff4da68b432b088a243797afa3133d1a4b2fd6b7a721f73aed924f709761114f4275062c147beb83e1452bc0d4da38c89e63ca7d26b683466ebcae59f3beec54bb6ae6202d001015903e5daf0001b1d5d46583f1e072aa7c0d3c1eb314ad5243db2a98c33ea3dfd72908b93c7d70ba7dcf2146862781eb3862b691b01af4b2d065557445d56e632b3eefc0a085059251bbfd87e6ad3697b37f693511c316f9f718076197d7ef3096db65b4610742c8c10e5448a55117e4eba03620952408ea68f853fb0e6b85f5eb59f7caee0aec50dbd8cff6606fac227cdf230072b38d845248d67083cbfb8e03bd861c607a7d59c416fa511fbaef027168ee173d9dda37267fde1d4582899540ee76fb18b75909bffdb0d44fc4bb8789e74c92eaea3be9b29feabd05f1a8885786a1d9236bab5e01c8e8a46d780eff4ad96d9d16657b333a19e62a48d0132ea6dc9c897ad37bbc9acc51a58c980eb9a38b877ec401deb456b456b3cb8c287bdecb6f8623c314bc9cafeb406638ee9f81e80933ce47aa57c528877f6ce2e64033c3ea11d2bbc9fc35a611bbab88717919d2caff340cd1b3c1bbdb34045e6ee0868e39877c8179167e5ccb2414f6b87ec416a365974a48f8be00f96e5ea78df9f672f7b7d4035244d07cc63dbe22a6c171f57bc77dee8565c4e286e9545b1dc6770aa53486300c7b97ddf388702a0cdab82c6a9fc56b52a63c603e275a1b864b1042e3524ce03cfba153a5062022eb1946549b9b5b428dc897bf7c585aaf63246d44c9c84cc305c313f5b70f4a337ec43ac062de2663e33daee8fd3e666aa066de550439983b120660ef9efe39c2aec46b8fbc1c09dc691756b792139359def4af49e9474300a44dab65fb7480008953f3509872ce7312925dcb1979e5441965ab317e77c7b65b2dd4b62f2b3a6239a5fd9ba3300491928e251dca0611a2c2de02fee477895a6af718b19761c5ee9c53bd696be63085abe2b5ebf2fbe08f341632829b0a1ef6feaa2fa4139e3db9534712f47cc2d30f245ca5c3e90c38f85b1e4be01510e41fb400e06df31e9686c74cf3799bd20cbb670bc405534c16ad456eb7778d4f9e8156924b47c8266f4ca645474af61661091a57f0cd8ea892f3071a0f3acb780d0c8e6fd22ece7eaa5299a9b99ee9d39480ed1e63d269089f253645ef108491480da89a91c6e12557fdcf0dedae5885bc8e6df14f7d5a7645b3772e76254dfd550f38ffee5f34005643edd14df13494d7199df42f6a2e8a99d3e8155f45aea79a779794fc203dad191327146f480c39f1f2f8f60c5c0c51ba80cf60c829ab776dfd01e6fd9273b5ea084d37ddf78797401b7824af7e59cf6c60d39c86b99cff5b6ee0d6d057d1c639205e223f6b812cd4409ecc43b75bfd0c0cfdf06768289044f25cd8e8a15b3e3c39e1efdb8e636737e453ae22665747a954ab67417974fac381a6851a7548d9b687173af699b13c50b30661aa8ae92a4db8e89246e4153cc4904496817d6ed7e078000612bff8b9d722fb78a3405b67bb9759da4b7c837550a6978c0ef0969d56f163bf45389fcd3b4099c21323121e9b8923c337cb500edb439bf3ad434a171d1f08de9a80adca9f996c7747fb0ecc25b911258147c7fd95b3ad7fc79488c1cf3b3f8344b00e7b224bc86d01433baa2c2a86ddc8c8f5d2d0171d86b8fbd9321fd1ae7358ceb12abc418447b509c8c48bb6dcce63d3c0ff73dc6eee663ff74c94f180d4620f80027b2ea3e13413826d35491e337330363893e0f5b65d79ce94efda680edfda7a109b3964d4cd470931c41e65356d51be2fd619df4a453ac33f2339bc59ef39b9a8225b43772ba58c78b221620e7f16a51ea39345beca22ab55705d50d7cb31903a1390d689bd6ecd8c1c194c58686274b9f7d90c8b1ecc1e75c28f90a05dc6354a82dc5425413aea87fd8bd79a5047425ced4ae9bddfc1ab25def9847dc623f27fdd03c109761d396ca6d5c4457da1b3bde69a4bb079eefff799ba719b656d7dcaf8feba31bc01d953aa9a11edddfcc6eb7786150560572bcba8d93d668813351f7bd48c6f34adb7c4e440e7cef3f20edb2dbf561ccce416453497992e3a8236e058d5925dcc4fac016ca6085f73f748f5d3fb7e25123adbdef268720ea138c8268f4171acd5a4d0a057ae9eec6938c72d6a2c7cf09b28dc052da493e090dcde713bb9e4a9afeae768dfc1834dace4415eab37b4a8d252ad08390c3c941eaef4d0fbcc1f430e32e911f71fbfa0d9dc10acc7198ff14dc7faddec9092adf973c67fca8266ba8aee9ad41bfe35011ba3a83a926fcf5a6cb74a0b4c88cfb97b579e58c8bd909ca04e51d9db6615a79e3dab4c0a981babc97e58d00ecf81c843539ec428147bacd9819614760f31fac93aa7af6002f74f83e84d28262cc1bcd6c0875ef4bd66d06fd666fc1f40ffd7c4fe8b644f02adc6f233658f91bb9cfba337384968ae22203f8de2bc6f2df3ed508aabb479e4f752ec70a891ab820a052f664be91824d0d04e3fdb3baabca50930c4b096b973cfbd3e7d508c75a508512d9df3e1bcae34841e7fd31bbcec94ca08d0574e4ad750ec8c681bbd4fac8858e3f0fce6d0af23c6ccfee0ec6ea12560d3604184eef53f1a969bfe9b4c89c10e7dfb7725633b989b1c83e5965185b47178b0d44a45f7eea0c831d64f37386222574eb8ffff7f29e9c85e7c113ff1ca0363535e052522b9ef20d4ffcfe8e093a3a07ff5670ed119fcd4e5ee8113ae1c5d949298a0d07125f47edc997bfb553bd90c1bc1809089bd89179254c95a97c76b8df272363e320f6d64c565a304f73ad6a4717c017933062e6a2ac0d234311e36aaa1eb4c75ea340cb54519b4820d3eda813af388fd6b25bcc6a41d94848bacc5009e970431d31479ebda2faa149dfb3370d2867fe15784e7f60bdacf9e8cdcf765bd2498d8d373421cf33be233dfd63da5900411cfe1c81e4e2e3dc4f0de38c5be5d2c452dbbf7a2646a93aea2265f2dbb4018a5e5fa7134108950d32b2c1f3fc15207bdf99adb07a3c3b6018bffc94d4805e3f0b2bb00f3ac700f4173765ff51c50c6a0c969f94adc4d521faffae92e1cdd892a1ec74fb3929a8006baa81faa30ba6d95eb60d05ebae6ff6f03be466a764c64089742199116b988efd52842bced836eebf1436a1a49dd5221e6735febb62602db04d2ee4ad2c345f6781f5016291e27c7265c07e4e94aff28ca74d8651550f64728fb77c95172e3dd01393bdec00984537211d4ce1b9589940062bb7631b8639b11b8c79b164f310d0210c9c7233d428093e4ba64a3cb0fb722cdf3349160120b12e831dc39244b1113518c60758110c0cdd9591180adce9587383304d33ca0b8e19ebadf452d817eebe11cdb3b440fcb7a749a7e53c4776c19999f2a16a558c7204c061e1def46d3671fcf291c8ff7607c487e551302fd1e0cea76e419c5949efbace1c693cbdae382cfcdbbe38b85e94ea9f749fe248a48296ef3c7750f4884fafa925b7b90ed2c37c7a81f1c20ac58cf117542873bd48522769c6e35000b49d01572f6adfcee8549252ff0f4f3e90d5f67cac08b3679038bed3c1406ef7e7ff96a2958c1dfe5907ecea686cdec8479c4dd72485b6ea7205a89d1a55134686a30d77e8e40a6dd92f6d98a88ac05eb0e1069c55d383d9bbac7f30bda59aaa6f4e31c6e65c2bcfbcf41b20a9b8c7c0eb8fef5451e017896a5f536b6d03ff8830556b1e788d408c5ea2ec11efaae93085d1600b91af58b98161d592848a5f9822ecbb30805d8f011d2e7bdbf8dc3ccf5f4da133721a631f6c655cae4e653286893679c4cb97f51c7296e7868cec2d9e8b06b6c4ae3b150fbe8dc89c6966430cf32107c2a1ba8bcbb10af99978829ad3a7635d2c7e4bfc280eba7c86991e161e7ec2c60d70ef6d146e193b15955ad839a11a2cfe5a5070d92fbd7d2cc03052777700f56a3dd433f6b7d51e31949403d3c9a26dc56a81c1de33e747fca8c484a4643e6f3391516587f8ef7d2f4bf159a1f83c48145f95ac48c3db840b5c15b538071ff08bb37b469e150356828d0e6dc3af1a0e6ced1d2ac1138bed2765d4dd6b0211f6aa8be2ab9add599c5d1fb2ff09071cbc3891d4e0a0865e5732d3fcc67073b765c60f5a786450dffe39b3ebe5204ed41f778e60175e67c2743323777e2cc81440ff96b1733e3a18fd377f5d6551a169082eeee2ec5e6e548434c60e4ceb3717694532844ce446190bd737978f932a50766c3fa66c854662c7c6c9606ac25aff91572cb76afce12a8a2377d1a27cbd83a98bd7347bc20b4b261981cb2cf39a73711e2aa622f1aa841eacd3c34817cc5186aa5488ae9f63467ac2e3a2f9d12f0d9fa640edb070930a1886e5e40c9fdce9aba95101935d7cd461df1ad2a6f61a8210428329e7051ad6d71fc113b7e601c64323b448e2df3748f3b3a3845addeff1c66d451a4c16caf23c0f4487a3f77d58fa29c7c1a01ee69c1065937de6e4520a166c09c4b6e126043c0fb68ce0f7a425701d8b12bd41e29c66d94516782b5a4bad1ba933a748278456380aeb863905c9d3e3eaffad9a7a9c339f06224628dadfabf6dd15856a93d4ca097d8aec55757fbe1903f767d846778d1d8dc082b6d79ce4f4d91eed87f9fac3676c729709895f63fb3b1125d19ebcd5a4221370839a213014ffe75a358fce2debe5e3f5d32d545c0c360d63b365136ad7faa16258ef325de1cf93aa7767a4d8af3c6c2db6e66b6d2565351ce5a4a316fda7618345901b81b5268cadf74526686051eb70f96864fc586bbcfb9d1ef48bf28b2e04bb92bad2348543044ade052adc21ab197ce5426f3565c7c2a7b42d801ff927ca49ee8253d979e739edd37895582c1ef5f5f247e50aa65d7dba5ff1ec48b80528935d30392a4480fc535f671ed4b146064b5f4ab776e1d9a90fafd0729587679dc83b538a3d78c3df34d28ae4549b691cfba9d0eda22efef498843ed7ba09fb92ece2b8f614219f0e2c24accd079f00165e978217c22697e07aa17bf451759e1d0f03be0f37ad8cc31629e86a01745043705dd4d5a13fe55f56fceaf220d957ccbe35d1020c08b56c6f55f85e6d350858d06135a3a02d6ef409c388f09f409e4d249b8647cc09c4a4c2ddbb8c78f2bbf75e5e2eb5578f69eee5b378cd45c949df4f189410b64123bd2672f5ccea6e8d00dedddb8532c5474425a1208067f7b761c5b3e622ce9232d31d16ef00a63f4f4402efc9f94170e250caacb8c0d92d87682e2adea3cf0b0280bd4570c81662d8a828b7ab5e69e08d09606bd9d7216d9c6de7211448755957904e455cfc7c1219118b2199a86797641a8921fe7a14373ba5659b460ae4b1d9cf12ec9f8c4b839cbee253bc7fa33de3cb4dac1de69dccc0e0ebd41ebd045bdccca5cdfc983c5d32ae5fda2f2830f8f6e7703b21496b125b3c791d056545cb93caa91ae5d3d04c3dbcb69b0a83cc9f6c57652697c01fbde25697a97cf324c542a6b3b6ce24cc42faba23b98019962889ee711d932fb8b5d77cd3789a8f3c7dae946cbd1cbbf358d866bd15320e074717472afaf1e137072dfb6ff71b4b3942367afa44519bcc90418fd50f5eedfc747e3aa49a8619dd565495804696ee27e963b87667f6c49e1727aa9378ef9204e53254781f416f6c864bca1e1b1aacd550238b09f841e9361c3a80357d62e5fd02e037d83a97206c079d8d6a2cf43b32f59d44d3aeca8b7c7f35678618269d8d2e97aeed0055ffe58aefc4c676d807c41c251e3f9f62ded518422787d41f532bedc17d0805137e1d719242004929b829f76e1cfa0fe9eca0f82b8646ce5af4da19b200e3258ff04ca47e0f890daad2ca026b37912b96ffa4a91a73e6459beff6ef779b65d246041685924e8531e750bf8eb2bb1f96fc83bef3b184ed255f5ad63395eaa3114d2f87731c09baff08452944d5325cbfe6518e2ebbb4b86089edd248340a8c61d833592641169b3211bab60de8be502ecaa16e5cb90445d9a90048ce5047ec031860f7380d2eb106445997618c8ce5711641b705cdbed1f5b0a821bb3659625b6deb45e56babb86520c58693a70ab53b50beb9f7d191fc41eeb90547544d61ede22981616129be1b3e05af77320606a98a9a08980c0d5b1d7149dda54a3df966f08b5ba8eab4604f4ca6362bb49c455d24fbb2facd4fe0b988fdd88decc0a589bcec61f586b5f2204c90ca78d3c7a60a15e62a67905e2beb1bb789f1fb2e38ca65fef82c0756c3deb0bba2335286a473ff798050a9024b8419f778e05f0c539754bf9dd872b7f6d8cc9db3c25e11e6ad278c066a6bfbbb43b0a14526789d2288a0ea7611575b26706f13a4ec871e0556b46fd91b6b9a64cd09d65c052549c93c4fb98ae1cb2c0641b0a079e2cf3725423f68e38027b1737497f4a944e87b2a781443d7a30222e50c901175c1c5917b95383e4b1264e4758d1b9a346fc6b95af8a65b66cd5b2eaba1c9b63bc664108c879b5ae85b815f2f52cf5ccbfeadfb28ab35e48c0c23089174b95f1ace41cddebeeef6412068a751f0db3eca21eca36b0456611087eabbd4bcaacb5729d91389ce62b06c73aed1bf4cc745044f0ecb4e06fe4ea937374225568803ef43718b4dee73327e056c7c1fe8f0448d35246f9572ed79704d88a4ff5399fb30b33a81bc2cef3bd54e36ef9767c81d8936686d7e01b1fd0b81a94cf7c51835c20518d82d7bdb3a6043f83cab2f799290de8ccf869dd9c30414015f5f59adc6256268decc0df674c728a01e2dc83e92b95757d01ee2b2d2cc24f7fd4358d0d2e3318156e637b6c6803227d73daf4cd7448e3ae4de7429a0d819af21bdf68b2ef1387f80cc1ea7d99570b21f1577553e044ee1787085770ef482723afe1edbc0a8dee4298a1349f81f9155f559a67e111a99c8a97a00448a406b089583c9efe70bb5ff56b89445f106f2fb52b7f5eec565f7834cf4159d6a58ac5e76e37c80664ae8aa2c611a6302e3a39900a52e30afba5dc8c4657cc9b6e791b98233e238def7f5de56d484bce039ca655f171d4ea5ecb8950592599f2856ebd09dd47ee2ff384fbb3cbb227770b61cd873e1cf2b42a9676efc86b0273c2dcb49b7b981a0273ddf0d38a3f83fbf03f862bb7aa80acd5e0afefcc376700ea9b00c0ee48fb8d59aa1fe89dc56ccc7039833c49c3b534aaebf0835582b529faf1def0dd18f58f4f129f1867b705f87c0b18f6b381c12b14f6555952cf2da148360c3156cc09be47e01b94eac4c6d04e6514cdd32b55a418ef16c2cebad2c0c80bb0b1af3dc57bd11854c28429cbd7711741547378fb47c3e4e258dd043608e2f65bff5bf67655ce3fdd98b795c4a8e2e1cd046cd3281baaf84a7aa13f5904100d1bb655b93512e81ea4d199bee23e289c3e313b2d6450a255f4719fe8b3a23301ae2d2b1d3dbf60e43305dddd6502dcef7590fda0266e2abb61b7d48753db13dded12f3bf80c48a07cb438ed64c6d02f686ce9f8b90f66cbbdcb431ba5caa0f2f5e2ea67a3a7c25e64d4f3628176f8b36d9912b175147fb488aea81c66c596229626dcea3ce9d7bb7304559dda971806e1866f2f132903ece014bf6e267eda8cf204e1c63ff403cac0470bfb7477348ec6364a4f063f94c6b5dac84d811415b746fa5ee780278bd1beb346bf41efe2f8762a92ea14d75e919105c144d57b92e8e500fd17d01b26705cba3846864601541c208fc847326c4dd27f689755b1ac83d9d0845147855b3a1976bb8021afc5f8a9ff38f90b9c18c3e9696fc250dd71d51ff2bf2ebd747ae68d03f42b4ff2b73462ec7c01da0a7e42d10b4f1681660648c169a680cdcbdb478a5c587aa19f879a1c0cd2fec0eaf0c432c8c4b4d8085cda2015598a7de76c6ea58fa4935fb36468e780b6112c646b2b4d88736b3d310406f6dbbbdb25516cafb6eec7cd8ac8bb1ecc5600fdfc15f81a4b77d98c63475df16c9ba5ca3ee63540eac97ed078b0d75911f04d7a8368bd67fabdf4c1df67f4a9eb5a90015e306b3a1ce6dbd2c212518f977cb4206adbd8629d26826a67efeb14bd515fcc88d3ba8af167affe2b41939ce4ea6dac82db2125f6e387a0473250ce23a1f32f8708fb637dd5ae8be9c2e1398098647607e5934fdbc67a327a166dd4a84d732c36d2b155a58c7b48de4dc81f9b3ad940c5769cda1f02486c83e10ff7181c936cf30cae774c5ff9873e1d498410a645020bc0945353a40372c05fa5607c8bd7a8c64c007f411f2b585c513808479f0bb17a801d7f0b2e76826e018468c107b7343cdbfbbb2220383b4781998a710c1101d0cfad09cb1fdfed9ed637a1b8426c2e8ae65b601b1013006cc79417dcda5776a4e35f12c8be39e9fc56fcbfb4b429e996bb7ffc7ba84bdfd8e05cab0daf872da2a099267c22cfcab6f4c83d7e9e35bda900139ea2ccb66a1e9d2103fb76573f84764f5239c112c1c2659a062ada9d2ced367ca2609803cba87f2861b7c64734ae217f5d2699508709e32a563e248d485abc57834f20546f63421a3aed70c5114ccb352819e9ab6d59d55967abb785690b551ec4d26720fcf5c1d5028a4f0b41d2fb268e1ebb1ebd1b25b35097215580fcc5d3af3cfd9eff37ee20d3c25d27c73316ddefc4a118cbb145327cc522a943262f849cac393ff0a0504f87d83a0844ab92c4c83d546d245837c944e2a6384b37bbe51462504300214d437ad4f57a697d33ad342b9dca3db7a77e04ddd8dc58f9742ac48f5c33a25f129e0ac96fb800f1a927555d1147de581fab5fa59dea7393ba52b8bbd79b2c5a5771e0b274208aea04e1cbc1c7ae78b6fb8ccd363d39d0854c416c358885f2722c050adbfc68ee75e8c24b70b3e9d8654130c383dff30e4a7d77bc8a7d527976b078a04c89054d797d6d6aa236449bc9924c50ce83fa3c33dc48d2804c9677fea1d7e84b5d26e23200b77db8836a1f5efd116553a97c101f522e16269a1b186be025ed3ebec0428f709e5d196a1467400ee73dbd042a4a638d63a833d265912a577fc4aa517742573130c257187962e55d2a8daec49bb61685d9f87f69f497aa5addc8ad8f341daef25d0c14afe694e9d119dd745a9d366c057698eca87d2141e76c38d7d60165a793e0dbbb46c85294efb1d6f9c01e634e9ea935bc84068c961a4d1948309a07aa6d50c4882bd0674769d6b1a8321793273eb5467a21620e368e6181fade40e59cd275b5d9f2da171e0f066332525616519f1d23794be3d237cadcaee9f42900f595e1e70eade466b5d33ba941a889f478fe632057feda6c6a9bffbb89f4c8975fc658552e359a5d87ed39771a5df158f5bac781bf721dca5a0ce7fb428190d075c3c47c9e6c9dd27e749fb3b6387991b2d267badd90bacb947d98021f9abf591b91cd6a72c425531d7ca3ffaa9efd7d2bf789011ace76fb02cb14bbf2778579ce7f13fc405395ffb9a46fb326ebbb427df2f2716ee26494a26b6a917655df716bc46c002b92a92fbf9b31787e5c6ed773a07434ce578478d80bf513e10117b1e7f00e5c11c3cc1ac0715fd95d268542db1b40b142b7045235c26784ee403957667e4012c2af754073b66462721fa1432cbfb4d7632d12677c17f2178e49420b3f6c7ce1c054a87aa10838eb9d08c338f57d7d09989fba5d93ad18f54cbe4250e7b9f19cdf19915cb241179a60663bad339798ca1ddd9bf342909bbfdde7286f82c36ea07518ceddf3fb007213eb007c7b14c23c6c38dabe3f1fa1a9e50f37c7644bd2ea775d532bc727f9411b377a263628698441ff6988a8b695aee847da1fabd3666ae5cd45c6c175e84805e53dcd24ad3286fbb0fcf4a2623a8d4e5023aa6550d2311b063cb362b9fee2c82d2003207134a5549884c6cc9b808d99e37bc7d7a5d7c1162929fb5928f9af0b10701acda77bf0f81b555366ca4acd464e1429a3415b79b972b62e948d0b9d34b112ffdbc1036fdb8638d904e025305c29a3eec4a2055873aa7dc321816ea65848540a7dd58d88f36a0fa3a702a19610d16379d2f3d708cd57d957abe9b0f3394663deff304512bfef92ccb1e64717ec9c3094f0f8b64db70eab3ace0b686017eba70296e3999d4ac28883914d7ae7a655d4ae3cd35bb4c0eb90094d3b77ac0e8112b7ebf9c25761247f3cbb11cd16877901f3b651e1f3e9f2a32974bd2684302ae8bfff39ce13f1890ede5cc655d7024da6917f04c0b1f569a326d5ae850bdbcd067b59017e999e65b35be6011601d564d28696e08c1baedbd4e577842452e3233ccfbec5ed6d58857da9b00d59c810da3a9c4ef7c68fb78f68957c6a962d93f47dcf0f15c083bc1c4ed8188dfba2a52a252ad33fa9ad62e49125b40a166e6d1a6ebe8353149fd122fa75eb26f5245ce5cf116e5a81bac0f3cbdc8f9e6db4037383c208fa45cf3dd72d98019c7261a3d895c01ca8f42b81e637239c69cf4e43a3c65ce43c25f4d51a3f137e38c2fb7474dee1b578be8a434884b5b44647f4f92f7c1d1341cd636177ec5980cc14f4f492db6c18ad1aa38fba1d65212d861419d1c482852217c33e46ad80adc579b3ef743f65b3066973894422d0cb3de9751773f6ae61f4266433a1b7ccaa50f2080859aba486d88c7439dffb80ce9b085019365c32a21d23a016fd07d9d0e810f2a8c152006e1ae0a262c38ed5d1b73bd2eb12d9b7cb07204ab9cd46aeda954a9f2b4699dc60625109d61b93e1ee48395e12e479dc98c21ffba356e62ada3a2e8750e293f71bc35f18e6080ee3a1b2646c7321666bda07867e915a85965cf2d87c20d9ecb87e1803b05af37b55b07f182d508e649045c86d0141c2fe93d15794174686828e2963ffa88dc787cd0abde824b5adb19823039ae548bdc37a3f3a10d9a55a0a827497ac7a9e7cf2196492f8a3e6e91513d3a49396d27d108376f7fa5315fd4d8722c5df0c1895f10bb600461909956a049db7c1c66dab7cc78a2029f19e3383e63072c9a35f5318f56602eee2f592067d0a8491f1c94a22516b534ac06b74d357be7f3894ec7a768488f7d321015a0b74dc3721d94278c7d67957ee5df919e94d33a75325e1c96580f5c1bc87d146dd6a1f1306880cd3daef2fd82efaa7d90537cf194e68b78b58aa71f89ef61819ae4121a7652f6253b62d69a215455977ec72752bbd0d1b7eec62a6b9e80d9e332041a663746d8d4c7ca3821933ecb6f792d38c59957448e810171c535caf19ab45630e6501ec3a772b226d6786c3d0c6be3a76e64abadae0e64ddd3855f43e52590849f8dd28378d6e90d6ffe44235ea731aa54996bbdf3e290de6de1d848e9007663edafbaaf4e07c57728a3654fb132c0a7fe5727d6fa536697d1c549e73a1b7c397fcef7d572841223f52cded5e9798f4bf975636c70c66c797dbabb0b28243c3603b6930ebcc40c6ab96ab640a06ef88a74820a653558248f30a7365766621bcfb95033e1e255d9a1c989847f8457a00b10168528eeba45e8e648cba9198e52e9d55c25b0fc25858a8258c1415574ec1a96a2da7f2344584c7aaa3fd228bd8b96c9b4871415edc277264053cf921608bfb29d46e1cb21acf4a98b7c6553d4cd2cdf2b4f073dab1023a3ff20911448dd0bed3547e7bc5b1f40fadcff03701de2056f8b6ae569a7093c7ccd45873e71be9286353a733e3dbb953ff3b82dd322998b9384afeb0999eabcc0bc82f33390e0265247c2ec66c1777559810266d4bc31921955a6d2cc3ce57a4032971a75cd86836676363f7b480fbaf90f472979dd62bca1cd282411a3406fd959d30bd33ce8a0d7340ab3b3a56797a246fbbada53e15e16acc64e6caded3db0b91caf34886b51e421bbe9ef1e2a3f4fdb3e28310f19b2dc84f884f15a38404a6a985672ba5be2f50eb8d1121023b4e9c0f1e5f133afe3e98d045537261c6eb84966cdf0e4c19a9e4b62397f7978888c0a17ca85f8c6a6a7cc8f2c0226e48f974786b0d82a46c434a0789e6936495ba6a42befc0d40edf6f2e25ef14eb1cada138294820d1e299bc03b6e7940e88258666e05101d2866e83bc51a1b0b4a8442a0d6f36c7374de94be1faea7313c2eba076a8004c8598473f08074e8952e891e48f994c266b489b3a4617db01a1f57fed642cccf37fe5d41b1a5c75e2294f0dbc8defe08c6cf5032198e04400595ca5e386bf8c777f4c801aa86e234c3ac93a0f01153b110c3665fa5873858b68c4ef11474b218fa01e926bc523402f51985f67b3a29c1dec80649229a51a1508fece16a5915910a839b0cda134f87cb4567eeba9cb7c0e74a58e00bc82593aac87ef3c7ba09267c6ea0b9b9ec6b87632fcc09fac1e8b06eb0afdc0b63cd3cd0b0245f1cf0f8d1cba96b4c14a4aa2d192b0a1e6ffc55440edb10a6e1c7e2bdc7a161306d55464ac43d27bc7aefe3c929ddff341c151afb2844b94b84e568897b489164c162b7211e0729f7c5398c8b4c3df51ac3dd8128e5789c70a1e065be7552809a472a5e46125b84fef7d07e7589fc38b3ca2fd0a4575c15b6aa4c1d40ac9bf8a043a10338ca6d39114d9e2cb313b07a3b76698f43ac0a856012cc218acc9ff5a0636f1ae2a3989ada236373fc7a4f6fbf9d5132469b60225290cae87975a20005bf82ffd682e0ccab0c0bce074156555c4e50f12f0f1ca3504635eb79a3dbb5f635c35c4f605e04551daa23739c0dfcfcc78f6d46b545cf64f59aefc486a67ec1bfed1695b5a89b018dc46c42e6f131bf63a95fd66c1f0d69aecc9d2d5dd6616923c05380655e246fd56f9af840632b02fd892cc3b68d7f858cd233d48d0badc2484322ce6c2b3d1995be0e0233b03f56507","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
