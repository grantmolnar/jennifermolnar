<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d96203b78d2fd14294cc5906e683781f2215043a059193667a558aab09e29c12a530f0bbfbb61a454e23840766e0c7326d3dcf9c6abf9d84498187f0e06f3c1137d99689e0f0eb1b5ee54a217dba836a4f4633d44c0c291b45341f84a08fb7b38f971b8f1acfd96ce87e823a4251f0a224261456604427542f5c32bc72355d844e2d24374abd3a7bc12f9b5e45fed2d7a2edd75a6bc26fb9611a63a93c6fad61ee7139379cd96e2b111cbeeca5c5171d5533e73cfc35679447a122ac55ecb4b20e79e7603344de2acd344b9d1453bad46a32829e4cec9fb269c741a016754f7c2b70ead34a8e43d538e892db5d024d7e0baa4e4e3a3bf6261c29568c6fd3929783f29834336199b9d2ebdf5d503e2454d8e7041b938f746e78edb0650c84508dc6994a4a7445e43c0f0724073bb395e6de1b89803432e970312b5348ab07715662836b1ae5e86bc006817333b79c042b1b26bfc55c05d7934dfa807e4a654d3b6f4047c40a90f1095cac4dc0f4d64d1d5b749b5adc03abf2a549dc044a88e10e0e6ce993a6dd8107c4648d8e4772db7fb42d59ca11f5fa2a854f1a3bd1c4c3d165ea3fbefd1365f3aaee785c26501d033875b5ba8efdf1df2fe166e7efd5b1a3a35386ad75c8ca302c7431bd44c182efb71bfcfeb0df20dd68461e12d8f1d368ef888cfab19d82663e90cd99292b4dfc99cb830e6a185c795d15254f437403daff9a16f86664137c495bd3a9f0c8444a6fbf6b61a09eede03740011427d72f67dddc1b47b0af9b90bc764fe40ce372449040fb97f8b87e6992dd3a57bd7840a63e1c302305292c80484238a18f154f25dcddb83a5ade9f3dfe7736d2d828949ee8ad26add58f6d9ea4695cb6dae878475aad49c2830c0c12df394f9ce5bde4e523313791a272516c3bba10b0347343679af7805145e0d46e77d49c46b06f782cefb5bae22bc4e930448ead71f16a4d2034a9b0a6ef1eab6a53a935524a701630b5ec46204f465a1c293847c9c068d4877faac4a2bac352234e3c1a4e27479f076db4a4abd828ffd8f0c734db169d63986d9ac5cfa19bab8e637ceb7558648b3e4c613741ab1e6385bb53495e9582088efbd984c10e5cce1fc6caab96067460509ad7a2ab3816dd09410e3f4cbffd79dff74186a7f2329ca4a63ca31d962c10916d653709ddd31006229a0e0c05907180fe0d2df72b73e9b828514fce97229feb882e28d90aa2af36097a6f9150d1a01479d4f1d08518a9b639607a32f44ab257e51a0790eb71fbb2cb5798abe3fbbe6bb7348d6d8e5e76ee169add1cbc048b3b33d5c5fcd5297641d83092cc36c790ba2c435ba5ead044eb50a9e135279cf1bf2b677cbf4435ff3afdb95349a132b70c1549c355e4c5d2b00d51164f9976d05604e2a030f2fe43b8c28ed93cacc65a235f29585e489c1e5b6835461a0d5f6a41e58216ef447f8422f1fed7212c28f81fc1900e163d257f2bde2d5fd10514cf1906682cf8c4a4bba7b00649d5aa3c20c3c0fe53f047557c3e29be87ac5beeef316eb95927bc9601a1c399940661c04fd2b1cb946a04dcb1592c75a47a231fe330fe3ec295ac8d05de1a16e23794dd45414139e85838b47cf0865ce7f15a2bfac6eb13646ebf90afacfe0d7877c465f5cae50b1b9c0fe6a7b1dc8dcbfb09747f7c6ceaf85cc55f16094e05dedf419fd5003d876f38911dd161ebab4c8116c8b65ca7b5e584b74bef65038c88b3bd70eab70c1884040482650db006e768c361894d49370971817e90fd739787f9a0cd70c902b126c4c6b0f2790e5dc458506e5020fd0ce86a5cd7eab7b3d915733d0dba8c87b132af23ca08e8be5a89b067f3d3ccc7dc3bbda39ecd1c5e252b88055f3b75a4c6338aa90a5acbac4a555caeb169eb266672bcc29ce8ae06382a04140c5b4f1c589391276c779aa822f848bdf834ceecacac7276a7b79fe385eb9ad9210c561cd089d6881a5c0f9c9225896c3cbab92f877ffa57b51fbde09f682108f22eef64e75af8dc41166ef53cc9d39270d3a41bb57217b1f504120cea79e34c42f576272dfab8830b40383ace4f209839a567794318c4e13fedf7c7e458d4f6f68aa1bfa2e19c6a53ac451c10b0ef30f5106f6331a0dfb8c9bec1c7be484265d42eaede224f595ad3e75a331335b4237fae61cf30bd46bd0e51567521cb40abb5cd1b51bcbf5c723e8072bdcabfda814a26e2f8503ba864cd9102cdb36ac549f32bbe1e024de36f55148a98e224b52b9df3cc1ecefd007ba910a3757b89930fcb80ea6654e20cafa53b37f86282cf69eea9d4674dce26263c0c8aa7d92ce151fb28d98dba183912588a01f864c0831daedfa9f4a3f7f42e4206038adbb264aadf33f488e2ce9a22165ac7ed79eef70dd934c1c00b6fb7afba58a17beeed205bdd3083a479c7a008a20de2b7995e85c1ff06144f2be041a358dccef877cb98a404bbb6e731af5a3fa1c44ee8f8f84209460fb5b11491f4b37d0728f609785aeda0d8d01203dacb4c90053cc0ad3cda224f57334d4ebd42058f1fc7543a7acb5043da193e2c5ea0b0e2d1fe2ac67b7329594342c5c6592b3124f7feea6831ccecd1401dbbd03f4e65eefa5bfa9a99cf8e467c3c2f2a1c867f8d8af09ab08ab222489e91f547941aadbc5844cf1a41f63963ad206a8903ec2b22e7abf06c9d4964c6e06e0bca8aea37d61f3e4d3e7366012763c3dfa1ef5a5d357b347dc9f7645664e88a0675caa001480d5f8e5c697a8c93d59ef8674a42fe44e05346397aa113f12ccdd56b43cf4d5a83463e10f75395cce1f6cd241e76ab0e24a631c37f77f9c4f027de7bf2e716f8962ffa896e3156df6749d7b6ffa259b02a82266c87f434779d3522071d6ff05572b2ac44d0460fd0ef8fdb598ac838516c1e62c852931b0dbad5bd9627f32a13ec837ffcff77b2f0a11164247b9e9fe0cf8c9fdbcc4800793e0c9bbee406f52425cfa75a4e019f8ee0948b99e766db6b555a78d7eb2d18a7475974d96b9b1f3de4ab723e105e84d3fd1dbec44df8af6ad7dbb65e5eaaeb66dba4c55530da6be502759c0a50533d814a2eac1b965414db7da77e1b283654a3b9ef846ef804b3611cdd05163f7a2051456e3fb35c4bb914e61f69da671b4b70d339d391ecbd7e227b68705bd483db99bf019dd820ba3b6909f93b8254a257aca55ca5dd4172273ba4449c6d822e6ff8082c253f99a6c4bcfd2d1d2aadec1f46a26236f3e60a382e944e7dfd810e6609f7752cdbf19cb16ec49f44aba8cdc2c6c2927dede18a08aa8e79b5bbc58455115c76ecf6ea8bc9b6fa6bb4976a0c599576870d5f72556862372017a62c91a02495a9aa965b57ebbe5298d2651ce7b87e108efb31f00bd9ef34f6ac0b7b7b6dfa8f120424d98349f4ca2c81d7e29e7f7856422aab69b082e6a6f57a9d0e54a54322bf9c562713c3d932d4f7d0674516b0586a952837c78ebbf76673be4c2e4930b575d5b872de1f4da9229552ee7ae2b6175cb6c249660a3b2c74723288e13da453fcc487c2d6284dc078884f11509cbdd71756e5ff12337138cf90468ed345c9b8708a1bd6918db8f188c7d28a1c99e2ddb5704ea8540c99f67149fe5c014fca8dad25e48914aebacee7fec5edc5bad99d54532e5f6555d6e7cb3b0d92796f266e19a11e023d94d8795800472ad3c82a435903bd25ac76a07ad341bfe03e7b06ab9a6f1237724f7a7bf1aada0ec56553c59852a1c1797fe77fa61336308f36cbb6575a2aa76d622a02d59ce38919d2c9eecbc9291c06c614d146d7a2496349c903e88d3d821823b5d38e028f3bf20bbc7b83b17b56c59e2be94c90f6a6a01ac13abdee407fa7690aefe937b9e92a519edfa9ea4be20e911b03361d7b4fdb8a1d5ee4da48559fd1451912a5a2149732a70e6e45698869aa814c555e194c05060bac9df3559b1a4ab4844fe6b913a66090735e93ed8c20ce0951669c3f48dbe86198d3ac7d9b37b92c912ea2cc978593afad72f7f6ad454cad69652b098eee70dd34903ccd01710b80f69ddb6560cab10a2b7efd5b124e93523bc3cec1a54869fc06540a0665a7d01e05d372fc0e5879ce4d43dbce87524a49ae4a143515f0f72eb98cb38ed1b7950d77518599ad19eb4d71d3d93ec56d8904bd236c4c1650cf592964f91252d263d6b3b248cac1fe80a38024f8c7657ea8ce0dac145c18b2341b0f164399e7c9d7454f4774dcd980bb69e2ddc1a095bf703adef0358e9f1cc6ecf23a266e4b8ceff2895374478ada463986a5f2ca8e75a04a6af72c7e493c7ba313c01040cf2feadcfd4c770bfe4aa46b18706fceddc5e1779e025582476a3a38e3aea953c83dbef6cc1f2df28e177aac64843f1d2a4226455549363a8ea3a24d5cdd95c6998e37146057b1d0971c9e786014cfe9a2e947a4939c228c3d8fd492e11de7efdf22636240c5282bab4496202171ae5b41db8abd23500b9b34ccb06694f04de39df149d6c4ae28241b2b798eb1c9617190a4a7aeeacfe38d696210724868792cb9cf1fd1b46e5ab0eaef1daefb407deb9fdcbe542ba04a2583e8e0d90b5f0295037e8d9b6e9d016de6f4ce151bced2807fb636a99e5e4ddbb9d2ae4e712c4adff49d7a2ac8bd2b9d6bab7ee2e89c62c0cb25674d0b3db1819ef0de4fda4269a3c7673062c6110e2ae526f6f9d4549ba9cffd1bb736d78987892e41196847cb255ede0cb94252002b98d45c8f7977413e6da72089753dc4bb81a102a6c7b24555b1c53524068d8ef778c605aa7d10a0f228aa93267822487a2da5b26c2c407808de472774c6f81832c8c40dd38be3ebdc897e04d6d1038db102f088cd53a52d5c5b9bbac3e2c8cc65a96b0ea0a32106eab43e90fb69c2f9e0f4c819f621b3f9393220a363bb57ff2e4f5c9525605662725ca6f22ec6b939b558d260305693fe4e17a7b1e2dc253e43aa9c607272db587c0f6f3ad13dc2063c0b1085e2544d35dd2eb39365b037852fdbecab55d0acd80fb0d9a321feb506f641869dfda8df1eb51e8d0e00236188d58c38ab10934c3d04f10630bf728ac2bf8650bc251bacb923c1a98b7b9fd8818095a1cc729543cb56396ed98af6e8bc225ff9375eee0ad1cbdd51fa0b47a7d91dd1a47235ee9bb0248c5aaf2d30d2109d1f4d2f9fbc164fab1252ebf0224353b972e07d1669e2048d0dd1e970d36eb025ef44a2b163805bb95971e36ea944111c1774c603d17b060e321bf86cc7fda38c3d440611d0b48075bcd2722df2f4ee3d4a42321aefb80770bdd52369e7cf859dcdd9c28cdedc3c31d9520c7a1bc8169a89c93ebe6013fa6ec7cfc42b7f4d9b468571f76b3b6b8962e040b9d9e1aab6de684a2cb6e7207c25e536ff8b067b323a7cee420e9d48e8a042796be3caae1a6200684b6c68e83743f983bfd369530420ad03b24e49fb1385d2f58b62bd7e3ff48f767a5784dcea8a1688de1050f64a462abaf2393d32f20fc524e28138726a26aaed2df4752bfa9042ac6505bc7b2e7767cceb2a6c76a91a5b6c8a9a860088f8eeb9c155434751aa36aa70e20c5e6bf2d01d047c9ac175fe2a2d864171285fae11b77dbf1cdf92a5ec2b832c65e3c8b5be23277bd73e34409006d656ef925e2b450fed3e5ad606ef311f9b3edad61ad6a00afea8eecb92564f807fe56f07f9b3c14882009350671e7180da436495904cf642c79ad8cac9f527656272850a3271895afab41bc190515728861eae09ffa07212051879ed3604f0b84f48369c3a89a485b18301ade0e4910752df55d8fdb695c688d6ebcddd1b8c66bd043fa94fdeac4614bd7479190a39105a703f3704e10a8ce506115378a7ae5bf7560d1d2d7e87c07d4655f22518d5d972cace6c4683ac36adeb3f5329b25fcea9808ead9dc4e7adb093d4ea90d9455da14afaf6981c89b3a55be722db32e849b7d66f7de3339907520db0410187dade875467f94663cf09554ab06c52e9bd7fe6a656956baab67fa012d71d4791a8863e03bb1353f8877a885aa9d11d8dd14a4519bda477b616b75a6f01a995ab6f424e1c4e7019f976877fde48ca23435a72f6542260b7a218f231fe0a57ca544bac83f08f8db2ceddd2a60ddf784610a439e39c0506ac2b6092adc4c9cba07f7772bd5997a976847f2907279c29dc0ec1bd4ebb03fb01a9de6802686fbd4bc1b6a84a6305dfe8ddee0efabff1ad631339c108e8d9c53b6bc470a241d5c4ab23033d2fe5d0d3b8fe68ebad024eec2cd6b75a0981b999350d24c4d687b74d64d624738705f0cda263707f2229f09cd66e68a312f07afde0d2c7b7a36c59b3f0d55d27d7a491ea8ef51be9a74f62e7464074ac99576ff352c562a16a6c46dfae3b922e8d111bda63335e06c9e8d7de25192ebefc286f3a49673f60896028d1f21b3f3890c1f65a42de80ef220c3972b746545195876f64019d5af8ae27ebada7ba504601ab7b854e1fcf63402ff6dc926d9005e5f3e864820c2235631ff60d0b0c1c222258f919de89dcdae7a08f383378c7626805d9993056290790c2098b361be0eb6dbefd9404d5913b37420ac6ad07b00deb458e87aff56437457becd6944e7e8455494be74e0aae5e172a26d6adaeb44d36bb907d4fa84fdbec86142805fc23888a755cacdfaea728622cfef09bb3dca44bc1926f7f7088f70aadeeeb908f26b5e193c9a5782704c9855ccb0f545060316ab8a5221db78e0d0aff352b75ead3474c4933db252fa79fb0aa8ee9f6b24943e74942c1cd0fad32893316337b41631ac9747f15967c03c7fe1dd1a2becc7672d5b8b39d3b6a7ef0ebed4042b98f94e11e9412d991f1e0498a811e44203bc4d6baabc840e639f0108983d42409010501ca85b9ae7639dc25cc3facdde385d9a0c2f31c512b9a72452451f79b04f277b951eea9260b54b7049bf76ecc50f10ab03c6c738f46bd82a5bc5a731141a74da7b4cf468806a11b3d4294c2a8f36c369fa11c1916e2d64b10ffe261fdf1e52427214f71d2f4968728d9a6d3fca425319d4befa1e601b7e306b0e83860817473eac889926e145a5244313785fd6cd2f74a08fc6d1586d913bed096d8046cfe21e8de0fe48a71c237e74e972967bc097a02982a6c6fd6b51c100e628ffb51a9715f5cc5ae9dd3dec07109487624e6339d96548b5a24d1902cd0ffa2ed3cb110714c28e95b94d4ddef9199a236e276a740ddf6ee87ecc25f4a08c2313b9b01cd1861a241e1abff3c5054eca70d9b75f88b3eb59780220ff71e5978b1ac7a408d1fa8976306a03baa91cf8fd9969548b24768123b0d2fcac4eabe4cb5f8efb000a97f21e947396ebdccafc48275942f5b62aa2fd10d375b6f91c856d77ed48938dade70c90e360ac99144e2cc9f7a781e87156ca714d022df2a806a873eb9fea376ea89f67ff7675acf74fb648d234f443b5b8bb722605181a205c74797e16e37d61fc674fad9553612ac94a9f0ff6bb343c5519ce12de32b8724314fffd46af2ea9e8aa2234c7153143f39f09ff26d9dca707e1b0166d77ce08f2ce6ca8a91bbfadeb5d2f3b6771fca1c5257b22442557b5dffe374d2df6edce76cceae38bced368d22064ac70990ffee385db72e65b91a709ac3cdcdaa7a2a18cf89d415fc716a3de0b86eedf386b7155200a4f0c6d07917bb28a57f19447af99ca868daf087d1f571b20d58af29642f5ce94a790219b06854b1754e95ace31d685895b294b2ec4e3c59fc21be621c520f4e84943765eef70fb260704ebcb0461847c86a43b8f79fcb44d5fcf20457a7aaa9899c1ebdd5cd262c3dce10e19d907c82e5d29672f2cada4988f19b037d92edd4806ed2cd980483fa7d757685dbabfa8149c9ac930523e7979a507c337d496c63fcd562800184dc45c80daef37364dd2a906f6dd3556204a70cbba6a1ac18f9234a8a2909530c71a46319f49e0cba48a241912e9ef1c5a7193d78e5bf182a29276838111dc8900f8422ec28057351a491f0827bf85a360593a5c0ace36cf0f5cc8bea2bca227999f7cc27baf1f6a6678eebefc95d2f6d4508e7c03082a44feba02703341435ed7dc44c60a5ef7add0aff3f7b46096dea1bb20f6ecae041405ed4e4221b4a0f11afe04f6174006c8e883dcb7870348cf513643cf7d80c6ae4612a0d333b9465031c008a2220d60e458d85f7b9f332e95550a7bdbd36bc10c47aa4c9c958e9a1c995dd2cde421e71b8c5eb9a966da28d661ee0dfa6e591e7971c9e373edbcea58bf742506ff360eee773b238147b2134d547d0ed1356f82f36004f5221ce5b2c06fdfa0c0c7cb344cc4e170bc021a663b548bc2536152e86d657156bb58094e3433f63ca55c8790346c9aa6d0c3340085a9f0b252e23f0c082fece3bfb7858b36e67016a4493c11d96615985a5785157a860dde043d0c6420d714ed40081afbc8351b5a8d37ec17965081a3476d11bc56141846c84b7b243f73ef168808b6d11549afd80b7b6785afcd7bd362edf866a28c4f32022235eb47d5182abac8b88f05a40c353cf61171f363c441bec2026705a0faf3eaae1e27f7b50f7230c32762753703d46b9cace6d6be744fdd87e76f6ce2fca67e99b7eb4210b071ae40dcde359b9ed9069363d6f1acd0c4859192ad0fb8170a1d79280efafc0abe0fc7229287e33714e915d3bc00270614148bc9918d1aa1ff6fe6aa76c86e202db3a5e3b55879114d7c4cee87ae0c0a94d3dbad70058c8fbeb3ca0e3c081c6bf051caf15957971b2796178304b0d8841471301696c71ac7907ca1ee232a07bfa026224d67642b3999a3bf498b7e58eeca0064b7800ee673b610656426429efe58f8524610bf654ddfcc8eb6c26914de212331627620a007d0793c51864b0ffe47d1ed3fb29cc91077e3020cfd3af72810fef9f92c9a1a578ca6c0d3b89fa899c04b4220b27e3e0d823fafeacb128d0c4ce017c319191812a0f96bc15e1a33f0cbb9c9b14cedf17e1e4cacbbe9f18d6a5cbdce6373e14f713f5e557b78384003ecfec86455dd3eeaf634c63fed33267c3a0c943f76bf21577c34a025ee1acdb8e199eb6015aab74e320b02c0c4d4b2e349d61cd52595cffa19796ae7b21c17951f7e71ea86ac079ca11f8b2e15d573e556fc5a003f4b872554a9b598138ff26f21d691992941d73f20fadf48a2ea8d5c6a168c1ffb112d0f6ddad7270b7db40d7272396da13745a5eb1b0330810da483c710dfb657fa9d57fbb408f07197c908cfd2da8f99bd5c8ba6944a97606674ced769313e298067eaeb945bee95c7523842924f74340c16d61a791d0e5aa2047cac3ad5bbb57baf483267071e28213d000765308ce16fd00ffaf06295713ecda21209c3b3f2c5fb66cf5c7ed16f8d233e88914e61267cd99f1689d55fa5927a081f72ba9e5cc385373b69d823d8958ff57fc56810b5d554a48f553007a566ca00309e27081aeb7dd20891a61e28012f44716457d037564a36637b1504a647413f9874a149840cd01ca001809163343b164213c6db50eb490bd93f9976ae93551dacaa4352a41590588b98b18cfa3ac34fa02ed3674f0b7d3b371022e3a7ed9bc0e5ece415d843019282b069114f964ada7d7df93afe785bf6208f6014dcaced76c43c3aed76c99ddd6aac0bf021940561da685b0baffd7a75c011ed89c38713574d6d55b8b7ad364de61a88b957efe3715a4e9a4d9bbb1d3ae9baa84c7b3f5fd3cc398d5acaef991f507ae7fb550591e6bc6ecf63bd958a3909660454d76b6e9c4e368d6a48ec230800ef04e5df00afef9b0c81193d7ba0329c1f2c5f24d7d9d8cba2fff7848779ff6265d2e6433e48920698c3d749da4370e59dc3791fb9b307bcee82a96687e1b37675ef69598ff41ae9bff7b9a6e411cf5648ffab5b65706f9f13810b6834eb6ad219ddd5cc51b63f330955760a850f60710a08e1ac3e45e4f764542add5a839d02ee8db0fba078ba20360bd2f31bc9399f956d30319e7dc15fbcb1b8e139ec891fb1ea1adffa10144dba3d8d21a9f9843e9b6b84283e73b721a7487c6c68b5db9af7b67ed37113f9d6ac9cd4761f734f21a1c0e23ac54dcf418f1abda08af96a899d4cc60ca1d02fbce37874b2ca1b7f9355217d999ed8cf51e6848e853dd68f7300a5833a28b5ef47bacaaec1e4b5354f026dea36e087c5a85b64999a3d90907ebb96b3326c797781f5b32c250dfb4fdba39c40759d205a50a0b7292b2102e079595cce470ba3e222cb08cf28941404de26a82d2ef518d946c4ba512a2ead1d0ae3e2148b94537a468f3d98cb02f4c057a1e28c930b74dfb25fe2725dfcef23052fbdbec6366ffd5a6e31210906ad384430db4f7511b96fd8e33397e1fb3dca3df83d219b630f07d9c79c00c90e2970afe4d85dc96714fbb6fcc237c67d77a4f67232e75e4f99ec272ed9e7b3b61940353d69de9b5e8d9b6a9fddb363893b8608fe082146cc468c15fd431eb4e756241defd02e4bf913f0f3679e840af9a4cafb8d99e700883ced311aadcafc9ff298e5cd4d24468ed8edbcbb8e96d3869e5f1a2254dd660acc06dcafc3d5530185c9a99d02780cc7298cf2303f7ff93e72e6e23adb271c6af3de1bbdb20cdf9f3c0085f4e6276559796ddb60aab87460101c3b83f390f4f54c7642fe3a38a5a2464f235b91d586330552d785c1e77e8018296aae50927f80ad0ed81d06df1a62a4e4b6cf77562efc9e458a9ffacd180ed4bb8ec22a5ff51baf34bf25b30ae5bbd08b07d5508e504481bdaf70e57d744f975219de2f5ab0e5a0bab5dce1d53a98ddca821ebf964121dba0824568625ff7b219e4e54deba28605d67c2e2f59c7116e3e6d8f6944aa94abece547c27e9a9ef10972480c5f311ef00b97611d2e08714fba905203caba4476c5b9745802c6cd053e4a369ab4318d0ff126129dc6c4d53431a3d4a41087c89a0bef21b7e9cc6836741de80c0a82a4309f73bc8a2226503123eaea91b72332fb354a247b05d850801c1e1c7181d5038cd236bccc12f6228a9fad86efb440460b9fcf51fd7b9057fa106bd416a02368c3e1197a3e760030a13501efbbb8a10c71dccdbbd921ec8c2f06999ece3bb3ef1bb2c40b1046741d597b9efbcb2019a993f119aec9c32c12884b98552a74fa3559b593c0b2dad13030142bb3f2040feec6572ea23387304b35758e644ce2f4069741539bab25e27abc5f9210c1839fd0ccaf916aa8773ec6c6828f10bae2f4f4d852b135b3892888d13404ca19c6cbd77ab04f745c41dddd25300822c9ae7a7fd9283fbdb974e0c81a5639ebe30a53af75f2411a5b1ce222c2a3622b4ed34ea6d20cc2d0a3f5adc356f768f93aef28ac4f28fbc67c5db4aa0d4973c9a32fba4b0a09275b991b8de04ce7aee44f4d6b42564f262b5b25f8ee3e8ea66f6db1e764a132eea337876eba04316486870b715b91846cab02c91a860f0f46df470abde1135782044d17c077e2bf036ae9041616ae65d04de6f8159de21f31abcff9c54fa11700c43c96697ffac89cba1edc248c61618bf646cf22c6dc5643cf26dc775d27a1d11c6f224c6ee55fadf4e6ccb24c329ff4d07f619e961a9f7f033ac035e8af8eea69eeaa8e091b11072b4d18e1c268ac48f4b90fbb038ddb58dd534cbaa168cec73cb2271a11b91b6d8308383fd34cb691c0a59aebd6c49341e0e73cf34ed4860da097283cc7901ed61f00715820ac3b3847aca1deea3e9e00e944309ac9af56b532a37934d0bfc8c5dc11ae282de4bad961afa219e594d754dba60acb37630f41c01428751b9fcdd5e388357b1e1e92e0fcea4e173d7e61a0cc6616c9e6881079b7235fecd83af9c88dbadef54f00992acc52ff2f09ab2b76db5b647d57550f505d36aa395d527f554117f4904cba9a520b89b955dfa179de2b82de62f33949730f5acb0b2b05282ebda66a5ead2f5ee0b0c35734985a2251fa5bf3dfb1b5f6d2321a8a26c3896a8d022dc2b8af59a6a012e4104ffee552790a6a178da614d2d99e3fc12ec729c744ba65d3bc7fd5f649e27b677504aa1447cee80c3818b6985e2da4c6c46ee477d2be96704db53ed4a08340fb146e9a7c7742fdb886343d07ee4dc4443efd175639233062d69e241173b23835fc5ca1c063a59ea472deb0935e7b016ccaab33ae7475580fb8444c5c0b27113bf93731c4f25069c463d010d003697e9a419294589b250f434973e36f9f07dbd23eb3a3e2446b635ac007b1c93cde8cd6da32f4beb1a2d79a4985862289370d429a7471e8fedd2696a255aaf63f11712216a2d525c2b5cf5c18bd65317e108b0bad0e1bda481e6b25dcebdff3bf6749b34b540eceac6089c510ecf18a948b34760d15e4799a68fd442bcd35ac217c34e6fcb104ab49067c9a521a1226b823062703a1f427049bf44ec72862bd48ff91e295858f50151469e43c19ad50ec125ba7ee6145e628afc725fb6e92ba16de21437645add7ccab044e9a09415ad32ab5bcf0e51bbd18eb8d0698ee9a7a27d62d757c3903a85d69fe5ba6483834c651f5c6b1d9213476d72f13239adc1eacb8f6a43861796c32b6245e8c29f57e5a96f2dab16d2de9fbdfa42feb2ab53475521c16fab8e8488233dd38d6a4d7dda189cfc4ece86454d35212242d0eaa58761cac8a0c87a3d4e1b0ac3b55ef3837a26cc70208f7a81aa39bf7ef55b09c1b0c91f1ee0090ed9ed9c1fb53abc566fce3fd72a4aeb8246a674f34b66ed1539079e3eb00274d72a35c8592d15ecbe6f5b986412b77c6d21fc45033c4877f623dc5ccc45211afa947cbdbf9d041ec449007cca944d44c0ddc904c27727ed4a6adde6b51322167caacedf7f9683d195bfe270865692ef26f02e8f270ed62fd918936cea0c42510868fd3f6507ec41a653bb1ad7c68dd01378c71c239e8af241f3209e9d239c58c0461e2211ee7489343f27d08a7dfac47b83b7dc06e10990f6da046122ea5085a96bb9846ee2f1909d8c9ca839acf948b6628444579fb68c1cd9ca934a7eafed287f948dccf8199960876af094c1684fe4f9ca7894a5cfc8c62d2ee5724fd96fd95cd22117efaaf3e42d4186284dc329d0980d14e72e134d4c0c00a95e6e17ed6f35fccec686f78fd3c89ae94e9bf2477d43084f2ad8012c4547af937d32300ade4a9b37e0977fe73fcf84af1ae493fb93eca1f1f5d10104f3abf578a693fc3ab8c91f782202db4d4558cd6d116568d771e57c53efb0469a9d056edca9c24253d02b7b8be1b09999010dbbc18295fe25cfd36150f0cb8ac9e4bf860ff30136cebf52c6d3ae564902db24ac94b7d326f5376dabfa04555014997d1630f2775a4e7bbe2c1c50c764762730f6c3a78a580a081d52ad01019237c2141c12b995c7952a7cf2597ab97db47699b5a7ae08b5a0088e8dc98621cb2b469b7f4395fb2860672236e0acce6361c196afb9df57f53b0d758d74a1594f8eb6f7e6cc307e551525e5baf70f3eed2ab25bc962e2564f52cf8d9569b4c8357d548e68da8e62c7947e09800e74f9ff5f4959830ac2407c33120409be5831b698610d66c012c2bbbca260833bb62c157cfbb1afed629284a9a78e7e6e4de0f255b9bde91adfa1d13cbe970ab5a6a48340ebc6863fc5a77c7dfdcc532e78d866edd23f14de8cc9fc30e51e794463b41d57676b206a36fccfed6c24b02343225602ba28e56fe7391f9af350a26aab1b4ef73f9e20f8b40615d7dc8e5ebb21c30cf5c5b526e173903c77cf03032dfb01154db6e0f843f1f19c3fd27b44d087c08516b274613db4e76a72bdf4049ebe1e6348bf01c9d63c228df06274ff69474d43708f5644dc7c37b47d28f201e71c93d507da9f6d76a7606aa2567e0ab5c0b6b5c124d9d89fda873149776e7b349f8ff27c4701a0c71f533cff4dbcc94b9ca303a49f4db00067cadbdece17894ec32eb1dc5cee879aaf3608c7b046696157472d4644dfe8d46e0cf5b99c69e973851ea3af31aababbe5b6736ea99b366470da334296cc8e50a8c9a23e4cd22a364f4f77ffcd232e03c28a298eb99297a15f33b02ba3f3882b0d4f5f01c8a0455a274fa51b101395285fe0dbea6ba08549582b737f33176b92e451cb10ab7b9346e4ee5173e8c625ca6895baf1bb034526f114eaaf8591f10ca06914f69cf704eae32f95c008fee458f80ef37d1b69d251ff3bea9eadf480ed2beefb3d7d1a030a04d50d01877092a8389519c98eb3f984666f446b806f9845f1fd9e4450702d69b59c7c3466fdc78030b5f2469c14d1691afea38a3a5d69e2b6cf9f7beaa96a378f5edc2cf07248f3628d4a7dae73817de82daf9462ff10827b06c9bb30b328877c65125677dc4ba14f3dfcce9cb138ab24de6fd243f6b167501634ef072db7194cefe8abacd3b4a90725bb184d2d3b419f764452a55306e409ece92a1d26461d585d8ed6a37913a28f85d77edfd8a859ac5f1b59e11260000258267fde8ce1c8f313f435de10f69abde66e5b294835205b91c14c3fa0ae197f856667bc3cecf548b8eaa3c25eb5bc219b97bebeb27f688d69d5c44811f30c60f1bb4751668f7d93f34ee2dd80ae3071bc49b82be5c941d91a53ae6739d22b30f74bb0fbbe00fa3ccf9ca6e6345deff70c6e488e0e20bf8896d3472812413e90281694df90663934816cc6ff8e62b35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
