<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"589784ccd79889ecebe7572caa96d50393fe84b1c9a3ea2c4ae48382c4b6c26dc2c1c396accf1982d1a9fe58c21766791840bf4657cf8a6c631dbed0846e601818f4a05f85486787aadd89773530a656a0bc7fe6a6d6837272613147bfddf4a6164da8075f5b938f3f44f16ce54af1a2ea6b083d742fd2a03370556d0cca606e3b2c0338524770d1c1e4c21ea9825e8bdadf7d759d173491674909c3cdded07f2ad73c242ccddf32ce6c0f7d4ee3d2f7f934f7e740f38870872ca564019aa7e7d1228217e04d930f40bc3092812f68ed66a78020d78e415bc745c5703797f59facdac447e12e49fb3a10796fbadfc73b57d33e9bbea72aef0cc60659cc3968a325ed9b7ba87e72a0d89e2a998158c55b7abe003fcba332edcd9b1be949da3f39f6d8bfb8b365947c77c745bed6e9371f510b91278356d92888d17bd50a4db156324674676b2d1daff3eb8c4df685bf02ff9076b50995186ac11894250bda64602bb320a70381ca6436f04d0d67a0a496387983a1ff7c155b4592633c6df3e84889e2391dbe5902692e4c6d1920f670a25f79e08b186ca7bbf5f5e83ee75795b0e8d12537fda57921a950f7a93c04680afb6182c131e1d60fa390e2029743574a093a9db4eabac0ec9024d7e67fe80fe7ce8a66d1ed60268e6a80f085fe8cc90741a4363040e150f26f3c7c59538e19c72fb507fdc1cfeec2b50290ff3d84b4057a055b86a24363608d572ec59851e74575e3f974c709a11a99fd240f415307b268a2556db7a7f9df97897c98aa672b2436e39d5abed76638d2ff0fd21894a08b47be6405713f8d6ac12dcf9c26e7c2835fe033a0ba7c383fa0c8c85210fc05f3c0b31f0e6a2cc39b52a7ac7dd056c31544c05377327267a95dc5d2124b8714c26b443f1725dd480e1eb43f93b4ab34673bb62daea4433da44ebfc9a49f2d971b9daf502579b45288312a5f27760a5184b85a51fc778204c494353eb1af73e3ad5b72673858181ce31f1927171a762ef3ec9637dac7e2dbaba13826180053124902e39e4cf7b680bd1c0a32154cd8402a74813525093cd70377b6551a9b5b45996bf5822b016655bfbb7bd0949242eee0ed2089ef21512fde78354b65df1b4162f1711fb3a2674ebaf80b8a7eec80714dcb2a4a968256d24405f19e6278d321eb8c3b71a463f79ebe2417dce7551a997c2ae9785cf10d6d7cd6cd2551ae48b7cf4d2bf9c86115fe06d538c969ad9af274166e5e747db46629e8a0fe1e5f0a10d15273f6779cb5d7cdea9f56e4f470a1920c1f535213ef319a1e0b677252ecc66d77071cc7c2fcd36387f6292c858a4121b4df584bcbb842e852fd2749af190a92b1e2c9fe8b10d5697b1e593c5943261ab69a1ee1ec966abd7ef6a4b895090daa7ee00bc3e6a6a2b7a87837e8568d69a49b48d6cf6fbd4faf859ad40c23e28f096c55102c6ab09179a95315fa95c9299ba2e68a3ed0628ab22789365bd5c7bf9d889bb747cff541cd8e995bf24f6eb93e4f438a46e351c403cbcb34ac754991d0353428d1220b021c69559ebb68ff732712e89330106f753aac42a2d555bff95011c17036077bfb882afbddf771d0ffe20c1cd882836e025a56c1b08d9220ae0e58bdb0d1e4d727076cbb39470c0b2a4929170b96059c2550314c3b3e0ac1d56281820ae888bc7965cce44c1b71065b51913ba4e14df26abe39b047a0bd92dcc27a13ed01dc30b0e8b2fbebdadd71a47fdf1225d8928dfe1a491711b6cf3eab957a17dfc3b75abb487c1b80b227bc7f70b14e6e2490cd3dd9919758758694227adf6923af0c6f33a5845cc906fad19ad3f5c67c7bb6dde47fdba9281b18f1689733cdd0ba5c80d1f6194961ba15048c5835ef4289e44d9dd08f768bdc299bc1c078d5c0f8598b66a219d2b4e5b61133e3c88a2bc25d4440826819bad22510ef9f6d989e5eee90d6ae12a22f1cc66236027efae0b38f0e735d6da460424cd8894f7dc6382b251f4211478cd003d488c3da5a1e4afd8367aa0e77fc5d90b60b3e4c33842863d892c162a9fad0be14fefd91b0ad565e2e5cd52ed3e3d79c25ecb7919345051353a6ec5be41051c1d4fdab613e52a7b1440f67b58b6e4d8c0da434f7b2d2845810415a502935f2817b9454796d28af9e84847c8c5833da2aa8bfd89877dfeea4ff216379e5b141fd441e91adcc5f402b264ba4e913dd6cdd972f0eb1ef2234bbf6e4060f53e3120c9db9e79195b8d232490920fe9dbc9393677f8ed22a27d068022c187d02aba64bde967cb48cbdea0553d9d0db99c82f452788a739bb2d2b89104e8ca6e53fa2c62294a923c3c7eb7f5c8c38124f33da74dda93dae5784841419ef29cbb2bf32f53f31dc5005377d85c169e5102204097450f271e83a9dcbe589556c99aa5d4af59a78ded62ef93a89c2af0704ba86457a39669e9c25aa22de31a46c27a4e328650747822c54c4eba6953c77490e4ec0cbcd7400cbdadc2a2f1faf2c9c486e0a67a4f3fb1b8d29e01b5e9eab5f089595bb1064997725e19550e72985287611cd7ec5a9cf252a5a6058ed7ccd3826464906f3df83c313757d11da4d900fc0cfd88e595c43b65ad94332710f7bae9dcab5b577583913b857a8030e64ec82526240d6516bf19a098a89c0a871b519d842b0c74f808b6c8ff0a76b78c4897e30b41070f6b4643d1e8b2beaf526560538c43779207aafa105ca7a02344be803d7c3e20d0243830d578266a746810c135b2a5f05b7adc51ca827a39d556873d6381a85d95e5270090da1ad6aa73037243ca48bc709faf1e8dc24bf3aa005f35f3babfabad4aabe3203527bcbb5b1849ad067e434f5fd76f38838c9748a0587d877cb5a860d24eca33223eae8eb288a725726d374155cdefc21166be4ef2a96e2afd6b9bbec44196804b11c15f7937e5fa688b4085e9878382f6000274b2071f56ae3237a6bdbf66084051c75de87bf5527d66676dfbefad2e358c4b56b04f08a28910afa2c76f7c1b62b00a673f81800f1cce83839f9fa51389d725aca9ffaca0a94966c6729fdb89bd24c533737575510f32d6cd2cd33b09887cc9879fb2d44f7ae199b441397790b93638e2b297d45f1052bb389afbecfcee5cff6e46ff0e325ad398a82df3c6d08f8a6254ab9a6c539399d20d7c0ae054ffad3968236d3d53ae651880ba94e0d0f7e36a2f726016a7fdc5993a188c1db205b2f3070f24f55adf0cfb4f539dae073314aae2b53ea01fa791af032d8f631ee877e1c6330432a4d3018b61d0a28fa86960246156e300605dab1a331b36802109007425f1c6f1eb1b26081dd06fa9d5000501d4fcc0d0ff44953659160f707d93f55a9053738eeb3baebb43bd0141297c40431f71d7da107ae1e0c773e001ef7f55a55fa0b414a481d48bd693f1749b168231a7ba0c208824f53771210f7c5e2602720855a4ddf01f7328f8c0df5805a89b6fa977efe922e4114adfb4de9b348cbe22f04a917c0cb0e4bb0802e60a0982ed92fa595ea805e34944efe5d78949c365c76d331bb8d9baf3c194ee8a4d29546b2cd145017f41ce22488891db42e3c9b195ecc648ea2c32bb343c2501b46b5fc79902972afde39b522f76b1e248fe1a960ed23a2bdfaf09a1117b3b1e212da351f3446e06bdc8e792b837236f446205edbc9a86757ac3f0bb42e5adb94f81105b38decf6c1bb8a0538969800851d9b5513fb9f0b4658481a7f061a01273606d158dc4cb7821e4687dfafc2a114cd414f059550fb014f4751f6a897ad8eda3dbcf96813b5af5dedfc54c4042755e82c38c79497a08c9f46648812400f76225c54535eea94d6dfa8365f9469805f6ffd8f3c445baf9d6cb6eb1907cda4e75c0510b840e823267d02edeeb1d0af97ce6de651d6c20eca010cebd9f72e25e899e5dce8eb4506e7aa3058a416fab7ca62ad2d56e7be622fd855af3db9235d62bdd7ecc9eacece573e0e29ae6dfe8f1eba0e7228ee9da1430813431397c7f01183aee36e9ef2a56bab81e79b9ab7a106ded9b396b7795f701196baff6bf6881b639f8e1eb87becce6554539b5efa5d6889584f1956a5eeb140b309923afa261aea31911382dc0e7533343060deb6febaebaed2ff4afed2679d9b74ac6a2c4801eacc8196689fbbc1d5ca9d380fba35f0bc5ac6a6d3df42e66e530edaabe42c0d21f70ba1609a28102e715487349d0f1b1135b30c3872abd07b5b826b5dd0b7cc582156559f7fd1205cf448b95c6bad93062ad1f5080fd8bb6120a91183c1f2e61a6cf4ea19ee49a5dd1daa400e4dfe081447a4e703b680e46f9a27e5fc094e2ba76273856462acec60c81cb54cb4089584fee0a1f59f1b5ae82ea4909759782aebd0eed7d836c7b6787201b79ebb07e7d6ff6161d3af899229fbc3ecc142ec326d9c5aa8add5ebdd7dec6d650f34d1b0fd8f9e8de473ee93942e90d136e33d737b17fd40a6f3376c204832ffd2531e8d94135a36ecebff72fa5f57a8284b2ac54f85e532be3b877dd9bcc8dac48b15a98c4f7be75b083d1dc16bd0244e5e937f9d47476e886077683575be8dfa069c66520f9fe7ddf005c882a1d5489d640fecac7e39ab10a1fd098cea92a374c389e7117078d94fcc942c341039a1f8bd752944326597b62dcf3f5fe1e7390e0a4e7c18a0dac2bf7d7166aa522b6743e0e1b4e81e0acba762d85a2bcc42239bcc941be1df96d555832203c8b3a04d6e769a407e06897017bdc58f22f304093a8f5d64ea9170d12ac51ab43bd5c862f535609e8e196b58042177f76adce7609eda8facb81fffbd59c3896f6d55e8ea52a98668ac5e006da3d80c32b01c6bbc97658e9006dd93c12ccc5aa98d5f8ae57d31144fc835372d35c7b256ed361dbef9af3396ef6d8aa78bfef07ddb72655929cf75cee60fe71d95b7b63c72fa22db677d5981e755611738ce70d24d62cc108419596d8aaec526e12410ce77c1de7732f21793af62f9aa577b567b5b9a749ca322651646f53b896bcc763f09330d46c89a9defe9e2de26bd78e2509911ae052f54bb458d1eabf9ccea54cb45635440cb8b6dde8356caabef3a9b358b35c86593fd0cab59afbeb66b3edb93c59b320e54f2459a1e103ae3e985864c99698e4d3839af009242c9feea8082d48ba314ba0a09c3af33b70848dac26ae02af50b36195acaead75be607916a11432c0dbcbfd8224ceba9f500a1fe976ae03bfc09111144a3579200e4a5c32613fd84cf19c9661ca6852f68bcf42b60dcc9921c38433d809afb33de919d9451c3ac77c347284070854b4e35f6e1b6f69bfdec258710ff4ad8d817b5c94c9e74b419c4e99a26e9de28a832e4ac1d7b71f289a525d503e04695cfb1e32af2ab52d2a4a9c11f70ffcfc065c05168c8a1e2ddb392ae512b82c991f03dfc8c03a5bf3fa7c48a7753d0a2bc2c3974867e16856e869408e2b6e007e38c01ad8351bbc1bf85de586e82313b457094d3d61916ab7bf3ff7fa571cc682836e8afdb06f42f29a9c51bfac771d36305a2f38fa088af7850cc41669cb3a09311e6fdb0fe4b74f8c3707d7a14f97062717970c9f1e9290d76baea7245f6680dd648c2224edff9fcd3fbfcff8d900369e814c0576bcb5093ac077abf87758e8ca97f168d9bf9508355a3b0d12141deb35a7f569638ab2305b1429f21703a987191b3d9e1e6cf4c2093c6819f19c2e40bc1616aaef51a9ef1b5bcf6181d04e945345bb9149bbb0a4557057fad5b2ea918a3dfb82ca29e8285e19feef980498c66aa789733bb77e0192fcc1f9f6702f28d298edc69104f1ef3efc61a2be527f35fcf118b7edc6b7019314f73f2a2d6c080828fa74e41d867d2759c93988cd53c985207b5982baef954762b0f080499b9ee3a669e1b9d22a73eceae51c10a9cac9322e66cedfb4642cb9aeed1c088883ff429ef15fe3ae0a2c922e92f365b16c6ee4bea4a11a9de55cc712495a291a1570aa2bd838417f2036a85b3fe13da49cbcee66be3ba2ef782368b022082ef3a43cbab1ae3c76d2f693a083f55dd904de9c3f5fdddc656a2e4e6195ac07e927a188205329201408766c9eea5e85ebca39056b8207376da0e603edc15cda571ffa7736200dfa7c4b09f48fc29c23c5dbae461f826410b0bd3e2c1ff000e4b5bbc012de7ad9143a2a92fd7c52103ece17bedc9042c1dd7221672160f8e65d26ba054244ef73ad80e1f45d2677392c5ab12753bf1da7f3356cb92d0accf2a6d78e15193d651cf0c914b6c0fda6eedeee8c2deec12ae6b913ccfa70f4133b32a800f00a0278d69e6febd50ae1598a8e6a432264e8cedd26ebd6257d8539b283abb8872ed4ae6511602e706d7c8e495b5b124cb196aa43fa5373cae80d39a4d2a33eda59747d18009803e9db7fd2e52ec17d35b574abd6182510f4fd41b40e79bf7a57a313c20f653aff337f58e0fa2728c7855155e1c6a52e54fd4610ab338df40ed442025e0b8182843be3e808ce7d93db452af63634a2f9bc1a7deaed48d7815618f118f390406e82ac79e7aa318e3a935937e1f10e48a43c46e8278aca7dc00af6c8265a400519719e342a348fe12d29702a23ad57325bbd93965f0f990ad106b4e9eba66e9034cb2efd2c0a16c4b96a5064b390ab2544240053975e91c2f863cb6f7ce5e7d40f6fddc5f5c7e501f2816ae62304bb22a2aa139a08e99f374f918ef9ae901cb16e435ff2dabe33df74b09feb004b943ae95eb754b3485f3215d615f6b35e0532effb3dfd32c866ea3e19c922972832f8cb1d9b53d5f0851d2beaeefe12b53f45a8dad8aafc70bcfb36aa74e9c30bde7d5b8effc05af94c5a352258221185612e32b467cff51280d0afe5f3efa60acf1d6667d1ccba16eaea05b305a10724f5f7d6b08f462737c2552411705360809ebaf04936c7d093e768172af60fcd36a4b8af6eda09264aa0dd970b6d77f6b4b5a1beda0d60db0618b559bb5dbe67d95d4eb07a21934e7d7a670b1db3a836055c4dfbccaacedc4904827b88c02be6261239a91d31c2ffe5bb352ec9458116a8061c096baa3c00ac174a12dfa69b5e9509cee576b35a96553c21ab14bb6b5342a07b0ed8c871ab0bd2a67784b3b76811223874d000f1c1b1a84037c57dbf0bb3d9d2924b56779762454caa39a8897629ab6983e0680a351bff43d18bfd6ee24b29e250dedbd365878c0652dc18c858201abd44e89fe165ad405f94dc0485e234a24ab34391d4aa0c98d56ae62713d9d4bc9466576c74d528a689c6680ddedcbbff5607d85fc9d1a1fe3488f9448525a7f055c12b46897f9f389961f7a2ae77fbe1d349b9201f6add153598fbdb8d7c32f77b3e30f00be2d57aca4dd8339a8f1ad7f20618f5025cb507242c702d9468bf4cb9529faf957af86f5f7e2178621afd696a9dd454cbb94129df551f8d762ad1f178ef853d33c4bacce587885286b8d56df172fca1ef3cc679f98bda6f5138d169a308428d18a8f5b2d8a458ea1d2668a7c14543f94970f9e3e83d8cc33e1bc2c77754ac07b881429081d641c29ef36e187b3d2dc0bddb3d1edef18eb29ccb8fcd9074ff3753fd7e9605add9e5f0bed84cadd9a7aceea9409d182c90b277642ca62cd10b367bba265a324b848b541565f3692c42280727147b80bd65bf16eb67560bcdd199eabaf6c18036af6c51dd1df0f8de8887d7f1013a8f1c5c86abdb6e716d165f51497e22dc7bb582eeec53a24dc3913b3ee6f69fe2f523eb498a5434b53ea150e8a3480e1fab6137c89ef88d129541784c8cafba27032c97021404ced5ceeb4d62b98f822ffb709a855eecd9f8d78cf1ceb691be6d13659d003980590cb146d473efe4867691c79bd80bab631294a0227f96c3e729921ef78441c87feaf9530c2b3ee6647e79e0255c56343f900a731a7ee8a7e4fe2dcb049ac5a3ec95a4bee83e152c842a3a4e693c79aad8d9275139550833ced15f42faf6a9430c2702267bf7dac7e698e84e2b5d3f67bc6a101db877e066aa723a8e04e2d16138040b362bc13594dc1a6c3c777837973c831ca251b874b7f4ce34aa6e5bfc147953923fe05424696d950e68404e3fc98c3445c11c8f854ce98c1917ae1f9e156baf8a52f1fe4a0e069328985fcfe882f1463cd685d40fff69b5ff2e7adfa3560d4578dc3cd7d481a10015ef93268c57683812db912c6edfba658ce10c75526d8d9b49030105ee85a480868097a884a819106a2024499e56f70b56008e8546f7555c373951b93ee64b6633286edf56c4eaef42a76bba93f82ce49dbe74520538f44d24522b28366e25b410d844e1a09a39160cdc9a332c3f9ca6232a72ebd9c32619f3816e93633a41f75a3a55a780ece405ba563a257e41e4be13315c7df8bd02750ec0788aa497872c2be6c3c0c1225140b1c90d1f94c71815fc3d5b4a9c41f96b99afc6f947f8bdce60b33ba660bd55526a3b076b1a25a3294437cb483d997d1d9a8b77fd3782b44a7686eb4856a862602a2d8957a973cedccfad54686104b1093701a4d20b4af71474d89fec6ae727371e7ae4b9c749e81d0feefad43423fd942db41c674b4c0e62ba52492310088485ec3a4a9ba9a63005621aeba2eecdd7b3dc91dd63a43768131dd87050c6535d010ab1459bf32322a8884c07a66b733dad01b96ca6290ead17edb94ec142ed9898cc272a7f8378c3445745d471f9f0116e9dd49186abf1e7c8e7cb9830a2d2ad3f831c9c39915b355114d303a19a734bc0677b802813ffc868eb299376572b57b8fca482c415dd12f5c561601aa1308ee4e6bdcd93f13d6c5b1e9428aeae9f3188cfbfb8dd0b829be845f0f65dacdd140f782c706777e8c59e3c86f1d10f9027f85ebac4a6362bf84d047d332775efa44fa6e8efbd0be66c6609f2be52bda92d8d67648dfda747e947abb5aea109d968f7ebe9dc5e090c403ca3c1b5b992160e33d4e45c3b75b4a494f6852909145f6e9893b02b11db27bb948581e1c549e32fff129d1f81c9ed9a3e2370ab8b51d2d1fdcd5f8f06d58b2ef3e2b949dcea3ca443fc8be9891355d0f0904a0c918cafe951d4d097cc68461e22e425fc6a9ca2f91db60a43138a237dab2203e0dd880afc755d5fdc63abafa85d8c4c98c50814c533c5fc96403c947933bb30cc96944f0a446632dff651b10c063443380a8009de8f3d3571ead64935f1aecca65ea5c9340b1410045e8bce9f4061a64b6dfdac7ee1a85ea40321ca8fc070975c03501fef0aa184ec0b5c0e26912b15e129a257a44c5d1587de660aef89e60e823af79cd3be3cfb2ab342cdcc769cbea24c0689de359c726a752888f903f10c717e13681dcd37460c8ed7c939d627d5050db78abdaa21f7f61ac37035d3d0b3fdf9667094f7d2807e014405b8e75ace089432159306e2815b1ab83cd6e33a844cd9c4bc11a78bae886e673bc92c6fd1c75d1e32a2c3913ff2d8c3317623b656bbbe3c9a80709ddd20f7e15f0e31b761a17eef590223b5694d00805cadbf5910361b1c6f26572b457bb987711849205348414fdaaf4947999168c3cf889ab6ef15c3a62ac564539d649b4ad8c8324726e6611888a47a81d658cdcd96bf0116eb1955b0da8813477c2649ffbb5a26339349090f1e3660eb222a1254741d583f1efe1c01a9a6d5cc521803f2a14147bcc8340aca45e1daf2407bf1a76d3f52a4228e8d6219f7ae53a24ac0465130ed9593c48cc70898324d05d7f802b1c2811d5cae909bdc061823fdb30c5644bc5d6678d6491ea93a53af2a07c847a5c9b53ca8449a5965d06e6aed74df48e010ab7f086eec9361076fafddbd92b1fd145137231dd97c04b780cfc611d7cf44498eaf6413e4247abb6039c3ed5337b7b46220ad44f1fdce7db295648647c6bdaf4bf9168adc9b6105f58121c59407bb77a26ade246f09858fb0c2eec0bea7d28fc31f3b772193d9d65ee197e8efa06ad3b3949018bbf8bdf837c99d18aed4e8d16ee92f48da1c87246bab63e96ce116703452d1c8e4d48b3500359b61a3978620ae5e43e9642c870e4091642b555e491f7ccd29b34beca178fbf5f7cfb29c1a51b7502ca37a9f3caa00d9957fc04f2a0c3f95c3ead6c9eb63edc95c03e23462691b5635a6f9e669ee6717538e10c952c82746c7f7d09538d14e40ad22cce8c3f8fada82bf1cee72e9b29c796618b5d0b25664fac6ba354f390c2e1eabe0e4c720e7a856bcf143de6517673b68e849c4b0588ff79fb3a66ad52d7999bb22a970e38a82bbef9a84cd095b5bec2815b27c5e576017139544f9bda7f5b05d57930e2bf4284e496c186ce078975b0521c5db12ab4324012de1e3e221b043d15688b5f1b6b875fa2a6ccf0801f74b8c1ddc30e28fd349092a7e84c4783f3f8471f19034d4f44c90f8b4a3ecab8b8a733bca6fec5b9a2fd1f0ba606b29e968bb337bf5be15fc34182f5aaaa4362cb45316789d0de76ca3c84a68851d871a99ec6e0612921e0a22c6f25e6362b900cd24e42009c2d909949c76db40ef0a2ced7cfc438a3c638d60ed20a9a89d47ca9ea011f8e9258346b9e1af15fae3ae33fa1f3e11be40c1b24164e4c06b75ad982d0f61ab96faf72befdc0674328727f8b499b70e097df48692d154b68c0b0910de03187b3300526bb352862672a79054cff547c7da95842323fe658eb74d8ef726d95468800b07122ea3613fea84df9074f0595bc0a17474e84d61a189dd5be91d44017e89e6df37a3e1c8e3c37767451d68b190624fd23df192170093358975cf9b1eba5ff074ad8e67d2f02bd222dd93d0a14d1673f18660b81809cabf9411e9132019f3690ccc2f1ceb3bc0228125ca71105835608d586aa39e38033258ee7cdf924aa5d79cc39bd0fccb6948f2e9a6151a4ffee39a9fb03661fd0be4dfa8b3e1bca16dd696ee07cfdc4ec714f3e74c5931ea493fecdc5b3b3f4eafac1486a3dd735ac86953195793744b8dc7248b659588998ffda2665d4cebdebb92405fbc2224ff15589ce81d622f2188d3f816bd3377f5e3ec2d2fb72a1781c036c09d497c9be8e7d1324a8e77f79bf35510d6155449cb250c59886de8834ad53d974cdbf93721ecafa807b849f1c90e71a12734d5745db11e6731887d435c858ecb500197d588c0928b257ab89c2d228734085c9aaf6b2e4da2c93974156ddd3b8fdf90d13ff59475e0e4fc9fd54ef8d49064f79c1f7a663ed20f443b90a02429c1183ac3e8d58a3871e2af722334c817016a80569c81a1faf5a0261ea57c77d960b3d43a7fca332269376cfba50c6257ec16380819e7b39d7fa75cd9f2500ff7eba4f568d9e07f627e2d45e6dc9d5289d1d92c37047dba1bdf1e7b74d67e56c90916be232bd76ae5207b0aea17ca694f05fcb34655cbc81183a30b245d11726627d96054396a6376c1840a0b9cdaf723405d0b54841142e9b7a52aca14548388dac5fd82fc90da10980dfedd48734dde9426a612e0ee7ca0f8254bac3a5ad9c62afe129533bf20a6587d9b1fb64b8b25a36e184c057bd2cefffafa5553a7209786d9b491d25db84ad1efe2b5cc07e575e659ef42be1cbbbe4c1189c9ba0a3be9463da106c4528554927b787d163d41f62aba1b79617a661dc5a41f6f36575d50dcafe97ebdfece07deaee7ad43050d115e046f1bdc105449b43d2b607d7c72a644ef085ba70d1e73cf87ce4bdb1975bba56e567ba3198dfeed292de9c1a03ddd5fa7f6af485e849fa320f2b45533b32eb692282e3b533a42ae4fb4884dd84a17e953ee1897a07dedee7bd85e5e36f1a9866076d317766e5faa5ada13740edf170e2f7af0ab54bd932ec0951b21bd7f1b2e5aabb4329c2a532c0c17b1f02ae21c4f913d3318dbce464e121802323e7b82d396f1648c8b4d94c7dbd989ae021be9e0a864924819799fcb917072c308592273862de5a59ac896bde7e6a203334c7e02520c22a6b9a89f44b7737070520cad70c81fcb2ed6e9d7100792d3cb052c07d5600400df6009d62e48c63b53bb249a2f7114c24b57507f7707dfc09537e17764deaa3362f6687983ffcc625316f2bcd1d4217b180aa2dfd9244360f67ff8798e0b27b1a8be090a5f01bdbe56a97ddbe9760569b28bf1016a1f672a79bf84740bed0bf2e0d97e8b9098ccdb50a4d9416860b88e8928adf8c4a958a8182ba29e4f3d278cd7ac51cadc688d67878da8b6f57002db839416a5b2b2443800a9c2847c5b28b66c5e7442485d8ce5e0ec57e2a9045d1560dbdc83f7f5ee58c35c031a442eb940504d127c4f955ebfd95f120176a6b5e14737064d604bab5ea25d679d7ba8def8cc0a232c8380d83c295e23b9d6668c193f6de2bce51c2cc54a4a62da0ea540dcf9cd12ec78596eb915f2c79861695a57d45bda89fd2276f2f59c237959281e4b488ac5586006e6ad8acb2b4741ceb22ae1bcd8187d97c5e7bcb53110228fcf6442479d4fef69dd60f38acd28874c98d2217431d0a6df3da734da0e1fe045ba2f85e99abf26afc897d5cada3e421b900c26081fc08dce6f68ef0a8acdb188bdf6a00ec393d5be79521f42cb999facc9933020c58eb7b57c61679b4281e3a6c736ba23edf7ddd46e3bfed099b1298a5705289e23780660b5aac6273a15ab78fdc8e51e21077d432837705792e6bf8e53950c66ab5e83c815adad587b3c1c3d1501ac0fd3761b9195305c85b62e7b7dfde6717ca7ac8cfc37df8e620d45b142af3add4c667341716ea4faf7f27ce6d8b0f4936e21a0e168e69f1b68d9c26148ead885751cb89748a3a5a2c9f23413184d9563c83e2b3f6b5f5b3083ec0f8a9b032b5eb04a68614b511f88c9e690616d209871e17d350c8ae595bfb8ebb657af02a5e1a3ccfb493a368b3d6b125adefeb211e55b4d0a03c9c6e114845b1f393172dfb5575bb92983417023df817e4c791fdb257ea8563e3bd78a49d615d6ea17eb779aed1444338f77554aa381d3c53fcae6d908bf46a54528bebe49b3ffd074bd4e53d2aa0b9678327defc52be5952d471bd9bb162e6b72439b0104ee733fa218a9cde30b1d234825e9d992305aac2986587f2ceba79a4f53c2fc526e19f80ed231e46003b585d0e9d6a42971db93fc33d111be41fc30b39f3b271fe0cc5a395448939eefb89164e2b5c341117147a8b4eeec5ac821ac9442e6c7030216ee73e190024212d3f83872c3f161087e71b16e9a22689f98a5380d4f3b9f41a79a203b2245b49f3da73a4f8cb0681de518528bc631080ae46dcbf6bfba6e13a67f3359a0b9125b5fd0476b0c656f668a5b8e8eb40f4e0a4f46a8cfef43f5d71d16f15536547c40cf9e0c3b497b3a7c479330d634391fb3091ea1c0a02f60faba15655b18c0eec78c41ab526e5c07f3c47baae9c370fedc76b8de09b024458e849cea2bd6ccf2140700e168a6b6071f571ab15bc4537e91c50f33ab4faaedd2a205da642b31752a3229fbc1c388b44e7bd668ac50baa354c53be1802888489e8ed4fad2dc6c948a10bceeb6c234414ce948943a277033bbd9210ece6b1539b13b414a980682c3467c564b03f052501e3fcfdc8db17b34267bae428f6284b01a75d6f77ce2940becca9b32faa4f84adf25f7ae4b9a88308a0b86fee3c4c17c66109e0d143c704a629b7caf8b3b9ce1cbcd7a492349699472e9fda18c445f99ac711bd7ae81adc9f2ffdd413ef85cdf1b1af7462f9335e5c8e3f54f150b008b53453b9b18a65495b7f65f4c540e16af97e3e1b2541a07653e900c98c6b89b6cd5f8a155b6cc4678ee49553667e3315ed0406ff8c00f10628786f5f9826c4ba6e20a5f9800c4548d64a0ed2b39a3f42c54a6b699cee8c169e1e0935b65c279e02a0858c11ec9ac5ef9335b1f146f4c11f9b92d8cfbfd575191cbb720897cc319b867ac0ccd40083191150794ee27db3b051c8a2eb0213fb3fdf4765557cecbb8753433a35f1a771698df8f3babc1435e19503ae769b85147f9f7084c8f25d9e54121bc3dd459aff7cf25bf7a49e75759d350f132cca32ce5d2752a6ae8a105a90076fd1b7bb2b2f2d768353c3865292096265e7097dc75d97cf082fe618dc11f55b4d44f17322053f5c7fc628869bf451b2f36e155ff248a4bff9e0a8c932a6c8fe76bbf8c94d433c3bcf85fb2bc9923256d8d769120397f60a1fda240c3ecc7142ef4339cd7e74387811e97c876783099798acffff3f24b7c23e245bf9ca85df91817b9bfc1c6829870150db7d3fd491d552c728f49f0d01bc8b7b8635848d1e7f3dcfa1a23e21b0b266a43f038a9701d68f2be3031ab073532c5443d8e32559ae4b7e2ec966b5bbe696ae1f0ff5c2bbbbbe2fcc30218dd098832631a79e23b0f6874c7168a756d53f849ef60186cff968dbcc57bb14ed5269aa13e8f846424f1b19b21e0952d85c096b748b93a2278fefdd85c92359a9919e924043b24b2c32dc558ba7d1217c7df84825f528ef8770299eb134c96db51a1b23e6a2639dfbd7d7706094919abc52893f14c36a7d11883536aae7c82793277006b68e9e481baf7ec9bf9fb6d9d185c8a5aef5754eb96fff3d3045ac03a4aa1c70e28f675cf36982e15cbb9a5d574e43b977685d6205030ed4228dd7b29a86fd6850ee9d0d07a56a26ab86c5124ec01573c30a11f1c29aea97d16897b9656742ca0e214d450681238a8c93bbbf70b091a1e1340cd800ca7e2fd91018c453f7bc2854922639f263ceb5e3fa2ca97e522b21d270ca47157c3a77c9b7e4d3e3af683f8a5269e758471831","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
