<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"192bc077a165910f03e51cfbbe5e1a27c0abbaaff1ba5ac7d45c056a927118e2473a0450e622354890b05ebe55892540bc4be411f91e0c477ce7edaaa596d93d545c26151596e1f2b49b8882d98fdcda05df0fdae0537b259b89506424f8a99d51fbd351836818fc0541f09ef39c5fc4f28f5e36f9553203a28c716dd02a143005ac758d4b8768e50128969aabcbec20c8483f894766fd0ad8e15376a66e782c8003220d9e255cf1e995906d50359597def30bc78942a3957020455342b76df25ec0ef5aeaee32838ec0bbf6b7f00e6131e6777537643e5964792497a28a06d67045e9df0d882efdda0367334d048975b4b76b45260e804fa0717bea64af2b1af3cbc82165f40f9a990a43770d96258d055fe878948b80a2f21a70cde4b59b7da3590fa6898b4678a79ca0c1c9447253e726ab96d429ce09b19ed53f8599ccf591c6e4bc04519bf9ca2a924179e89872007bdf4211cf76fe6992c01d6fc55d042cc3012390e45f77fc5b4df4c3b72a651cd6f0f0b1d8df7c755ed4560727b9a1c47d63b7790cb90a28c9686984c567248a80376fa2b23c3149b08550b3f06cdebbc7e3d1c710b197af83d2e8114515590a80b089c8b10f113b357fc9855a3c357f099cf4d9d00695db7ec4aecb81e1e55890ef3520fd23e414a7469bc453b2996c9fae9826399a7a443504607518f3bda54d636817dc258491a7246b8c2718c09fe3e3ead00afa02e4fc3c6a8475256f024304fb655b644b0805f2f8e919b3541916deeb37b84e45db2df6c1ed2b0f686a1b06737d9f381f63a3b73887a97c8a5d211c6576b4a1c0d41c6890d31a11d0e11d06d50cd03ba3386e6d751556e17320350de1186f75c5ff591f2702d6559a269e28c7dd9d08825efa357810c5fbfeef83cbeb6b017d1ecf06bbaa7c679a8e2d466c720f45be8bda7f8c08b5a501fa2c626dbadf3595279adea278b68faf8c067299f108b423eca25666f5bbc99b6e19efbed971bcdf6bbf048c55aff089f9d647cc9c4798202425124d96ccb04b19b91e7059c7d2eb86d2f7a3127980706c30a3084700c8b65c08644d832e7ef75354ed5c769f048f4b1943f9e08d0bf3286ba27d54691230c04c0664b468bdeacb25c246f9bf97d6e857b6ffa3b9c575fe7e0418487bdcbdaf5c7ab282f1b9d2fb63c450f67c8798cc0a68da4edf73cc8da88570add2e710efdaba74e2e9b20f4767cf5c4c5309230bedb59b00e9d95517ce01a5a05450754e9b8e51faaf7035f4954d2f18d0d3c7973d0526fcf6e9ee757c9b2b91e9e25b56140cc652a170bd1d3470675b89718e3cf91440cf6a7b615ed5aff6bb5add5c3c0f6da86e80bb52544315cf209f8db56b84539c2f4ad1cbe6df8f1e4acca5c2c533334949d3c0620dc68e1534fc0bde4d92bba63947e4b1f390583033cb7a104c8f749039314eca85737069920596771b4619612260ee56608c3a5efdd9714adeb58d00b8c8bf963456813bec04887e72bca14419dfe27ef4733e75d68dd973bbb1a4fea5700fbe1a313a03405d67a9c166cf480b2d7419210a4f493b6f5264752b664df5927544e8314dbeb2af9322a9aac6698474c2b802b5c40829dbbd965b544461f86704e128eae4f29014b1912df78bfe2aff21a313fd7cbf963014f14ec98c736ce64261d5215f432ef6f71a474fe371eff21500ac95b7cd07e7d1b01c87d54ee35e56851ad184eaa394cb26cc0a3e7bb2a8d07713406d854e48a0c47c21f1d8a1ec592881c6657d964a0aa4eb8b172d5dd560ac9380da70a352f1a16b35745197a22bbce054f153344671748e234783e8fdafc034c6a20deead5c81d073d654e0098d9cf7a28658e8f24c27a16d20619feef9be25006b62762cd47f374c5f11b1710aba5bf6eb79bd574b90bd628badf065999f577d4b19876fc540f9aebd886d3e6a9410803ad05cb41d0e6f7b84cb61ad7fcf23b9d8772a65ba1e87a8bc833cae856d74bc69f33ec84a86e6eb5ea70cee37487351f95dd3e6254f7540aa784f0ec5553f164a9cf922de19bdf951de9ab621dd3fae3b2c02ec73d713dac9f49b3cbe2075e514e7e8a407c375558afafe01d176feb49081010c72c20c640ab5a7a94e1938b10b283aa624680f3a6df68a6c08db310d5e9da3619a1afea8331d0c363bcc5bae6073f60e9d90191396f06782683ce71f8c5bf77145a526a8678a6c70e32c972f4f706b1a626383ef3964bf8e1a399185b48694c4f125110957780f017ff15b2a6d955fec76b964beaa5e45aa8b29e2fe6c79f00de23fc6b58e0d00019ebf8f02c1abcaec5a24f1b1c8a2e58eb4d987024ab5b32662cd265fa96b2ab1032919be82569d50c54b9436b61242f2cdf2c7a3a939dc3231e334789b914f6841832476c060f02a5669fa359c037370515b569489cfe5b0e49cc35b20a4dbec493fe30329963410f230fcee1093bf2607b1bc1ca1c6d0064171edc8e9fb964d6d1f077f578ae54921495cea7474587c84e63300205ac2da94d0a5ff79495ed21be66b961adc01ddcf49409ecc567ffe645c9d8b190e1e8f2600e5eb97e1aa29c830ddff30922f335d81b4e222848346247e100288918f40b1ad465c79e0fc60355d8129b1430b488285701bc775c35e0903dd307d4cf8c17271ac4ce52be68ff825f15fc34b3fbb04c596d7be85b7cd42f9e035e1a8b96568a148033a2357312c97fdfe1955e95110792b8150fa6706475a1ca1e31556a62b345b71faa0869de06ae4304667af21739ff25c1123292cde8d993f4ef7d4836016eb2bc827ce481e0698742b2d6a799c970a94551e590bc74bdc79451cd85e9cfb5dd187946b5b750542ef596bd5e6e1a8a922b83d48621c3dd8dec26477861565ee4fd59e48a2393e4cd6d1dde547d971282db7fe2703bd66306764caa3f2ddcdfd67dc591971cd97eefe133ae0d8024e4b8737d5be6977e871fd9e049f98bdec5e13bb17c43ffc1181fcfac8c060e678955e33bc61a9fb7b13f0cf948c2d445704af1eea08220a7332e6460bdbcd0436cee45cdbbbcbf5b3a71411746209cd388d88bc15548fd3454963ab140f19ac8cc5362023ebb7a152d19be22665775ad88b0c72ed5fcadd30e69eb7d3f06bba834d13eacad71bb70e1e805c252a3e3ca90aeb7937b2f30acc4c298f8aea2d9fcdc1062c44cde580813b36e16212a10a6d324bf7dd73cb0effee684016209e4552c75e6a863fe8be31225722c1fe230bbccdcf758ab1c4c0c7629f0f9667f51074297c8a200eb438caad0c44996a1cc6c1e6da3920a1f0854245b633fa294e0d6461ab1fcbb47c26f9f3642f116d1797edb2c608a852d531c17a92f711e1266f34b647f59d46ece062206f7c20c6ced1fc3c71ab9b33878ca7499a76c8234f345030515df948a2b83b188c6ee32a1454c4f14981861ef1019f6b2a9d26cd7c53f80cfe18b5cb1d54ba0394a4ce3bb4cb0a3da56a72f026acb93feb09bbd5a466cd8fb0c7c581f58672f0cd06c0306712d92eae9a51fb726292d1b2524af5c449edcf434ce225d79d752d8fa4ccb9d294b2c0464c726d44145e7d0ed6605c921b21255fdda0b0d0e6e1f1561c7617e1ed22b77e27d309d0902db37958bd7025e7da8f8cf68e98bd45a7186d3014d6be93625f442b49d2a9a509f0fa9c25b054709c96e18043d2b1515461a03ed95350d504df132fbd3d4b75e549bd4ecfd3b85f6b56e14923db9b2a1e13a9c70b19d0578aa0a24d530ba90e6aac407c8c73f2e50133282704a72c6efa6249fcc484068a634baaab13bee29889325b78b84543c127a62b444c2c2d4ee69b527d1d9a5e1e330a3838c0ee69009744f8ffa24c40064f60f3189188f58a48ab0e3a65ef707e24a8382d5ef95056cc6f2e594fd97ce76027778d57034266394ccdeff69ff38bfe4d79c936f298b79afd8987ddae2e8de13cfccce3ac937feb3e18ea5ca83319b6b499f2d47d02d0f6e6e8a3eda252a4badf3af8c5c3bb79a6eb5a6d5cf8e0cb7a2c11057ef97be85df4b41659f5a11ef0ac9e9ca4d4c808440864593dc32282e748dd270434bb18aa362be3ced87e4720d7feea20acb8d1f0dadc13f194471e3819823588cc31b54f0c35236343f377ae2be161528416340b7dfcb8dc207566775020d7baba9852e011636eac7f2eb5b57af6c6fd8b4bb548bbd954053d8dd0848a77b5564e7692ac275721e7c7d5f6a7f8c4ea49bd02e1e6c66edcc14300060880ca6fdc9eefb75521d0e184a6b5e62d940e5d5cfc83718d58f88556c4089be5f72f24cb1fc30072466c5f24bc6445280c259db61f5ee59a3d73808e88ab6408d6d0ce662d0376281dcd56de99a9ec8fda11da57afdc160fa0aee257905dd769cf04a66f13b7fdab4c049605650225f74d23c0acbf72e996c7a88235603a3b45641f976d8c2d77aefb7350bd36b5eb2127eacd9ecd9a8473aa9ed5659ac4ad8c426a1c3b97e0c302d95924bd2c7e8b68e5dab01403a9e60b63678deeda6fc0f4d1c57603b87d476117c9ce1b75a77205663af84d7a35c39c3fce8af96aa5f1313e39009d003cbaca7a187180bfc6ed66d7e3450fe11defe277f0c5adad08ab1a1834464f6747dce941809970e70d2503bc66de3b5748bd87e65e0e4a7d55bfb751964d24353e48bc1ffebf7f8feb1ddf0b3fbf124cbeebc37500abf24c7b118903bffd42cf03e2714bb9d73b6e82ecf5896434d3ae78e889175b40d92ce2ca6de91f444423e9021e7349f5c464f009f0610bc593bef5d0be361324c13441b3c979af4dc18dcd4775853d88a1ce2cd5d718427c4ed7169b73d7c336b0f5353bcd6347725969723d26fdecc72e75a4803836bda2e00829b0638c4d7ea59468023f1ac55f6d3e69c5919f91a8001ff98c9387fe5bc12a1a954dd0bea10f031f50916db052747dad6dc41e39be28a64efe818f405dec545aac6eaf299773e80a3e2f03b5de0db1af52c13ed02564141e53334e9d1d74ca73d733cb8f2bdd024dc79ec45b5cabdbe765a440634e15e496d8c554751b57120d6dbbb08ba25c26896a4dce6f01a22759eaa4da362db286a5d21e9874563c65bf369487d55383921c9ccac0a01a5b69885fd1949741eee599490ecc1876abb05dce8b283a1181874e7a21830366123e16c64777f28c798407d14ce4fcc1a5f7bde447ce9bfcecb425b581ca1b2b2a77e7562ae4d027fbc29c632574907c0f794a5e94165e26da82554d605f205f22125ae7a253b606aaa5b401ec41cc4afa33ad4118a1d0b935b05bfd25dbdc006e0e3ef655b67c2ddb7dff00e9d9134039fff931a9f9928ee589e4f0d17ff70b592fd9cded098a2b85254dafb5714d46ff7fd7610e9a7ccdb1f816a9f4b816f451b355e5a3859dc8f8adacc000b630b5ce20904de209de2b55e1f61377df0f96b2e6c6bd5118a5b31d6dc05d4017d51e2452d1a7e70617e6e96fb055e757ff830a1ddf848ec5f421eec443ff9285f1bda531baf698893991bb6e79a69a39b7718b63b8299a6165b9d20201d2d117bde155510fd3b6708791e0c8a9f827e6e0a4cf5ed6ab01f1eea5dad60aa6be8c2229bb0e11b2f154ad9d5111e8330539633000e6cc4a42dec90fd7e641f1f0f1eec017579976b5ca373f15dff879987b50fe597eed111e75cc7d4a2a44956332ec05c8567044117e5bf2fb282c9f90951c973b7ffc5d158bd072e7684cb815a94c418d83ec8fd28c63cf094cdc59a23d7ca0c238eb481e1c5b129a8939796c5b83503fbaa6aa938b3f290686ba43fc4514e5066d6b397379538ff9029a41ad606eede98b38cc707a1242b866b49076538ab4acb485a408bd5be26bd22c40455f1a00973e6b7b42400a5173143dc55251660307f0209cd84491d4da22d5398e80a987ba417fe25404e5074b96fbb7f52d4d0451c5af3a9430dcef332d5478cd09b90739f038debbbcfaf37de2018c68f4c4d319fea6309112fadddf0710c45fc04b1889f85eacc2ba717be223fc5aeb93d3b9c0050f8d52833cf1ff15075bd0dc73abe49e108b45b7912ba8a5d858ed6d199f8ec6c28e1a82010d07bfe2f5fed623b4e6e6f9b077947a77804a1e0e71980483fde8707dea05c053e2b5edf021eae32237a170afd6fca2d15b693da2c9791db8547a99f0ec7af8dc19062773ba0be29f6795e37ae1ddd392d31e7e2519ca557deb113624d60732b8c4e411a6e920d1cf463844913d0478850bb6f4d4eea5937cf08dfe21dc29f2bd43fe3a349c667f1db55b29c4f3a1bb6ec43ca87ad149e7195f96f40ccd182dec3c684a40af89bd01f8b86fb3c9694c15370950b7f4fc8eee9d27761f9a976b4ee768453b16b6ba52ea734dfce0096d5096a4278f8bef07e55d9303c6b40493af1b11745e2569d3cd3e55c97c4aacab81e004a1b468013ee7764fac061641d16165dbd15d850a87cfb2520ee721d07120eb2a671b69e7ffc2800b387711dd2e2f48babb2a9896130d5c46a753046f6a63069fc19f59a142f2f81d523b66162dec7743b5c379588bb6392c8ac7f59108a8c9d55b1b7f125bf562446aec6c92fbeae83395cb4de89959e9aaa8d46ca6f512e47b4b043013ba9ba2178e0cf66adc11752dcdc78907a16e326b6b6383815dbd2e729bd0092f70cb846d736501282d5edf297fee0dccc6b84f3da7fca3a8c90b9708f8cf47c7efc52d97172b196e96603fe7e51029bdd82033e15a54a9c8d53385fa3f33a759fd1473a31489464301593f42b7cbcde9cdd1a5a71be39bce4e68eab60da90a494e2c0f44a8f6a0d40548c437d0e3597ef423420b5a7028aa160fc159fe215415238608f2148f72df9db2a5e9f1e273641c2e48ee1261608009ac2a375ac770f6e61bcf2fa5c6609d3a0ddcb0c9a4ce9c2f05f60ee5c6470081e429d529ae803cc34d633e13b4b305a43514bde6ca98022dbb3aa6d051d60d9332236d2d4d8a6d9226f101bc8c65a2ee9c4342f809db2a20987fb080c61c2c2de840911c52d5f0eaf9082e6f5f110d3d01818e567a532337bc9f23335430648ef154b021067190b17152796f24b63a901373d8e2348abd47f3d3072e2848924f4a235b8b557342268aee17d7131d5d4a45d2a6b5207b6de053c7a9390d6cd6aaa1408e15fc75c1af76a8fcd8fa9eabc4c4839c89c20bc1074375b958b21223b29e0c71e0c73e09dcdeb7faccc9dee4b3323cbd27f86706a9345b7cabedb6bfc30704539b18ed914b6feed4c24c03f202045200157e005bd6161b50412841b68f8688c2536e0d6d7ef827ca0afbd382e619aedcd62f3e978f380d6945cbb79f4521249375b0c546fd1da285c547c0bb998c99a60721bbed99c16a549fe283c00da8d0809630316b359fd9689078c3ee648eb77a4e37d9f9a9e159331f4b96705499ac80be0f0903310ef70f974f7e0e2fbbcf0a8b098d1e533164347a28e1f6f07fb83c08375faada20a788c0e889c9d8c693eecd5e5bf29b02faafcb717c8afbd1eee618051c35ae509824bb8185f2cdf0c3d9fd6502fb5642f1b738690dbb4c2ef140eb7c9bb46bd51772334ed794b129274f2173dd3626b39bd1aa072106697fcc9bd8a44eee581c1cc4d3e681f031e8ee709324a892e829388f0b118dff49bc5a2f048a56b72278acae503388d38ef47987add21d4355ecb1325e162f6adadce04c6d5b524359e573eeb01333d70954a40da730282baa18b268745099ccd956c0b3c456c783901c56bfc3706952daae9315fc38ed8d5cae8bfff9f06e67b967b6f770eced2518e6d799b74c6be6721c8a0ad9bd5a5da92edd8f6fb99f4d06b3b10efbac31e499ffada90eae8643c6564656dc458f5ed7c577718692aede13f696e910bde8e8ed92a68f1700427c3d85b9b556707aa2fb8f42ae03d566afab1921b0a87a36738a95772ea389ce161ff1aa74fc54693d5dfaa0a2b9e4c64cc092b272a06922c15b70072858304534fc4f1663968edd35b8f6010cf3c3d64bc6375113ce2bc52a8dfc361ced223ab74e25c1601232f0c853b2949685fa61e846720a927fdf7e6bbfdde664bbc6f55e9f02cfc5000685ad7257e5f3d40e2488d12ed90db090b8a5b14e5182641416a9c675469c522d5caebe5811e99b9889582e7b1b4f8e88e8afcb6a57876b1fba9e913c42286be404548e1b865c87273d0e075805f31c6b89e206dc0595f5471e137d23395e89871c3b9e8dac832c0cf558106bafacb94648697256c44b58bc67412801d1225970ba597e08993d12a812ba4fb2b9cb7cc65f44e89281034161da3b84b0b040f4ffc7f86a515b29eafc303080a5dc879d2c599bb26fd3b1c1b3c0537295b3eb553229cd052778292b144abb57f0fbf2e99667d0fe9a77788077723f03a24a50dbccae23d4b5007bb1d21b352e9af21651d4bf78cc21fb562531ec0b562d5cbe96f18cd11cd46c66c0207522c664a8d985e9322877ea67ef9fd0b7ec575b6bf3f21a2ae7be3c165ddb4304e83ef6645dca5fe998b5bac5e1236716895a22e621bd0a18fcd98a7649c51f95590c2eebe21301b2574cc6bc6ec71b7b46e3ecba43dc315227b12c5992f60981073a24aa1b42926b30c802d2d6e9330f434df6160273af6ddc5047a2729e9b24182a8405777463d163c4f46156f76ca709492c9fbe52a6634a437c863a411b663b40c840d6bd25095e98a2a3e88b690ca176321fd86d530dd5762cc87b8d9cf604da593886732a90b8f72b278e68c940b57a157859870a775f6968879037516ed3a9c4bb2ce914e561fdd7e8b949c6bc7783004d3bfdfd643d2edbbafcddad14ba79bb17ec9649829acb53534561bb8c289e93c1054cf79d595a4140f1bec911a625a6076fd756cb90c98fe69df37739ff18a20651e00b2d9046420b17aecc468ac6d50556ba42da0549c764a9531900808dffe5fe0e21ae5a1ce20d93120ae8f34c34e8bb480e040302033af791b9bd7fd7051f552275ff8ce22ba056d70c100552caa3f6da5ac82eb410ea891377057d60e344682696ee7abddc700363fe1b489dd287ea113b9f6c66924be69f5d6fabfbe7428ef73ee59c8c2bbb3978f8904ca58a9107ab6f1b8a34d305de29d3868a2eaadb5fc43c2cedd72e4b5f3abc510f3ac334d0e62d03e62d833a4c16194d979208dfa722ef42e59b7f3c854c2a835cd780f12bfe805357d070cec3eeee24e75116deb12957509f59385bf116477a7159c48c904dde15a6df40c56c92b236fe19cbb1c6058809f950c9e209853a38f8a868ff35382a527ee3d807dbb23683d6483e51860e5aee02da2a512bb0cc4c65459e560d683615b49760dfd7d8e9e2458fc1fe037331ade233204a966339e0b72c5869448b5b34db9f0b95380a8d73f885bb059e2dd3bb4f0fb8a28c7f797993e735d48ed0080b2d4e4ceb847d0d82efc14ba258fea138104052528a5863fbb91f8ca54aff839046a9c2ed707c83a554a6bd3a544e15ebd7e6345e3cac43bbc9340b24b613e005921f39b0ab0166c96c1d21f62be882bc1d1555d1db0c3a4d5bc5e4da775a626953f053a16ff12157b0606ca3f4605b9e96388831155b691f3461a302839ed642d87236ed96dc6b52b19291ebcfbb57d7b1bfdf1be5b0df41f7b2931154b76f4d321b38ffaf42481b71f4bfe05285fab7dde5f00714e0ef942b3bdf1232f3546719ed977adc7bdb53073c6ea6ff1a58f05f47aa6113a7080b700ee9919fddb57dd49e5200e651c4675b5d11ccc7e44fda4421c118e450e79016ece3d8f36da82fc4c5525c9b6cf8011af30b1e241bffa5c4fbcb9926e444e21e5faa85f3138d5994b9dfeab662fc79f5fe04dada740f5ba320f416311016b0094798deb912c939d015a25748d2df5c1d27323a40c01fa9d28e3631080c07e8cfd0855c073f2a6a4e218da655eecbf8d983ef6b8bc82ba992aa0884e0eb073dd9ef46b6f79f1430a91a55336b43325ffb566d8c624782a435b8adb4de2c7997af23f60abee45e3841bc665815474f830e531c62051485923b7ce2b2cef84c2d7e54901d7db66b0deca354d45f87d66dbd533ab7f125e9e658d5f886d1a2dea21c539d6c0c135fb9a6d8d4e0ba50530ef1b699fa87606a59ab2733c9ace022a9c8a0c19e681e2a72c0abef47c0357445e6318c4b91a2fa9a98eb3f590668983155774b835a228504c4941416cfb3b80b9daeafd3c5a55fcc179eb0af69351e22dc2ec7fe4ed28ae29a810b381eaf958992eba52b965f97903506b995b95b36ae9b9eda882714f17e7c3de05a9e5914d686db2f04bb07ddf15d6dec0940b23c5efec057c275a57735479c796867ffb74a8a33a0046e5389fbc1f97490000fb1c154e3f30101135cdf76cfec8cdfa0a3763679948c2009d0c26389074826df088e5d9c5363a1b440bbedb984a3c1ec799178c7e518225d1369c13ed202c2d76637dfc57679863773f61701586041323fdbba8333989560faba6c3589bf9cc2eb3a9b99a3985f2596681a92833ee4e6c9c66b353e9b05830c3973fd14e447f2920c9760d5b684594e7e9040a0fe5d431716ccea2831efeff73eb282410dfedf4646005886d3bf13c5cf876017a157790325f2d3d6471760a63119c4ce5b28731a0f2e46300b76d95b571ea6cd6e2ef5bcdce5d3e673aa5e9e845656a12b122c23677f2c362373bb20b6569a48ffc3657a7424a6ed7e597164a106817f4771a5fa90e9447c3b9d92ddcba2e2e9d8c00f51973b0ef4e6502dbe32f14a91c19885147d2ae361da8fd8a3bb3532889f054f938e17b190f241c156ee33954c97bb50c0d164134e8a4f2bf17c32a9f2aa9d6249c4e6ea6a30aa3700485362828595024a065fbb437da2e5e09a3a5503661d14fea5887f4bd5d6693dc2cae4cc7b71a3f5c09aaa9989c952167c37fdec6736a6582a6b5dfacf2967bc860794883281395a68f0c7ef7d059219331e35b4def27e21fb73095affddda018e366f1ab86abf5fcb50e78b7abb306720e7537b973e95b4358db76e80f61a28a335f5f899d035c3889ea153c01cc240ca893a9039a3aba17d2302afa8098c6313905899f05ddbdab3ad6094478997422305d4a5f1ae10aa843bf7378ce692706e99f279738f4e9f93c4e4279763262295d4471d6c555091fb3c5a667371a318217e285350c01f49fbce7541c36d10e7a18009730928ccdedb992a60501a38e6adf7caea76bc750739160ec2689fe4519a2773e9672200d813e9d0d369ae8165b526eb72e305999e002386aed6a3d7291a7fb3b0367324ecfff939f6b6c6f90d8cf67240e405727697fb3b2c5d3ded68818360bfbbdac40eba3f20037f1c856d794e2833d134d8a2eccd1700a4ad48c30a5e7e4e3dc8407721214784f371cf635964fea9b53a39ba5cc2601436edddaf738eea170943ec797ccc4109657803247850d4cde5d435acb8556425e55bd645d373835b219db0579547370a1be68f46dd5d866dd20e66e6f3737d72fd04209ed9154a6a2a3006220c26373d58b8d0def0d03b165f36e85024b999986e2adf1c66c4e92d447abad4bfc453a15f4b66301b15e92321b823a06999e2b5d2ef52bcc59bde68e7e85eb7d6c7984af48fe83f4138a15bdcaceaa9b2dcf2174308c5667a8078348e16bb26314ae599dd8e9a7ad577c503cc239a460340567c17b8865a04da6f0d1fdfd17ac650b24c5ace83291e65b47c9b632df672c0009d09a14cf7b9d6bcc16ce6c0180d7d5792dbc56700a3d9d8d5e7b83b82a8dfc10e51af38246a12a2d06901ea26a6c6b47f44c14b6d6b73384da22cd4188c63e810c01444c70522ca9029dfcf36289ef13ed17f802fe0adba8429a7ced23887dbce1dc50fb3a7f55cd9fa8ca831660b49d843397a4d2fd84092242d124b292c292147f61bb312c8f2d6c0580518f38fee876bac4c9666f54441453c2ee512f5653b2e22d97df1093fdd1c8dc0b65224d8d0d10871169bc9569ba0302917263fea1dce8f2dc47c77986079a000acf50a8c8f7dd6af23651ba3443560b5b1ff235416462c25e53ff9d13b74d0fdf35f875fea0e87c5a823a36fe582f4ebe1362b0820e9c1080915b1e0785bb57025108d7cf72c24aceb2ce2e94e08415a8d2080bb3614e681b7532f07c399be078285473adc2507fcd5d2e969c7f31e76fb3dabae134db8ad7e5059d2b55a3e0f5358af110e06aac83e2dd7995546fe8b68c5a6bdb58d0bb72eae7239c25084133ec13d2a2cd71391196ff11103b42871c081c7a280ce861fbeeb151ed6d0815c41d7722c1a6a2dd6752b2265bc73e9689766917f8eb3ffe59393b05e4d96bd898ca7387dd01716ea2157abddab11b85850f04da261f0edb52bcc6379d2201ddf5323fd8b92c52e56b0d952bd270e92a573385f4e69adbbdeea2ec803c0b37c5aa3e66881a5dc168062a867fab198c955c681da3b928787781e5b47f6c7277ac15281c3cdfacc511585e75138a175f6cafce36748b42b5781bd3edbf772dbfe1dd04689157a81b9acc068fa108dfedacddf5ff6457e083fb6499866a15bb877a37bc2b03755288c8b34e0da122c69600c00220839b87b02bf67e4b145c8b85376311bc71ad0c1eb0c5cdc13d7a6b322f62b544b905678a6c5d6cd08402c7f1643b8dd2205e8bcfc1888536c6672a6a0e4369370a08699303ee6f3f108cfa5785cf26200481ce21d0a4f7a44bb32b2021e12d2dc20c34a8a116be14eefca5aa9e62fd1cc633cb8b897036798c5b63c8badb8f5782a3549dadd89514d0312cacd0f25990708e3ef7edd46c2595e08ddcc3f7ee80ee27cd6c179add55f07c9b94db9ebb3b65821d60aaa512f5ac48a94e299f849d604fe2a218db6375044d5d24f54c2420dbef8c1954a4899d62df47a08ef649934d397411896d09ccfe42484a7c62a1462d76d255caa190a2fec0c30aab9aa03a2aa584f647e08e7c11d9ed1e55a33ecc645b423ec907b24ec8c044adce01fdd7cb74f4a08a5198824fb4d37ae536509b526579028843d6ce25d6637253cc8ea66e4d1685317966d3800b9644d8f7f0a8e43593feeb8d7e80fb053a9b970ee1b57b424f7bfc61127c58eccefb7b859d2a6a9bf867f86ebb6ed581aced3d28e2cafcaeeb14efa918fd715cd43f354b2eb8544fbbd9ef39f96380c20b262222a6a590a8a0e23741fe3ba5a5a4f9a57ac8977324006370e8e742fb2e4f9aed70945fb010eb646afc92b6c8941bd0a3d5d70e059e5dae63d6d8ba38ef9eedeaa95e72020dd25f4f8539e75f72b267190f49c3e91f0b315d04bdef9eb13751c27485fc1425a5b1571a50d686d90c0dc204c3735ef9260643532cf3f43b3ec83fab7947cc25d31c4702c80f40c85896dece397e795809b3c8cb5b19045a83cf4501d7978a0933d86efa801b4e38e30e1f86b7f194f646fd96f2031925af4494daece9934c93e7113b5ec7427040194fecc0d2a6b8dc98f222274f9eccd15f0e0e216b14f49630531b8264e8e12891bbc8100bcbd0f03c7564dc01c08d2b566521bbe60153551e6f5702eaa9d9ec8faaa57b57f893e0c67f59678bb5c4f8554af0ec16a9224480a6cecf1a9fd5c52f0292db02fdcfd162cef99e508da83977e7fe08c93d04f57fb7138ba47715aed69ec3ad6ddd2d8319876ef8ca5c6ca4b3136c35654b803e6ad1f7d16175c35c464783c6e0ebc5a57037e6e840b2137bb06e2ca77c61b6145189aa26ba7f77e39363783394652fe0e65d352d952d64e7a1329394d3f106a3a3e4122968b4df84cf873b49ed442a392d5118d6ca770916e5b9b949c8d895111a441341bc66e7a9ea409507f38d5bb53f9154e2149211b4fd746287f05a8ed2ba64c017ee8490bcae393fdba70b3c415df09f5690b4c3233d00b7d74de444df8d951454327c9e89fe8d0dc4eefa77d2c5fa1bff93ad7cafbdd9046f3589f7a555504d83991ec095db22a5d08ff43e2a0f92a51f721a082a7c3cfbf56930a6fb9e0efcd6080ac376884f451e40a0afe1ddb62523e4cebd0c0e25d925419f5e1d5f7351778c4285cfdf0e59a988c587725d10226b9fd1aad84fc8627057d32f891c51c12a21a569b7623f41edf4cded6efc2aee32ee9afc8ed3aeabe6e8fd254907aa680f423d983784107daad7aca40e4b8b21a14ae02abb433205bcdc167f2b76544aa7a3f8a5cb6dd8608b905f568906a5993ea9821147d3007eb6f5111a4896fd5e013bd52ba82228cc54736329c244a1f2f954fb00db007ca6768f7802a518f0515662bc9abc8985571616d329d43670d7df5d49ca9b949cf1030f75852348f2f7d85be9f8016d8b85decd207b3771a46bb7022f14eb744d32e9467222462ac398f4007941278099345671fa794e1b828d0d3b6d882e0ade7d4266dddef274db4ad73ec596e35e33901d6f6d26679945f86e0ff1b53d9525e0d2a269bb9b46e8f48bcbef8d924d2ca8261e0fd15fa8e5862cdb51f8518b05731fff9cc7108ba2999860d78d03037698d5a0546fd7279af620f7ba8da858d3a0315f3dacf93d931e56bf19976f30a609207ddd4021750c2115a0b67c5a83359dd439e2472462a7f289bf463792f6945c04112f3cbbb85f221232d7202d06116c44dd22be9d9845db15bb887ee5a271417008def1c39421038250d581d7b0b153bad375a5027c40ad76ec2529d5776e9c841f6cfa0e2bfd50d3752f1628a2e10dff44d2ab9586414fba0d0e4fd9349f0e2d1b76549a40eedd2083551e01f2fd2346c7de633ce053a22c7cfcd9e9b2285c0c54b3dcb635796f50e369907fc10a08740ddfed7bcb22a48b7f73328fe3cdb02072e33aeba37b60cf6f433a3416935105d8a335b960ec32cd93f04d543b62c0dd7545b5e7938af12c8b5780f5aef1c11ddb8a2697fb63b5d7b4436414fc0b464813f8914e2e9f34940ea54e894b282f031fd09e6989ea049d33a937c7943a012fba38273c341a8d58e479244d334fead2b6ed05189927a228a48db3c651218c83e9bbf5d6dd0955dfc9d4c2b8106e26ca80574eaad663d1c76416d8b925590f63c4c38095139d3a6f7ce8506f18c13ecf9225ba5306149fb81f9bfd6e6dd8bb43655f93e08028f5329ae3f259d443c47cbef2126e3b078a244e4cd37e8093efd2a6c4fa423b7488828608da1fb3cdd30fccc20a4443e66df7c625dd6d3b9ac31f074266a26f8bc8a5c9ecb73e3ca9349ab890fc462344137865a772e12619f5cb26bcc93cbef2e61b79215b6b3acddfc8637c585083d077250beae299f864ad5f0212df125d4d81257c97b2ced4f49fcb30ccbf2532a601a88a283989ce08fbaa06c46f5918997e7e3bca9b807b44d53cd9269acdb8b05ad4e967e6d0d793c7d4a9d24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
