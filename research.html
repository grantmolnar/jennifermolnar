<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d37deb9dded182967fbc25d63e2d71630017d610355a879e154ad0bbccb01932c8ecfb4404f1e02d517f3aeebae136381fd0e56ad2cf3fa5476a4421593eb891b1d96eb77e8e7c3c1865590fa104413001f1d45b9d8f1598a70c3d21a2c6c039653ba59cb02a62ac3bae75bf55b018c11cd0c1a0d8854f9658c9022c0b35844767961a998a808f0a4036ddca21b59c84f2a1422718404fcdcef8236a9308907ae24c7fa0b7d30e7a650a85a14fe790e417b5e21583d21dcd0a87dc1dfc20ba0ac35fad5ae3e5e731ecd58f9492ca00ff9565f982f042ed0a470ba830c07ffdc1e2d285736eba5b113158581b761809c7c9cefaadd09d4b1c46ac71a1d1d19c2c7f17373dc84fb1b29bb79f593b7c2363f186c069b4c08c7b9e85c3230fec402f19799a391b7f22dd2a19fb4be508b8e5831d7ff5cd0e769bf9a6a19dad1cc21557fea1adaa5e6d4efa7b5fa916bcdaa551fbb2d8f16decb8278cf221faf011fda7bbdc3447cf19b89664631462d7440f93dc9b9ee3f89414389ff1f541d0c454acb08123a3e7a5307ef40f7ace40ce1b8806b18fe55f4ff96356d4b4aa99787d59c046f4a016a55e0e614eb7f57e6694b3e17af486f536ed548556803b5c0c5127a346b7b1e30ffdb5e8ad0321bfa01b9082008affb2ea385f1d9bbbb11acc7a638617f8b5407e5f9da5c1eb356b9db861fb2d9236953c973d91c0f36101ea732260a34f545ea751e0f61e815e524cbba8c0d6960b02dccdf5e86d9d25ab2c21abc88b0b8bf6e46b482c7d40eb4777efa53adc2746900af132270ea058783f928ebefe020f1927de02f37f9803ce64a353cadb6f3cbabd8633754feee3c3ceb4a2eb49e502603ef1f05206bdc7e636004d012d2cec3add11e3844b6d9cacaa9e344cb08cd4069e0925ef7ff05fd049c2d1b6ef24e90dee35337f822099a2155aa54e8893f9620edb0699ec628fb3a2536239e7ab745848f55a13bcb9ff4f3398dab068032e6264128106f736d09ea6fd4670a2d4af324651d8dc4dbfc2627d914143955b081c70099c0e96415b3626f43006c43688c0506ce96086b01807af17d56def2909991e596246af6702e719bcd891b05f08330f531147d5059b28ea67d980efd08514f118c567bfa7496476de5a41a884a56b054f1d79cddefc557ae4c7c3edb1b0d5baeb3b6849d8bc5118a40865113aec56705dbb2105b225049224d150d21c05ddc78f678261adc0d44aa2bee757b732f1ad6d5e873902ece86fd70e25ef3b05872c4e404fa06b93bb36c66449e53cefff117f0f6073b9055a43c172028454d1abebf456bbafc6dd064c839b665ccfc30277394f933cf65546ff6236396ef3c3ff8e8edb9571545d3daa2b5ca3cce625450b9caf3625c9b4dbf2cfe7df111a11875383c91408fab466356b39da7258482de0b76dde3bae79a9f4657e1d393276d1c73a8649c8ee703653f6a458f2e9b9a5cf290f975f06b8d0441f51a38cf5657d0d3842dc0085ffc3e7c6942e1ff03e30515ba3282027fc414aac0c224ad667b5c80dcd80c22c68333d0fa1d1162a4fa9653bfff96bb221e5e7e728b770631ced0b4c0fbc21f49a749f86845a9304393e172f86404dd7e0d46387308863ec7880082ca75b4736e6b41d1a1d80bb6d91e54a62ec046058fcf068ebec6ef4aaaf10f14089317b67fca47c10e8662f22394dbd0fa6a9410bbaf2c4d2300b6809c9bab77b78b81f6bb9065674e15e15666ca4b5e0ee0523b8d694affb6cb2202e36aaefbc8d7c366fc9b2af387f899f0e475f713f821604cac9f07778fb2a2e216f4b0dbb20f59c74bccf26981a6137edf71175fb8514ab695974bfe944bdcf204f3af552a285cd6a4000e6bf408ae1de054eab8acd3c248323a6e013f40b8f512a25d374bb8a8328f1bca9454e379c132f255e5f4eecddb30101ddc3d0d6d83a10be944a6967a4abf8b3c8716be62c380c4335e91978223ae02d919a2ec87839d21aa1dcd2270535058436017f1b099d7c2b7d0f42acf1759034046ae04f64b25a00a17c1970512b8f3a8bbec345e1f96fb6dcfa9c28d21280094b6b91e90f4ac6c3708c1fc66cbfbe71ea23a8d0a4c9dd92f3deb1d655a3529f21f00093798b9f4ee98d7d82e50639982b3be457cb7d06bcdf7198924d26870881f02ba137309b298adcfaed3766f0d12b75e78be37904fa689c641d9db5055c3ba9ede13c4b58eaac947ae69fc11433495af38c760aaede035b54e23004adf10ef7e9472b9f5b0fe0a434b4136488aa67afad38be48186ea1eee051e8f30350fb945dcf567ecae81575bff2be76e20257afc8044c431241c336479a1c4b351464a01e2a2c6e634deb1fa884c1986e187ff700b6e775d81256524dfcba80771dde8f28a51a9487cdee30b3eba7ca1a72d45cd941b82f6a077bef74b860505bed8e0ce94b052cda301d46d2c745a1d46c44fd580b5ca08d5b3bf4671ab163de3734fa83bbaffbe45ac029a0244245335e33f01fc01c2431eaf826203259e9ae4401e8ec216fbd3dcd777746f2e336a6522a0a186e5c5bfc40d2af703083b3140da4342f4897e9ba90d94e13c074a7378c205827a287f5bfe26c91b7b98407c437c28403950b11948d4f874cf4e8fe2994f7ac5e6527257484d48a7a820d577517dd54b3172826c9b6ee88fa061155dbf6b3caaddcc3f242cf03c6947cdda8a6dd92dfc8a1bdc702ec10d2268316431da4dc4d0abeedac314260e43c9f1fc3713bd628f4be520b0d5275a4fa72d8c533e500128e67c71c11e6ea11af2d68a52998d49aa1f00f39b502a454c03ca6b38d11ab3f5437b22e74df9377eae28f7cfc36d3b08a8d245b6553b90ff97c71dc184d2811cf8df1380566014767d782e36fad92ade638229661658b3689f376bc6c1e94b23cb461bc2f6e5c92cc86f442472dfacafdc7d301a2976474fb8bae27873d25b6f14e78823c53e83215c29078922399ea3d942b0d6759313b370da45f119803bf3ba7ee38720e24d6d98813d809cc866b226e30b0913674747a9339dba36c177cf094b7ba7be0654a49cc75ccaad1bad088ab10001d39bed0c8fe8ee837dc006e679acf40b36f5b705e782ccf90fde2a87393e044df73010362074640d8a94ecf7114b373eb1e3e5fd37ab3532f9aad5b2af75ddc3474fa620de9ee4cf7a919677efcacb88352fc8da28bd2ba9bb01a50089f2cecf9b598007369a087a2ce36006ea635ec43627b4b72f9af26496ec1478db68112b49b415aaa5b6b948f9bd894678351f6e2837d5a2d547fc7541a0516f855938203b692487b1ca8e53bc50208009a09aa5d1a57940ed7957129b9a966000f97a1d232a6305fd88b1a15bce8acf8b984584aae78db6cb7bb23bc1ac304d7873ffd78396abf0fce0f0894cf21d0b8bd49b84f5e520fdfacace2ea8c2e42f2f83faf7575049178e97f21c3970712b644038acd830368f6910a9489f00918f45e9b49b45c5f85bdb64a56e1f47f86111495e1f20bdb0dc1b3e4e2a1609ef9435de86dec6130a6e074899ef57f5fce8d64ff4cce3692e57b58285f88c255684aec2677a166726de78b985f1ef3d578c03f69086509f1652ecba12b65cd735e89c1f04e508528b75fe52e87e2bd46fbfb29a2247a07811802ea7c2a2c0d29b9b08a709422a20fdc88b5e56ad0255db55d23ec7b082c2ec8420cfd89dfd7bf9161376e23b4cb0d72131e913154d1f8625a3bcdbffe9cb7ec4d73cba772140503b5304e7b663b4903b6abe19e72eecbc03590049efe77fe1e09e1db5b1bfa3c8ecb1599fe1233e6ab349c48d142733f6bf2f31a695d5d1f8339f1e2870cb463038f049405e31c8db6202cdc870875c81dd6de4c3a950e64a07dbad823d2bac48a9a96ce46dec58aa4e34a08326ccc00f85b2d2fb35615c6b1cbf025efb147e7daea8c9b7bb70df50f3a44ac6b6f7aacc026a8a15abb432236da12270aa37400ec045b523320fbc8f449a5de0ba6f10110e6872abd68aa173ed96c5ca0fb39d91c3eae347437dcd359475bed92f325b4578316c4c836779cdb1dbafa60f47f0237c20341ca3742033138af54b4ff6e32ff4defa0e6802dad153360e3dd2f7711271a41700b609cb1c4c1b8ff026bf8e49b8f226fc89ad767d8b60afb9c5bd9a54a9ac777199beb67b31076daba1eb5aaffd5d94324d8c105417b93356292e39fc7b73bb03fd2f2fee7790db86a6013ec4f383dd8d84d7165802fc550381495b303703c9005539cdacc89503596a3a4c9d33c419424f276ff2bcf9878a6da8d320b4d84210590b0b0f71833227f6fab7d0816f6da7695afabd0786fd22dc5c707a1aa6bfcbec7a0a56e6d918da31f9358b9b905eb0244325fc8e13f03f8f853895ea12afbeca9153faa8cc2d23c130caceb2813172ab9f57f0063dd1c455d1ef0cf549ef5f3044f81fe3627d9d211ae5a9a448ef71a9233cd6fecae72fc57d51fbfbb530cc189ce454a50e587b238adafaa6cc2c3e23b44dfcc8d51ff306a6b44a3b8d4b8b3f35a67d728e9d41eaf05faba2dc90ac97588755cdba73f34cb08fc9f21d7b39391f6ac279440255576d5eabc8352f7d7ca04798d76b34d4862c62394f91645a3c66d6c9ac3ee1eb4ffc516f2f062d34c3609549ab12e2efed404bd280011c62ba7f70e1a4892ae50f2cbb05334737078d58c151a9865e920f377175e785a24f7f1d494ba43c7ab8cd738a00fba5d2eb468f4b5e86aca0867b5053101c4a2f5e21ef184ebc62ac7f85cc4fe6687caad59335850298013c443e00dde1ce6f0263e36855739c58fe8dcfc0f1fcbb47b5ea40c5a21a036c66606d86682699ace24961ad81d8f5fc62480ebe46413c1c09a0657b53a3e03b310b0420475a47f5fdb955461b53306d1a356745d2be490b10fd1e2b7eaaed6d84770cab892ad2b8efdf0efefcf5c5a27dc17ea2758d906a6715628dd5ef2e323779b69d554079d3085c824129b5783aaa0c201df7027d98bf58ec85c0905be83e76f47fdb8e3cd14575f5e79fc52923c4d02d148842e93fa6a6225a01d88401e86d6b476c93648c4435d4885d5c4025a8a35ebe8413722de7e2054d6ddce8ddf3c1f48d5b8d60c0704ddc15fd9954b376e7f1dfa1bfc01984238ae8b2c4204de2bcac3d8c99109a821b4a6c2e50291adedc49b3acb5728c9366dfc5b8dd4623a47b01371cb69011f0abbd5fd143d6ebc3eaf8fd508168b7f08685f05f3b4ea42b6ccfe2068049ebb80a13548669d622410a8eef283462cdb11c68afc6bf173df5d75aa466648a44e748dad01ecc07c76163d6a412a3fd12082711c2168f30568596c632aece58456805c8c9e9695c17e282630e908883e2c126ece4515f5d58af87c16dce2129c59f44ce585f989d4f8bc0c42bf42b8fde50c9fb9f969f873e3576418083262bce1ca6f43695452f6ba987e79805201fe6191334af86ca6bb08dabb99ec6b451aec5a63e5a4566fc061b32d450f5bdbdaa3f7a79d3be0af1ef060f0f8c36ff90a55938192710773fe67558f9cefcd91e48bd624a8c1e76b832f204ba214c04064fa8416ef99e945a6452029f1609f56b7213a680cbaf5dcfa660cffe3fa3482363f9066a0f3a4668cee82e5b256c6d2d9823b281e0a061ef85a722b66017c392b3a37b9fbd457f5b78c0d5aceb5c9c16b8828e5afc4d250cbdc0c39a0d2b4021dfc60b20e2cde6c64a3118d68637e02c8f19afbf9e82639fb68c43b265d3956e1e9b8bea9e07ba13e83306bb305e8e36e4c55165a7c3de34c10d1d18fe06b445d69d9e4c62fa3ddc8bd5a75bc22456090aea9330b2bcbf639c837ff1102de7deec071c2da83906a5a5ada334d52b0bdf8b4fb6faeee5890734477fcfd6a2072fdf7e2c03a453b364011a8e9f5b9f1902956fddd7b39680c28a73972090e4e2955677f4207ffa97abb565fc6cef9bb272c0493929894f4c61570e2081d07b212b92126eecc68d413795007f91052bb34ec4e84a25a6643e209ca76652d764aa32123d9fc3885bd9ebec4282e0458916bc302465475fc3aa674f64c3daec4cbd834ae6b41d2265dd887baa6b60f89ca9615972d3b7c6941327eec77270e3db5d38a1422e586a637ddf1c108d0eefe4eb3b3ecce605ec0f6d52e23138ad573375ad325a2522fa8307a46518dbe3905062cdaf0c623e4c11a9f06b0850e5c0b6e0f1595051d9836b905e514f3639a66cefa0e5d340dee4e35ee1eac2599b49b4934a0f9dbfdfbc7e896a11f85bdf698f8883ffc9545dcdf6abefd95be3b2029810e5219d712c3034cc709c0f5741d10a3cb9ec161a1883e1342ce0577abf68ce4393de0d5740e6ebde4fdd569e3280622415de5f91aa41da0182ac14ac07e96f0f39e83b922565de3a70d39eb117a1939abb9121f2c9c35e89bc80633dfa61498459f70181b8ed58785b6f72f79d61bc6c3109be97788aea101852477f50b62bebf79fe4fa60f30aa1a8336f9f804e524120449504da61258b0ee44aee4ab97cd99d27077a66363edc0ca6e0ba3f8ae1054436b83551a3b51d84958a30411b81319dd23264e78327bd563909501f8d7f096d4ae45c4fc97d6f00d19bb28a86eb1a44e8b6071166d56851841652dde22a74db6311f03177abbf6b71c08432131e3f9561dd9efedc5eb8355ff64e6620f679e8120927c0a8b6b2c8fc7408901190ed8457267015efeb17f6ce648ff90584e4057957e273f28ea1a0e251d2de585fb7d93d0feee6a396dd1e6f3f44d53f96a8bfe60e5a4a88a51320c308227b0ce8544b497a61d40c92fae4abdd5407e1d379aadefe82b979eaef0f80a8e4e627451206338804d96740b5b587b35f478dbb5d0aa790740fb56a564b7e446feac0928844c5e5985efad28185427ab6a4a77eb26e07942f6322ed74a9eedb752dc731d5227f122de0c9c6f368c893917cccf94157ed52d9d0c4b8428039aacb8ecff2f65f4d8c585e6538efb40c9b8b53b19b6cee1bbd8873a41d82b68ac34d8455c4fc13102b3d7f9f4f6e1083d657095da80165c24da0966de00398124d94532ceb334ccbf5ba90e9f42066495d8ca71e1d8901373f6bb0ff5b3d6b571f41ca5f79a6558e178a971d5f4c04b17f6aee25dec62ebcd72c570c826d49fee11561781dda724c63e0ad6c2827e7243e1a8a4df8f1c4d8b1e304167120938ffd78167ac31c6cab908715b9e39e46ffb75c0233273f5c6fac0fa612bc261183724771f57864c7088bfe55a917ef985e7565c3057ad58a1bd4d6f797c11ad467e3f36e36a662e8ba2dbd1fd5d5ae3493ece4f87d8790dc75bf912e85a3759521a3981cf5deba8bd47b973c5817fd4f3346c4760165e6f182611a6d5ef9c2437269926072a8ed28251d4bb0864b75ed40f3224f93a9185619895e40712653a92087753f53944075a5bc4abfebf788a7ad04b9149691526c995755d9044a904128afeea849f739dac69629e4d9148890edd5377f95a695decb1630654ba2891594c744a59c11d90ffbbd92a66dcd3fc2191aee03cbab9711c9d055c11139214306c6f420600d6c965a8fbc917a8582d6267c2088af9a511fd7ebd830813af87e087c62c32f184c33feef0f08d9f39b15d91a5fcfb5005802698f7f04921106125ba27aa152e6777eb78fb0e5ba78c27a8d724969aacfd67c91b6ec787aaa37c6e365e0e4063254989d60525a21e6a8dabcadbc320467caf15a482337b53c10aaf2e090c77a82cc5dd92762646a6bbc19b31bc4340dbfb2d58969b6eea3e56c367767fa8aa0103abac8835d57e835f9d91072341802b0e21276ad6501e855be1e0bb042e6e553ec1d97582b8057a9f3081ba00af3f012c20691a797cae9269939ea861e9eb37b96e120f2e83329694d38fbbb894773364235aec41a9bf6047c080f832bd9c51dfe2a876cbab6fadb5df14a0e950795f381d15156cd137e82cb5f550206ff68492e320657f159de31a24fad9ddddc3125441e006077c98513fb5d907a6ad411b399c956631ed209bf758bb4e4c8c7ca9fe7aa4847007993625afa1275f20cf25b76d593466ea2d62c9f679371dc047cff934926c658ed14fc272dda8e742cf0f0f4ee1490cb366090cc547808c29887d7d85b35383406c9a0cf48e102a2be32701091c34ce0032d1716aee8a7a7ad30f1613e826c262cda06b5920d1d6215d0651e357375f889a2195c39081ac345181c213262789455688eae8c46ed689488101a1d2855f631165cd2aecb10ec5849a527529b4b92aac7ee0fc3fa27691ea39cc6833e712c803cae113fbcdf9c6766b354f95ed527335d35483279cdbd4a7e76a398ec02b9d9174f358195468c8acafe116c453917fcf9376e02a7dbfeb0fa15ee37c60378395dc2effcc4dc34f8328e9ffc0f3374dca99ddc70597de23aed8f565f6cf7dd557aa0111ac19f0c1aebc5bc20716b81752f842d07475839e793b28cd7036a39a97cfd08c66c49f4e61c057fd688cdb23e4356d9149dd85e3779774684e92412f331966b8b8ba8a30edb9533e43fbf31840177bbd520ef175c5d703b1b80479482a302c80484f707e5d3f761a2f2a9e149e22266699e82335a6ed67169ff730c7130f2b1b4a192aca94fd4aea61477d5f72c7416b27c0c1355d76b3ef92edf79623ad2db89203bb810a6ceda3b13620ce90beecf725203c0b2b50ff2cd07f2285b59b8c30ceecedff67e24610515590f6b188b42569174a7f87aafdda815bc0417162d5bd212c6118ba8664eb070bda888754bfedb44ca3e46edd7b954d557bcc2553ee5c7f14d34a90ede5d81fb3bd080872fea66619ad36da834631791068f74fc8498be2fce765ab8d47072867eda7ec23abfd772a73821743cc1df5a2db4547ffcaa8a4b5b5555f70583a30139966f4ba3c1b53115ca619500a8139080789d97553bf8f2ff8f6aefc9edc22ef0b6248995ea81fa75cf7c384a0afc11e8d07c12d40c2b63fd0f6d6507207d37b88223e06cdfb4be39b9f722eb38bb4eba055725bd32da61e30474ee9f9809cb437e0839e9e9ae35d6b7c567a53472f11e85deccd883da5696a5ad3ca3b44341cc0f7fce556b9af9fea208b2351bcf7521e9a2eebe4181176eb3a0dd6949937813e0785d6f9f8074ce485f7e01b779ff794fb9e8865de8ea5bfabcf2513d9aaabdf677bad6344ef018ffabb109e0f18b73065593fd9e8f2f2eef7932c3b32a7a18e8869a5f894f4a0463170b3d5f57e9af4eacbf3126e6fcea367ae07c7969c1f4d0497e3a09f55f97aa416f399390f666990b14f5df2d07b812c5f5df26d35cbb93b14f17a4169dd7a4ccc4cb8c085911a66c54eaedcba5e21ee243275d1a521227e51e8fb6d54979e7f8797b77fcd360b1743c9a209c2ba54a08369151d5769d293d534cc6cb6f5c3836ba8cdade210f29d96e636e78c0356ce5491de2b5865f3dc8a7810b3572c1cdc476f657a16fea9048eb0ec81ad87c7619c22075b16b238936d4949318f139e70c378838850fbead6b4e32d14095e537bcbfff1c8575c12e5cee7e3cd126474a8d09c3a5328d6ab01cee785456cbe7e787ca7e9259381a27a37b75da604a8e088c604f42a83a9bdbfde82ab699a564a5091cd103cadd07416fb29f2c3577fd09d69b5ca151e27ff1ac910c2966317c3d39bd68c2db79b81cf711e9a5ebd13c69d89d72a0c28e8f180b7a6eef35a9c5e03d90387df787ac04063d40438ec8531a9b3e53c02ec5d9581b030ef235f36172fbcc81e76e5695ea685df2bba29b0af9dbeb3714a80557867b0c4f8d1dc9b0909e142e2c53cd88f11c34f07557fe6c70359cf6b9fd4d97d07eeba41e2ab3e3e8a73393a1f41b7061f0443ba4920b391a1a366500250179ecb8536ef3fc681c84062a5cc26edd9051b913d4308472c9114c659168f854bb686065770d7daee9b166dc0b1a64120827a9187476f52ccc514169b754ef588e3ea3dd62c55e6fdc4404f580f9d3c3f8134dba365bc2db86f7e11f96b26b67f2837f05c4e25cde6c120e1bc8444467346c559d29e3ea1ca68ba1f1dca1cc183e16fdd1609cd31fafa8c0c0d64082cb42161d18ace50d8c94084a2c36231809c7326013e51ea210d4d593a28d462e65b646b9d69feb04cad236d147ab70cc872b7941f7610007a7e2b9a0d2a0092201a6161073bb75399344c668d02c947b77085fefac084456d7f96fef9473d6ad4fbf833358b43915f3fe66243320f826bee76f34724e42b1c9cefa542e55e5df61cb4546b3024817712e34ecd2c99f95a8f8dd5d172104a98aca7f4888c251b0b70f2412775f03841fa169c81fa2d5426cf28558577fe5604de73396fa95bb592ff94ac3de47f307892910d121429e0850f88ee71bca1c81f13cf13e8af4730ddb7e45aaaf9419675d3633f136cc6a1b00b92648b54efa9ecda26d9f3e66d8ce5667bada0c16249016c87dcd70399663f593df37b8616a0a927f80edca2e9b2c17d93b4fcebd9c7fcf38f7f656f0ecfe89a49593dcafc478ec2d10cc98a48f54e772c546962f38913aae094e15c09c8916e652246a2dfc55fc5181428c3c78eefb4afe4f484c462e1c1f662fb3bba0f7a31bc0762b25dc7f088441c61606221f544ea86a971a6936244fccf110fd58ca0cfc12f8581bb5bd08cb6184fbc5b02288e61bdace58ead0269ecf8d16d08f24d568bdd61dc772c47382d1a34dd0fc148acfd144fbc63b6e7344c05e0f6e62177d072199bcf0d038a51789b1cc17d91a9ceb1e52bce321bb31ab2a5c52be5c4a64707ecb7f8be749dc084c1e4b4524e332a985d091eae2af9a04ae10664dda7a70a1ee4b749a1b452d8f230d6c909ced0176b1f9317f3acaad30408beb3944001009446b9e93a87a97dc8a86b22233bfb1e6cc4dbb128cf16be45d4fbe9293db65531bfed50b26ae754d4c0fe62c21c6fbad9b4b024b1090e8e46e062d88e517be355e24c30d80e16570c34d28815491aecdff91c0ada7d2d2658380d068506dd1a6aba4bb0c70f2627f7b35f0e7111ab3ab0dfd8ba8fb9b23c0710c8222a28acb132233c358929e953b3bde3f631ce76d7ff9d9b827ad46e389a108c1e46b222b3f70bbb74a36ecbbcb275a1bc7034789fa8caa0a38713cc1a634ad102d2faa52b319d87ef9680f2e51528165f469d2b1b061c69d7dca9cd7951072c786426a07217cf79581e5f9c25f2e151d03f9f75c6ac231ea2626d967a5c173b22328b358410b658c4339868909d26b5e6a19b11ea0e5dc9196308455355826374effe051b006befe6ee3b225ff6ea3784181850ee3c6fe29dede670b3c6cefcb76b7f34ab444fbb98acbd46a22f17c3a6f1bbd9cbbd12085c8aaeaaa0df064a5d9ac00a8e8dd81d76d94a2f95ae2e29ea1ea0767da91da84e8e6160c342168d20c0140b752fecdc47ba0ea6e04a1ed681a77391b50ffa80475578468393d8a6a470f5ff132c2feb2f1157824040c7dd393bd91102b12fe374a51a6ac59bd6961818bdd9e7586380db94a8a84c3732aa1db6b430ccae44005433c7aa73cd35a24aab2e504a8bae397020d6f696caa0d1340b3c11ebf687eaedc9d06a816110b1bb23258005411513cc94be2a5278284e4d0a061dffd7999cad2fdb94ab19d6406af818457cf2e531d9bf2ae04a1899f621455ac337f228b6e2c49919008d36093db148ddf0338e4fb1fa9e0f2b286ea04ebefb57d4723957878bdc68ee80e32d98ea9ed9f418c5d4005d777a21cb6fb5e4160bbc0e77a20dcce3a5ac8218beb5f37bff47883d431b2ba1501402b6694331fab7d32012ba1957da360c8e23ff599f3ef417efbe63f10c76642bc9785fdc5501737beb3e94dae1667391dec1bcee7e03c1f0ed7b3df7cbfef30b05569b00ffde899248ff53855f3f0f6c8f92f1af1b00db80e2674a07e10a57f6f59a549504bc3dd7106a4690f9046eb8580c141687a137bad3bb48c9e1faac3d06beb6c12ebb76e234e8e65230b8f01ce2d6da8ffe33103d45875395a0d076a0e57b479d66e1cde9e142d0bec938a358a43106ac2ec1d375290d5cd0e267e1359646f248588c7a1fd662abddcd088eefb5bc07ff022b3f4c40a0f50a50e177f06a87c38541ae6f1c15651e23272c227e1bec0c26a73fc6c19ccadb77d32a948659de957fd7f334387efd521181155637f39430b6d8269e48ad8268817dbf64c4620718174658e655acc5ffc0f76f8a6d99d4f85713e0a8553305b54b1dd2473f56d50eb654779dd39ea527fe94efac9b7320a2971a45e9dd7a0e7de929dec469f9b40563873b700cdaa21088147d6840577b2773064f58deadadcbf5cd2bb2875a8416822bba37ba1442abecd610b416b736f525d8c13a7bb6eec765e84dc65a8fb369212832824b2841ea929eed038a9fedec3514cdf9618fbe9c4ece6bdd7a41668be6b1f6fe237e1c971d96d9e197b84c39d6e808fd8e07086966fe9e4de47f386e0b39040f215783b10189eeba59a8230470c879873f0a5ee2acb33411a80a79acf0c96e8060e82de578cd7b1a4e147fa35192cf600d7315cf0ec33ed2139ee49b26de7231e14dc0efdc266d533d0890be5ba447f2e8620969ff7fb6c2537cbf723edcc929f5682f751f09302052f75f64b94b09ce38ed0ad0ae528027cff088b53efaebae5e7f675a78355a63af44a0ce4478d49d3aa5a00e674da369a5b6a1c2c50cfe2741c366f657b45e6134321d3c3a1d7c3706c9ec12c7ea420c8d1309a93d813f17f8ca918b784c14efbb3ae87c25478f5e0e8aec4c8b43f7cd2cb17639e39642c591948cd5ab46911f06ad7c9dab20bbc45da1f30d59cb6cb77ad7c423afda6c29de9fd63f42c2c226c15e93bcc785ae3223235e24c27d013a6ff197425d78fecc5643e285c85dc11c917517f46a6a5718f2ad6ad11ea2cfc8b92e0ce1ece667e983985456e4748e2bc6c7c9b452b6b83ac8e63c1edff0df631ce143c6c3fa20111d1e9db35143eccb402044988443cd9d7b94e4d46cd2efdfe3d80ce0e78bced583c8179b138c7e71ad87c99db2bd816408e8b93a562a8b5f12acafe73f908b663a07d30e52d44d0c451fc076bbcb8fa75698b059c08b63db6e19d7a484e33b98d1b81d90a301537bba561b5222afc749792f317404aa6dd16ee6b66874f946f939c801760a510afb4baf357c7f6b1da8a4c19f8abbaa05fbb1743878dd2b10d9661fd80b418f2979751b15c8e9fee6f6cc25a56e1157194e409b5c753c2008145627f1577dc66570c4ff4f3ca5cfda0e374ed7fca6deb3df1fe74daefb41c76c91f2b122fbc079346a1c9b6a8da5283f01e78b43e4b4fec37623e229a88d419e23d03c8724d2a3fc1080382149a90a226604a2ae1138a9684c3b19a748fbb3ce160b5a154afef159314058bc7cd774b952af8897e4157ce4b029edf026ffa0b81c5846d7d4cc31219112a4f09158e97ef3159b30e0974bb4657bb844924940d4ef23a9a2333cfdf7e2b38156b8517e227365371ddd01c39f4192449c4f536edc7d17281eedf4a31e6efc17fa3d6528f74c5dc2c93f4231f291c9d9e6ff53829fc33ad90332124439bd6879a899739f6a592c1dc21d43a5a52291ae574658175821aeeacd0a48a6c0a828fcb005b3c9c677356e214f711a62b3882059e8f8cbcc8a2bc2ba7d9ffa594f3ed9d7706ab37fadf3a40b91ce1f9ff9aa6e4fc99b3d4cee2019da6d269548050fd363f6bd9d6424d58f5fd2f38b32da4f75c5afed3e86c77db50f85186a75bc00807e9f103a5b5114d82fa331cfe7bc0a181c0225a6528cf57ce76165693381fa13c7bce18e0117a4533e3bb35e3f423120a529e9c4265c13b175c5158d65912ee333c63054cd926b4f7be92ae3d77d0f312c4c5512b869a1878fec9f966cb46321bdae9f4982987a82720dcfef1d7c09da9537f8bf509fcbb1d99c87a809df7b39ab46e17023410dcf5d7d05478be42b7e286749e517efcb53e583082d0cffd51c0fca02aff4b58c6fa838b72a86685ecd3c5a598e4dedf30818aa2826ac10899f2ba5ce622fd333534a419813adbc43ccdf53e38fd7c444a4329d73db179d82ca3d852f30cf39efccabe221cb8d8793d975962e8c9b54558aa61dfc4dc879e4c01acfa74a9420fb0250a2fdfa30dc2837435ee769b851d26efc0b49128bb45e3c6aa1fd1c9088735ffaba7e6d875b82863951acf5dcbbb80247cc24dc6786391c626bfd46b74e311d25e96cb4df2062ee0a2ca33913","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
