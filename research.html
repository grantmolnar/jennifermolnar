<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"faf44b443c1589817e0d41664108c8ef68eadb20445e4881527dbab80b46987cf15223a9343a70dff59329650fb2ada141233cc7f23279c710a2f96ba56df9c4becc6507ac89ee0d7fa5b6eac87eb671bf9c20c70cd98e059a085042c0beafb7b7aee2a63f058802789b3365163d50c629a2d05bad9aef27c5e37a6dc7d6cf62687e045d1180d9d8ba1488f4170a8543af17d240a013442f5c3763872902572d3b051a7457bfb5216f5e61bd697e2363a9e51feabd63883839357443fbf478f992aafb323ae93dfb7d3e0464c44a786e6031937169f6f3d2297135cfe2a2b744686ad23816316b3fe2906f8b6ddcb3e557e0120a3652d38b662a93c0c9cc2761f568177ac5780298597c052c0e5bd0a022b33ffb32d20656e9e8ee5fd944b1ff8d032f19fb24933ad59e367721158ba82af145de9f796a14ddf69e7e98fb00bc9286b2d26581fbdc212a7a796a86a4b9e19181422e7b753baa69a467f08fcf329f3d7bd3332237925db96ac6d4197a5cdc002b09bbd279394da5237c087e176f6d224e47ddd2864dc9ca6fb8928f2ba459f8b5052793dbd92dd30bb5915709bb2009cee6ac5b87db76b59d68ca3a29ae3f0a113ffb6e6de7595c829d0f603a32ec6682fe84a13f647c81de8dda5cedbd0cccdd3887ffec107caa5978a3cc2c300f23d20164f1468de60b90d0d7ebd84b8c3440847c800fcd34827418f1387833dd4e00e20bfcb5871835121552c1366863a97dcf402b3f3800a4d24827fd60130787b4fa1c316444a0a591fcbcfc9130633670d5a79b773b1920d30f27a0802d1edc13c13692bb4f2c738a38234ed1104e389e125fd1faf6df686c3cdab9bf32cf8c9f9e78aaa933ffef723d1b4d5f99a609f4271b33e62c2acfd7c03d7c57ed55b56bd0f30f9e7eaef7316663494381cacd02ddd74bef811da45f87666731470b09f6174b5a5afbf7e24f5a49e1201f1841ae6a35168f9fc991dd17b4b01f7b6acacd33d19e72d11bd2a96c5745fbae49832089c8f18bd70617116501dfee48febb7dbb8ce2e6e913b47864528bcb0a8b6924cac5b7e7d3d45bc27c280e66d1b87e09c876e4a2dcff29127ae106dd325df52ab54740a8654e4b14c1b39981f5c5a05ccfb90b7a02ce8921d2ea8396ede11c2e53c8b1d49c39b2abc25103b196ab0e9b09e9b656f6f5d5482dee6f4449eeb4b8c7c7f5a10cfd5677b5eaaf8ffb47a09256e5454c754b53443b3eb08e88f67bbba49bd04fbb51737e29569d7b513c55e83f08cfc02a24e7bfdfc55e070a72e48231ce12ff379aa16d7e0fd5f2c6cefe4fdb0969f6d2d6835ff10b4d07f4ed15ed627650efe01ae81ffa566bbcc686c0ece85c475542b7536c3f1de8fd0620f34bceb7185654ab0105e462b413c3a15686005b20f3a9b1e524a74cbea7381b35f975bd104bdcb435d8dfd33b319a0bcce4b755a654dcc142d963212d15dc0a562e4893a3439937be5098a384daf7c981f61ad138b3111387e6f0ea2e19806b9dc41026cdd6f8624777333875c2e34b8b2ebb8093633ef08211a8bf8465896d96c980163fbd31daec6da6251ecd5ef2b36bde18684a652135d754f1c7bf27f901edddc38b2a8cb7ab380b1326da557194c5a19a4197d3f0d84be5901235ce2d9afdab3718e3c9f9a5fba50eb293789f5cc4d20999edff582b1b9b3c12590851e288fb19c269fe0ca30404da4caa75791b73208d88f4628d01e75ba9f583c2faca533683b4f1bc4f563f243d4619dbc19967e592cd8504cf95b727743c062c044ef9e457155219eb6ca58d5bbfe0261e60c381696b1432a702dc46e9661cc3605f7fcb3540ebbda5d7cae8e0d0c5258910fee42b1bb6c28de2e1fd208836fce75c7a1535f36466a12ad78da02974e3cdff782eed309db5e9301ef79995fea75bd5eed356fe1cb08fa8a8f0039ba73ffc25da9951a965f2097792d02abf05b35e16c7ddaf6c940765a38b6b57cc45681794e4c6a0066a036ddd91382a03e64c9fc34304e02421bfefaa8b6ead7e88627245d19e4e5ca5da212bc54323d7fc82e709f6582619adb61ce5c4987de9b3ea8bfd842a924a13c3bde829b0257dda4d158218ea60f9f669a35dab4997af65b0991f3ec2ecc177e8966fcf9439328406d7ffc4d92202a68b4c1804e8c2675f2b24306f5cb9e2e60a6fcc11ac09852d25380afc6802487a838ebc7c6247799a38eb55021b2fb3a37ff8169b00ea991f546473155439c0cbb87749aaea30f33e1d9cdb1a05f55335c2308ac4367579f71bd429b91dcbc42fe2fa9270b9598ca9130642bf0313f3bd6a07d2ad7c33cad85b01100e2045adb0fda806ef422d9cd4db402b487c9bc028c1067da49fb130b1d8863c993887b76bc3109dd83f8cbb45d548c290d5495e938da5117a4bb0072bf5fe57bb34485a72dd42f7db032ccc0a0d8c7fd86d787841a2e9fc819ab547118a793b6acff1be0500da7523ee0c88c30a5faaaedc9a4916f7662c347f9d1e1a8ceebcd409df2afc93807371a26fce71a6815097edbb6d9677517b20a323b4cbb7cedd55bcf29983029b05de0a4654bde34cb49dbede7e435dea0a80deb7a431ad103179237241e57387f454de7cc9ed0a208511008461330687c1eaa5311d1ad34a523b4c09a90dba2e9c103a8da9fc9742ac0ba291536ff3f30c1ab8616d727fe2b34dcefed0b83583257ab8585827ac42bbd3efab19901271964c3ce08ad041546ba0246a443f0ec3d65c1630bb7fbf387e8c962e60a48f5d9366fdfb10de46c7623ffb7918c8adfc08b7c084b55057269f5504e67efd0d3086c7d66cf66401b11654f364494fdfbf3b1e89677c32241e4e335e8c7cd0047b403978f6bc3cf5a15bed1ebd7a8a996bc1221cc4a8e91c4b3828f8a420f2dda7456c1af17d650415e9c90c792acd71335b8596509a16f4e920f5b874c55045066ad321dcdfa85eb16a1825b52197e533d3b92b9d6610bdbb3a99db92107d779bdbf0276cff327a985971aae6f32f58944f230117146ab6e70ee5b8571a30b8cdf83182ac6c2c13472cd6c66da1fde2d1fea4bc9afb3a3aea0b69707ea3eea7077747e3863c376345ccbfafcbd0be4bc36b989bd68e2505c6c4ea0736192b3b6604ccc6533ac10503ec3b23649c3eb8a7836b2f0a15910fc92f1911878e6cc97f6de72b064d916b55be23ace01fd78ad45cfe3a7ce76f500034b74a644c3500e795b2c7361a3168b619dc31a24091c7955845611cb0477bec204592eeb8538874dc55a3d0c56c3413d446ef2c06592c91f232faaa46f77fb515ad05638a276c3207058dbd3eb6da7d7775dc8d82951f268ba43b5b5e92fcf392f5825484854b1cd6ad1c6a09c5ca00c6460da93df98a8979e1f4db06ec2e00a7201ed7ceaf3730b037ee26913e4351f14caa486f90210265b9e0b19eec7821dd247fd796ff197a2e33aef4ae6990df5fe99988cfc13f808766b2866e696eaf6c5adbe6d5037817c494685d03b6e1a8eadc5a4b01302e55ea39eeda5319947a53cc019b25ac2a625b0ced0f49a1ceae775489d782426a957d83bf3ed4474cdb7507b8298cd6ec0155c2ac1f67e2266af91b263dd3e86cae445d0c9655fade04bd2de0c4ec96fbf02d3f0f58d324d952b184a663dfabbbfa343ea6117688afd976312cfa3a85b2666c50badb533526d144d7733fb9d2be52095dc1ad089035fbce86413c1775b30b8ac95eb905a8ed6804c83fb33cde18dea84492544ad2c97212c312daf144e5317777edcb1b0a8cfebeb8c5c4ab469741b339766eec6d1c8fe874c0e4944a7aaa29d99d4330e9b286a9b4c108ca33719799297984f26243cf9fbdad476b3965003e49c0d7609f5fceda2a5fb19b55859960f85f60caaffd60a4ddab237cb015597ef7c0f55d719ccafb11226fd369fec86c67b6e6abe87be6c3061e824d9d5b764229265e9998acaf5a8dd8be684c0069e433b8ea266369eadfc8808bfb6c7d0ffa0f9bbce0cf6bd5cc6d2c155e4517c4061e633dd4a9bf24b0c57b8b15e12b4bc6ce1ae9dbbbdcb2d52c041a568075de4b6c2f822a769e8be7fb1e69f727815f2971ce6bdc473d1a031ed0f9975920850ca136f9a56debb0a7ac29d4fa7e56933e43543b01fbf2b49d78afbbc0e6a9a97d005223d7fdb2c31aeb93bb9128669186e11a8e15859b63c1f8f20a6250ba7b7fee8ff112a84a466f8ce4ae0a808cd3555f3a70fe6730368902bbf81384ab6c2515027093be1a289503947e4555705edac12dd030b11fbcf59987df6d6052935e0693e877895871b61d3f3e92e3743faf54026ab5dd0f740903c7211e38704fc04b4089e52dbb42c4a5324d2fe109534ac3511cddc1f11ac66f2cf7f73c5602047f108ecda75486a4c8950c92b1ad677a0a4ff89c77bc5210a37d495a04e62adfafc60c202fe475ee85757026c6ea863a21ba66416b7436e987db8d9b277bebea274affac2faadc7b7238f94173af68981aaa34d8b70672bea93047832cdc15f512e1d8bd17594b7cdffb1b3c1ceb5bf96476d9faba678bf5ec4c3c50f5e6cf1838d98ea9a958d3449f00a6b2cb8b4f0ef622afaaaed25cd5aa37e89f56fa152dd156d67715768afe2262616f7920549ea98bc428494dab66fcdbc55232267ef74835a5b5161fd948632d9f4c4e632e80466e2ae487b57bbbba6c5c1c1021b025c354c122b9f667ba7794bce86b9fa85873edb655a667a71673111e78863512a92bf937096f6451087ff7ff0df132aae256bd2de2c9ca5c5052592036a3332034d79b18f12c3021b233dac58f4c435b4e71baae9f5023db7cf1f0bf31b8fd151965cf07922ae9373ca997f1a6f96f7a20de8476debf620ab0e708e4a485b1dfe6edb210fc754809c9f8208092d0e87e2f6030a343cbae676c9933a54fb700fef07f01b879cd96c8d000dd6f408703b076d74f51679cade58234db7e67605caf23a0988048fe1be437e8f8f8f30570d8a4cf0516d468efb8b0f804ce651c22d8d14c6290d4a8f20bb81824c029844fe4e74aef16195b4aabe2fecf483ba831430fbb763ffe96d0b8e5e910fbdf6a0398c9a71844b7f075ff3b4353aee0a6ba4f0e62adc345184f218761b3f655033ed109fea49936da9090b98439d3bc3d1fc91ec3d2fd3fcafce03750db7e29b614a5645d51f1305059aa64838e804514a33ee9c58ff705a1e5672efc9c6f9a22f9dd4880c052166d7fd0036904fe2cc47c703de08a513b7e6b61d21cf8f7acb102dea8f9b96d02cd4bdb52badf09b27e0d9b8386d239144dbb529f300d3b9f868e232bb7a5a21f4f5c6bbe807bb995a87db716e6e86d5996236ea2864b8defa58afea1ba5e5777354d12b6e061ad0da9e6725d214812caf62d2c94c6bfaed31602a881294886249c0bd66faea80d6250fa092bba993a696a93a32c9c9a2c657c9392b8c06447677eb688858884d07960bed6732fbca91ce059edda94af25f9a1e580378743c9acc5af64c87d22e5cc309b4042f567b6d11c75efb04b92a073897ab745e72d5f4c33b3bb655970750b0e3d03af495cee1936f7dfcea29f813127c65b17796867325c5072de4d0c936f82a834bf9a3a360de229aeec195cec4b6dffc15d10b8071d1e86189b771447efc34ad13aae4b8b6ba5e6cc4e47ad7ae92c1278de24565a8a61cd68f34ec5f79a3db753362ac58b5e6800f4d18772511c9384b4fa084f9bd738cd7c15f3c890f183b16d6aa28148d0a2e4b9fb7b9ab66c569ed3fef53e3191299a87bff07d8d944bd58b112f7f83fc94d6531f0aff2f6e31f9f50c96f24a972e61b1141d4b4854d4c69cc4a3e898d22ddb0516fa4506166576a23566a02e103e2dcada1c1803bc6b73a81bf8cf98f2f6bb3d2b49a57183c39ac9d0c14a0fed87473339049778e492bbc1860fcbccbf19c081eddeb27195be938ec4b5800e54d5c09b79bf0ddc609af0d2a82f9a822b7eb0a6dd3bf7f4159d843353ab4c309717cede6d710131839ac6aec9f902460970e7080d9000148a76feedb1baaa444a15cb6125214ddb25bcb200638c47f26fa8e37e072f7cff382ce2374157c2bc33b8ea95c920be2534c894db10d22e3d90a3e542e223ff9a3330b7682207f33eee5fcac12038b72fffbcb7998d4bed9697aa959011d9eb187a4c91056ec1ca10d3f2dd8f6830484eaeb7ec5840895356bac3d8e733bec90fb2262fc6fd5e933a97393f6c931a5e0ac84972aa822bb0dad47408e2f3560b181236cca51395fc764069414e4e4c4d7a4799994417ee089f25315269277fc162ef0255c6c4e02f76321a660d5505e5e1e0ea150435ab90495fb3a5206c24e0b9227a0d5e359c1b6963436694fee65398ae77dc48716f377b5128b17bde39f1876cc1a7b16a7983c1fec944e07f7ba280b2112a8be26a7c22bfc521a7a0de2e9d8c7d2cd5c2e39ada02ea262e1f831c2d04a2dca3adfe4d4c5da58d6fe4569e2b1e83fd004383c1680e5b22fd2b0984950d7eba927312089231abf3f2cfc7e09564fca1a89602591a879660d19056758abe2b23af56c333c2ae846d14782a95e7c0c489a1957644e5311a992e56a6954d9b1bf728bb8b14a351654eb765736a1e6eeca49e38587486f24da0c0247e77d1fe05f75b64e9a06dcfdcd34b52a25cb17346049b602585014bcb8994d2fdbd133bd90e37078893b71f88791a662aa629d9ce2e81761390778cf2b381cb9791d553eff527bf5ebd3f6ec3491163c30e402145f98f7d27806d676bea9f3ee44a7b5a3de10fb69ef4c340d12bff098b1bda7204280cd51a9235a5dfab56699aff26bc254af895b1e547bf1155ebf375fb90c10ed1873bf72d2e6d472fe7aa62e4992e888143a0b99e22519888d38a37a5a6d04dffa29450347df797685d24e763389d60c7c756ef87c95807bb67d3f8a0ac108129c720cba6728e11e3f62a3f275823ed1c3ac7a62be624de1e2a0104aa09c13fca2b89d01c70a73d901f22c1e11fc6fb01fb4ca139ec9222ca3a283690d17d84624f5679e8e33b833e72282efc0564557b5ac95c3be01d781694269240ff840502c3a6266f52f860cd71d1e708b5eaf888e8ddadbf857d34ce4d37c73f7a8cf62d078cf0da498ff4eb7f3bbf8b8cc187668e2ef9f5a25b480e8efbb777db904e2c3f175c803ee44c679574b7394d526a9b41cbaf667a8581cd6d419c07348bdf2f3fc6e74eb88d915237ddc16d224b581d1420c1ef993a87b0a29c128530b703f330a476412a45cc853ca0fb8dd1bbe2f0302bb82bac9697dfc2317dff417fec47c11b2cd54031400424c1537e130b16894ff091ce105935aa604ffc7b20ecdaf0316271c918a2a501893d88d4dc2da4dd6f881705090c8fdb98d7f8eae226412abb795bfda151bc8646226a96465b6bf555d7ff927629e3609fe192ed95948e860bb5c1fd38948b1c745bc9db3430a3347c9cbe01540e1f93edc112489f45a9ee5e93012f58ea633185771fdb4cf1d7723b1472b397e0be355fd2d594ea6ea78defaf276b920d1cb3e60bf175fc9507aa4ad768d86cbeb28fafdaec1333c3992cc4c5a4a0f5701f27aef6cce4835249e228ec88b079567117d741fa4d37569c29e130100b81dcaf65f0ed7bdbeeb91c698a783c3f95b368a7e6a24f19f15bec295bc936656543f0b002629e64a0b8e60a77522a6f6c4de2cf5e0fb7ee0785dab1184f95e751c9e5a179f60354f7081da34cb09dcdbb1f04d224aff5a54a3b4804297d5f2a961319440f4f6802b9462a59db1ac0b41006d68baa9d1da4bb2b7406e623f3b3166412858ff63273e937208ddb0bcd98282dc4397f30fd11af7621f2c20aa582e7b01a7377b2332cd0e13871bdafeff3c3b67d1c7f461947a887510bfbd01cd03e008395fc9ee7eba41f7176df75269b68a85f7f0e30f3b11263c0e975a5f325df5e0e8ef53f09ce8969fba0682ff2a33a1257c4e58f550e8762c9e96fdd1571b0245467c61881be283d68c2fb149813b3034ceb7d20b3821a6faecd62e1606c4eb68c61c30af451196d68e45e261bfcd5fc562f363821316eb66444fe42e0fe17d0d1116b270b9ca7fca4453ac9f5d778bfac33af5d572d75710acb985ceb983de3eb1b32548a3bbda056968ead444e6d0b2678e54fe2d40b4a70a9ca7bc1011ad8368c8e8909a1b924aac74c40891288b80fed3797f44f50528103585b723c16a546e40ce9c6c4e488755645d5583a0f0ee9927d5060e32ecef1d756d12e40b93ba71258f6c58f8663fef0c839e02fe2a352504d07409a1d86e72740ff4538180b2f250d2f456cc843fbb62c2e3958d268c53a1cef52e4b2b79436ed0015d74a63587ad09d7aaf07ba359064208b5ea27ebf9be5d1b7be90e4e371510671e17aeed1dbafbaa70b38150601053fb7c1fc6d37c9c5a3038c81ce01fa4c623ed51cf86cb72f5ce677d0cdc42b9d0744732515c5d0132d27d8854cda40b404c1018517005c0d50b2e03abfec344094a51aa1c0a31fc21be39b5ce52f90046860e961ac70a4308856503f88a2f18b1202b5517d8194601c73e839ae27cc626111c3d9d3b3008b208600e415abc0d52dbf5f329f8f84588dd571dfce6cf63441f33bab4a39ec36789f9ddf9e7bb31e0da02cc0a71f426d4e8499718dd1be47befa83495f11b321ba339b884779b187b5b22815148f4eeee5fbdc657fb63a5c03a8d53072a7862e2bd886612d1b3ff82856521863fc4d83e07ed8d983a4cc0e01c4c7b80b51ad6e349cf4a429bb0abe17b683fbfaf89a77e78965366731bef8502816cdb5a48b6fe8af6ee0a89c9648dd6d7b5d75cfec030ea72ddf9420a24ebf0e20128fae004f3a81a2403a9969f0c2e22f40a966622f0cb3b270c8d74bfb6ed1a83475c49f247ef4160645a0f2b9a219f3a62da077461d4b26a592da37dafaa1caac27b8c02c348faa69eb680be8b36fff4ebb2a4bb592d72d71b56ea78b4330822839e0680e943ef7aa1eb017dc2c157217455e573af4aa1af493d25878ba35306465697ede91f53204a380bb222915365cbcf11c376e50a1c1cabd93fe7109b346b68d39e0a9af121aedae13d4242499f5fb7837f70ef0e61fa20ae760a73d276211a36482d3a95fa97f42388e3c5cbcab73c483135799661f22f6b7cf8e57d2d9c28015724650bea7a265252bca82124b3bed55b0cde3af7fb8b231ac6a68db3e226c128cd101d0255772ddf4ca0d7339b5a35796f172799e2d6b03646dfd68f47c3f56526836aa0e16f19ab5cd7194f468cf28f3147824b3de7a974d22c8e303b4b4c873903a4c3fcbd26168ae6a1f38fb8f5d8526ed435cffcd1287ddfe12a3326e361070c0f4642554a1b485e41eb44305276da30899d860f98c17207bbe104a16cd0ee748e86198f8e447a1dcd443028f1a8f0a0b681a5ba38f93ccc540430e0bf662540874a9e8c289fba1c8abaf47ae94b622b803ed5c5e767c63b2a2592316a0457bda5eb4cdd0ae8336bdeb59af15e089e10e33a33502621ea3721c8058159a5f4ce50d0ce6852d6b702adad109847fbc70892832fa3d7ffa3a9453403c649aab84b2760497419fafe67155320c5b9a54537ff148051701ea470aba7292efe022dae9e57cf1b8ff53f095fc44e44709fc9204884b5bb3d6f127deb41c583b3ae8a22cd10a38d24def19c8687e95ab913683adf50807254a881a7bdb11168c9f5ff6ee42db0503b32b5b575824ea1f28ab7cd5d00184a8434614b26dc18b3786bde369434e48a14e77cea99e41983d7e8e8cb5142780794d3c31b1707a2c852d1adf7a70d5673e1731ee37fcaf4232ee4eafee3ca0d6fed3dbecf7ecca817328966c029a66f0dec6981aa5922caf21f0d83109e6cdad87cfd55344ed70eb036880e1af6a7f2b0fa41db489b3fd9a15e6c9bfe3b71816ead92367fd4c11146ad2daeff0dfa2c3ac6958b2213cf0c3548b7e010bf8db5787741f43dbdcc0ca946e353a54f34c6bb796c2be84bfe27d33888b460bc0d6b7a7fb78e046aaab266a53c2132448a94c1bda15a74c8e2df9d45d31defe6650ed92912e358f48594ce41227d0cf0dcdcc8b1642a48015041acca713ab6353f96dc89ee98a181130f69b97d8ccfbc338a3b82e71255a73b22e77d290b8252888bbf68a7721323a2683321236fba79d059e73e63b5bf98b2cdbdffd44b416de810223e81e1850320ea68669c8e781f616111431457c0c51bf14b609cafda2088fe298b5d43af5f2e253ef1baf8df9606c3257994db7203cf1a4311d3672176942b6476ae289ccd383a7cdce6830d7a6948a5f203a9cf2811795e14463454a95241abe0c5439a57e2b0b07e7cc8878aee0eaecc2cd6f4d47027117f0908c93218b9795030848fe05c8a454078e0b80de0565706e15538fbe93cf73794557d7401383b0edab88e6b3ff6db84fb48d1eab321ed3f4ebcb9f5340e5c7b583c04abb5bbaf7331a51629e8544f8a17786474c67bdccd12e772448ad646172d262f38b34c4be8f1394ee9b44f028489f58b19620f613f00bd85aad53a1e302b24535e61d236ab270f1d34e39ef22768d4f0ed85602c963c8158cc5692700a71971e7625c2fd142d80a707483a625f14a06570218fc444aecb5c3c357d5c32c6d61719e6136491ecb1084f2a1dcbd4330fe4d2e0611d531a85af784cfdaa4566cca3c630c881eb3f7d667c7ea556804be226fe5d8d34d7c01b03afde48eb07faa6273af3ad12427769762d7bebee96fa000c43ae217bb4f53353fa53bdc13f19190324200244ba2d46e1785a5b684c542aa52671c2c464123719659bbb119627d9e20203f417961007b58e963cdf525088345ff5ad05e08dd7bce436c8cf7af3ecdcdfa3925d60b078f140f2bd36502fc2a4c281ae1e1a7767b4fc9e5ff23634bd0604294d79fd2fdc2e2c25fb348e3c89ba8f62395bbffa29b5a83d572f3bc0772aface17ea5aa65349cf460850b3f4adfd1dff1f0666dc3ab409ea63f028d4c4951268de1877e45cd3742ae06ca3e941749c6b17e47b7992e30095b2c4863628f1c08d3d067a3abf06df0e4f8524d17c50d4dcabd65586ef643a3f7484342af76311d7170cca33ad7970db874a42b8b5031d0f0d4bcdcf8a43f060043f5789e37a23c791e807cbf53954df8ea938a306bd233392df86ecbd1729f9bb5958378694e33a637607d714dc9fbc7cdb234eaf104021cf4d89e92d7b35190b453744343dfbb7d191feff86c3dc07e99064d693b1d21d8cf98c4607e5be2d02d1e11d5a872d46cadced62cdb3bcaec4eaafd05a557b875323edaa8b67bb7f30dc854ebec72d785c0dad4642043392a39944f32df75396df24f4ea5f26976e155a9a1ee84d437eb8dcdd696680fecfe085101caf4e6079ca1be578e689851c5c52f3292f635b021b7ba4ec8aa0e0514950612fe68785709b89cf5886218e07711670fc7f90f506d441600dcbe02b69b76839c52f4a0eb6531a0fec622010df74b2fe201ab693e450b3dc40610bd5d719a33126dac3f9f9ef4000da92a6ed4e860e3b1cc45b1b32c1bfe88dc192a652de6ae998f9b3c15629fca899317441bc4a3e5d0f67301ea68d7b4b69b2a861f0e21f15c65cad9d9b77ffb7d94a278450e99717fe2b5059b9500d2fbcfa5ca1f32e9aa0e88bf902bda8ab2959ad46cbb733662665db6d2652fbc087ca4ff00ffe013ae6af2f116bb304b7778ed1188be7989b926307696e8644efdf1b4343cea3479fa90bb656486e491c37806db6c07156c2ff6a3704c77e429fb14ea43415070bfb977fbc6a0d0d00c43aa381930d400fcda95e61dfdfdc38e4fa8020e165edbabc90b77c18e7506b1bb2c3a91c2bbebe72bfa98c3486e79d013aa5579191a7115228d51fb04f4c00903ab61086b5adef632cdd137d524e0371321984365ad53aa376bfc639fd30bf9be88df092bde972b552ef5c17af46b4c0d14993697f266c302350cfeb5a5856666ad6b875fb25c4c09598bdcff4cf2632ad78cbcc267ffee0b95336b2abf4835527345ec7a5e3323209c0a204d8eedaa3e7c2c57267d2569ee0e23a6f48701193e20c5b137a3d04b8e3ddccfc0ecb136b49e7f3e21f32352de516e67a208a4112d1aa31ef3e5a6df17f9b95f7fb67fcdee175b02f984dd73b6f4b0960ab47489528e6d2af4540008d9e601fbd92649e0846ec2a18b33cda8a8c88da829271bb04ee0208ca1768e50aab29709a27b52d0fd4f514012a0daa06cf594d3fc69b8fb6cf65f97589d0d5d30de66ae058500c4d2c0ca9abe94b43017343dbd2206cd9afd2d765079e079e823f7c2a5412af5e47452e8670d1933985466a6c2c43ecc281ae60455fb861a1d50f3e0b7f533fbe912945bd2f088f295937d105ba02e7be5c38d6fb93c0a23f04709aa279a17b72622546bb69233c1cddcf5b67a80e14cb7685f81a33d00070f52a4dff558855144fe4fc34525d17de8bab9c79c3fadd890608d8288f722c107583cbe2dee262d884e9c68c3ccb109326552270cfe80609ba378d0a625d2b6dfb73c0d16c6f121b6c2c3a1eb999a99c41adaaed91470f2054de00780082a659c1bb958fefbbb0e6a8e6511c431e28d27c22371ccea9b7076c060a6cef1f277e623a2fb1565b306bc05053b379f9a45ec3bd12056f4dba1627cf007f640fd34ca21c2f5c4f13455376511928a54eb4fb55b73e99c4ad9c107fc976366d608c0017dcffc39554874745e5169e519efded0efc064ddf34b6d72bd066874df4dcf001711420e024706337c23b6d3048b0648d92758653639e2bee30d6616a1b7af4150ca35b6567761169f7c7a2a1ddc1c8434f5a448574a7fbdad2a8212ca88401e4500926d6778c13e75175883d552d102dc97441e6f59922a1dc07d7589ae4678e9f547d3ede5ac4d2112adec7644975c64f08bc4ca5c1ab667535445b3f00d65551b696518f48d951be82e124bf2fe5fce10f06fd7760a887ea034e579ea2ab791c69e0fcf708817c36cb687158c8ec5acdcf4831f232dddf9e5d3231e750b8fdc51262938377178fac8fbc171ba701716b30b2eaaf6cd93846eb26ecf395364c6bf0347f392e5b2e05b7f562f414cc41e20fec620db2d0f51974a3183934a9160438c412d8f069e01e544c56dfb4c8929ad1f6676ccbb51f8b1de935db825f4d6df00908d5db9fef0fc164bdfececaf8ce647162c0e973f2d1bbbefd4d75026e08d3d1938a5fbeb9a6a3170996d1f837b42e1511ac7eabc44af533cf4f343010c44c119eed93322f7cae5de7b84f9900c2611ef5e9edd89541c495bafa0875a8bf352627068160e1e8a829c055c4bb19aca479b4156a50fba1b60adfcf01f13f5fc2264a99cae4445adf367c5b8e1f1efedba4e25f119d3e64a536c3673cbad86b6afaf696a4d997ac9087bbdebe26211f5c94661dbe606e3f14ac00d1215ca327cde28497584739a441296913fadf07bebe5efb610c8419173625b7b8abbad6ff6575b352a913c72754b50d776ebd40fda33afc6ef7e2119dc146b864f1f6464413cdb9f427ea0e3af4bfa92ba45983f1890ccf9afc470f8ef99fdba81a24e40382e86755c3d31679467cfab2f21382169be99cdcce78722a6d7948f46ab52904e4f428d7fbc62c2d679db180a5e81c28e52d5f19d77c2adc46ed929eb7c81745d62bbad92ce1bcbdf343eca79f010fc3b5358d7b430fc7ae595a2fa93f677d2672b04b57ed581bca089cc02536d85b1d8774ddaa77448503cad566029db63516ef620b33306518c4525025c45c1320c1162aad33e9db2a282ce028bdf04b1e03d977355ec52ed4d83180e6145997bcf1c8d8ae1fc607b5299e5df92ef93a78fbfa0f082fabdb241f340cac1c9291bf77bfccfd85d240085a9d2018ea1bf0393d5c38377a745d2749381dae875a45741524683c829904c8058ec4ed8549645d01ba6cc0387a25257f6e664064ace05cccb4dae5129e4d7240f186103061ac090556dea16cf136704700b822fb201e8b53647097be1324e8eaf292dba3d0f0feebf7d3cbf19937aab4d5d7385b985a1082e7086705ab96b912d8491cb072c810793ec9e47a1b4814fc580f5c8848437b245b6db1b1d22af9da945476a6dc43d00e8db4611baadda9bdacfb075ef09bee3a882c163549a765c073cc5fec0e94b5c59ef3c8fb0de97a9a4f5581cd39f21550eaa0dca114958459f47e8cf6ad88b49347dfecc5aaad29764b0142644b5455cec2b59d1aeda3d4cfb5aef8fc3871184673a1480ec379a4b1c5a10b71716242b345792c7113ff2a881a744b34492ab5902d506ebcfe18c515806ad8b3d43f2b4e215b665f1f13fcf82c73fa1dfe9744da2521ec83bd06b0573541ab518cbc86caa1cac828e72fbc7a77e3ba69687e64c47eb0d4cd24666c10f238532fbdc6548fe27f8e2ea7415e8fd1386d6a8f1dbb4f4b54aa925dd43073dcc8c410bb27673d34ed7b3d00cbf0c102c893a9013f3101557c3a15a3de97ca6dce2e37500bfc8bbce210d57d923dbafe57e5ad466db1b5baddb00184c586f4a97a96154d20ebc85488f983618551c6d12a77c0484cefa31876af9308a662e7f5072211ecf67caec2b2f635d081b6def90af29bc5405b62b4a491d03fdd77ff81c5970976dccc07cb87ee6c64cbaa7c8ee26acd3d72b6fb4d548a11eadaaa81afddd2e9bde9d9dc24d0a26f3a4b8d05e4b8fa1ef3a50b73ec884217389c2daba3bc45335e282df6d21e0fe0cdc85f94dd1f6dba880ce7f44d77ff8eca6a54ec339ebde447b73b6cf2cf19407d4d3ddea69d3579cf6442082e2c1a4ea259d95ba11c6d7a14f5183dd10b6e5fc4f9afaa403bd09fa6a3016c459a6f6df21857cbed64f88ec7fe9f65dbd60a5d32c4d651fd9a6bf1fbcb5fc31eb3972b77e10d530ce07da3f72330d9a5147d8de7c266871fb4db564f85a8c9894d9de5cd5801cf1b497388ba25d8867a7f5810194409536acb61018f23cc1014f4540fe1508ff641335e67cb927d5a1d0bbd4bff21232cbe2bbb3d7649c13a9afe0ac7e2a3c4b0395f3d7663528b315a4ae2d09b8981605f8cbdd70ad651d65a470b195cebe04007b2bf52d30235f3e106be5c0320b211323691d660724c91a8e1857fc5945a16d2108ef8a0ed3c51b81fff5fc543b502d798bb6977db0ed59e778498edb51f566636ad2b5bdecfd779f8cdd55a381698baa82440900850704255cb3827c7f46acb2ecd03067c6a2e99a6c5b047f2333675fc06dca5835a40bfda766af52e3d0d9500183fc28e3127845e269fe6bcdee840eaa7bdfb7442d8e7061882fd0c44e92d61154a7c9acff484c49b0e5c4654e9630ed8467e0275f35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
