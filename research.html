<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aff21afb0bb719c3c2da055dd35bdcc4fb9375cd41d1b975d558a05e1f2b266741e069cf09775090f37408158383096cbc8d7727e9ebd27488baba72fadf890edbf289c6b04753510dcf409db7eb91d8edce46f6d7d3f23ad8a582bf6020d24e5654afddd1416c2f5e70b386393fddaf39a6750dd7300566214465ac75aace311739fcd4d7055ea2724442035248fba4a61844f79de079d53627b6a8471d0faf49ef73aa5fd38f456d537013c9538a4d9b0437ff03e07bcad6c51b455872f1515d1c10ba6ff8621a7a1757d7293b2410c92a18da19476d52fbb0494dc96bde4966861f3de4999c2b5600bfbe908deb8f975dd578b94001808a826c4cd64849e862f9ff6392563e3225fb061c93006294c854000bcda8403442382f72c966043401b59f84aecb9092c5a97554d43d6a0f5cc83321fb049445e1177f9133f3c21106a06c4a010f235a52a5e42db384dd945cab79d80069782a31a68edacfd9f58f40b5b9cd6ef537e649650a34858f94624701c4666c0917cc045aa45c20787a015dc1e8e89c8625f4814f33fb651893660df8fed6efae9ad99d330078220d2d05d42d5810d3530cac07f890303a2056d089c100c334a3e5b4153da7cf8f89cbce7b0cde814a8c8eed74eeffb86293cd25993eeef88a0fbdab19ae4f22995c97e768b1559514b0d73ca9db83ae189900332d220efb5db460e1bc7514588850be16425330d4480609803c53e25755a655f67cc3afeaa6477ef8723ad52613297cee5e7e0b35a379a39d79bd5253f358bfc1ad565f8a256009621055a385db0e2cc40539ae48addca7b0515c76183591190c5f6d0ad7b6e165c668a31cfc59e43aa80a8b3a89f9e14f8b211f046660219335a214a7dd2094e76eaa650a06c224211bb85e26686c706f547e5471263620ed5c272e7b7a9c7174f02656b6b5f108b9e8ba7449e263cba4f82527b4675807c24174a43c7012893c3d146116b0a7a6c7decbb45c91780a9199aeff2d32c60c9e5207f4af993fa14fa0ddecf76a0eee97eaaa04bfab52fc1decb2d23850fbf79bb55723e9ffd88407e1600a22b37db141da63d490711193545869ec2c25730e79cb372a6cab8567991b36a711aacbdd39f899eb855a52e05272102e39c3d5d0bfa01e9cbe0aaea400c432cd544dec3075629539b868e7c51255eaffa3be8bd658fff91aab87f88f4703eb9d0c3cc2858ecc4b1548af1f24aef3d4292ac195b5ed49f3f12312247d291c3ea4524ba4469f9393e9c8546c05bba53bfd90892a5c524fc25f233fc3b824e1f1156871efe98a1a6839fb05e4b843dfc974e36ef3778c3099701d06f6f455a11d534f1cf45a6a94e1227ead7bb89e92222d23e3c4e00496566bedae3d2a56039cde58902b7c4bf8bda07bd29daf69ca9e085756cfdc6ac1f97028fc14ef73ba7f2fff8d26e5fbbfd8e55550ccb1adef587c4cb4e4d611fd71c345d6781bfeae5788c79a8588b0ff62822590c7a6fd3f8a36f43d1b13a9f66d89bac9a6f8137f9c2ea9a3fcc728d275ab89a344213d1bc3082e8788f87a3348e68707ae9fc34466cffc6a0f9460fe0232d4bf41e30b3b94f7dd971d24168d75a0268c5cd3dd7357242d85b6b1f10d102b8dd35af994daff3f17a8e08dc1cc8747621e539051c03c448cdec3f5a755d7142d049a4ec4e2f277e4ca48bf26479508a168f5f091a1bb0cbcb992c70aeef548634f6836ff05bd3463c14c167f4c9fcfbb852718fd85abb139151e5f300d641b1a631087f4e406452f9c172a0a183821af5d72cef675b191121e8309352ac5bb739d8a12643539ec46401d67641caf609dd86d9b54be8c3028faa507a339fe33fdcbfcd846476c7306902e02d48fcfc596ef2a40ffc0988c14be784b0eca7ee67debbc3bfc171f52bf7b58662add82bb83e547422dd31ed3324df3f2bb6e9d34ecfc524dca32de16f5f092343e60b90ab0e93318e102e1ab82b1f2c4333895745557fc9245c20608cebb724e624a10a67de54160c171250418515723d22424e215c34efb083b7b7975b91c739f6081d523f339115e24927de010be6b12fa78f1900f278df0179e5ad6c79883455d96e39b6fa93647a564dfbfeaffe403d42e06fa2b85e085f165a8be45222c05850925474283fa7dd17b064bf3d812341442883f4d656fa83bc86d2fafa11f64ceb51e6415e3a857ea82f678ea18c7c9f729153056dcb33bac820ded6150f14ae19dbd7a7db85b3d8bc8d80aca9f3fabc07519e5bc4c38d9b39f2e8ea04fee120c73f8b10ed0e46e9c05ca86431251ca048a53886852f8ea2266dd48475102108afd616354a5f9873871e77da0ce0ddad7c32bc827f6a3022e79eed06b93d7051808adfc5bbb238df8cc73ba23fd095a005dbb2e6d254b655a02202940d37d0dbc965b8fd7d3e362aa1cdc674d46a5889dbd4d01be4fefd6182a19cc817f6808b2011082014c3b4f340dffd5854379dd879822705ca70970c9114f7c70a26230ec78471def5b916f22188898c2de085d0053abb1bf6c911ee11422d28570bc84fa56dc367f3bf8c7bd5e0d0e8d68e5b84df2e01d2129238e1cd38593211c314312d27dca0c161a7bbd6beaab91dbdfbf353dd0e8b81ae768adbec872b35ebae05a360ebda031555b32667296343c45b056f451739ceb8723bdf91f37269067ca63bf9daa0346856302c7db38d0cdda4c55cd05d5fc9d9b9d8c2b91f8cb121de7ac287b5cfba2215f3273011c23c24ae33e251f0cda5a271ded8dc42c96ea7b060acf9c0a4807cae4c7bf3b3cc2b084640ffb27680e0f85dba62e9bf65cc03ac4b2bb480eb3eec6c21b44e076218608358e7e336ece3905f5ac138d5beded4edbc0996cb997f73bfbba11f20383f49dc75fa65fe6f93db861e9e81194d558fd470f0e8ab01fb2287d42aa175da23aabd1cad74f2e2598b64a533b7abcdee90b718aac530122c6ed3cb4c3ef721f8105e6a598ba7048f31fc0a5ead703ed4a40243627c8778cc91e9cd87745468771c9ed646d45b825497fb6d9bc57289756d9c60a3622b013bc540d2ffe323da9a359c70e3c33721c3fcc652c8547e8ee682c891f84e84e5e99a6b5680f16a04f52125614bfa834f6b09c425c4da7ca3934933a6e82c5b2d131bb3f03e32c9b4876831ab52a12c4e2c37e0155da37b56ce2388ffce018f0dd885e84a406d6537ac178266b4dc41c035b40d4d3b6c0348a592d0d4cd0280e8318b7b5203f97df48244a1ef498508f96b3413c339f24ea55534aef1a71de78b12283b13116fd5bc6331f6a68a8048c8d805d43d5e97d22901f9c5827829032b40d396b21373a1a434c7f7091e2994cb8bd08b160578752ea60909927f25126e46f5d47a152d3408e611e58906ab5a03a96345e12edbb1a680693b5baa2a56e246c81e60447793a589288a2e44873903d52389aa829218e813ac04c900149e7c7fce637a72f4f74c6787f3c83b05aff8be6f89e8cb8ef7bdd5265c96921999c158025d63daacb60787b5119e722090d3c4f421dc0c1c44737108b3bde83ef0eab184f19ced2586a8344f5bd8464395a20b43e38dee8457f99915b8c95a8126a1b93ade9903e93d197d7b43e2ea1c63c8ba34b671aeeaba1ae23d99873ce9d3ec0c0d164a84b7f7e3332dc1ae57670a2da80e41fe6190c6520e90d5839eb641820336cd8a4c35e2e306e32fc38a39d4ece3380b8903220789276a8694d474154176dac10c14d8f9404410ed2ab4a58aa04571970916bec2700a6f9d3f0bed82566592d658af342ece14031ee8df5d7fb2d144cc285d5fc5b1b2bb424ba91e089aab6f402461445631d9fe95c98e89853b553588827835d6f362c8e85abcaf3d78377efeaed6fc0b766731edb9658eca19c7f7932a1df085d41ddd4da7cd21d6871f210f41a30ee0b999c45f4ef95fe37a9c1be6f2e23932a1ecb005ba0f50535b3dd55c2a5a93e1220be6e6d09fd48f88bcdd0919e26e7a3fa3915ba829bae2470ea20e6b8f6c4d444412b73ebb00e741dc097b591576a5ae6b905ea03fedea31e4c21674ffa17ec88067334ba60fd965ed2f2db91e3c134f550c87cbbcfeaa5562a7c40337aecbdb9fc2d6c921d2d5991d5b71c118b47cf3b5f7966a4bc3dc6f9a6811027d7df5ebbad37875956d1377a0497428b26ee03d589af849d719be9e191713340bbb19456d6ce5b590124118855c555c5f935de388a916c3612040cb34ffbc777fe3a8b109725633466ee85567365a9be8c950b8ad4b3da66898345cce77301308cd1d18821978a242ee8452e022f583aa85a574e0de863157f5f6e211ffea76b932c40169bf5abf452b02acb99df1b6cd696743ecba007a2cdf4067952d241fca24673200f461ecac29ff1cf02cfcb561f7c94fe9af722dc0a29f0759dd15fa0d9d9e4f323fcf600cac266a5755e79fd1f4e604774f4dfb80cd3d629f1a90d445e7d7e53a25bc89d68bf1047fee36fc55e1d766ef7dfb94596666d0c24bf887d596bb30acecd4d35cbdf3b8827c88e75cfcaad3618c1be5841fa10b19b203a0705b2cb339402256c2abaac79ce1b8651c1db06a57e0170ddf6fe0b4fa0f1731d6e40969e0e291c374420eb3a161a21e0481d87c2c77485f22edbb367f8152da6374d6602576917e571b07f7fc71e36a02782f4a0cc2cef36e629294294b6037e61f2db65f9f4e0d46cc2de978e431f3ca116e297caa17f7fc39a0c72cf1c2eee98d685a2303a7db42cd1bc0f97f43d2c85a118fa838003d7ff2f81c0aa1f9e7fdb804f15a18375e28d587e98bbfd68752ec692bd50dc1998a82e0b354cb694da2d1a578c88c65acaa9f1440f75e77d7c7813a9edc5246ef0e2f45705fc50ce239a527d0701b076485fa8817a6764f3d1a48e4ff9b55370ec1c4f9b3e74bbe3f3d077f2e0780d769a7300d43b6f376048165e9ca45ef6bbcdae9ec69beae4db3823767268f16e5da6de83f7f06810c9b5ebd28970830848a16fb2abd21f071e3ca0fa94f17e574d8ddd6a3de5360615f3a17f30d60d682726bb42693cd05fe435577793830b916b6986b6642377ac72c987d356e03f6d3fb8f52c76d0eb8388d94d0063e6fc777c9f1741f538f02b66eb3c45d2e769de05c974c4a6e4ed9c56310373fb83682cfc7dece6395cca83c6f78a5639168cbf4e64adf5a69badc14d4625de76aeca3a123fac6c9a0d75ce5152f018eb92d3bf730c41f643c40977fac0ac3d7b76dd9d32a62204aa28fbc1449e61a2c3b2b49bc7880fa5636b9cae5e2f2015513410976b82b126c7e866c40a863b7d8ea48744d7af47c02d3c9c97c725b2e6922bfc8a187df3f907fd14ad17348991886150b50a32a79e2ccd24cf992913bac6c263c2fff6d6600f1f62c245de07bcccc9c69c259657e54afdf084a8b7344f6b799bcefe32d742e01c48f6faf557546c1cb6c51f955a245d979e052aa45e93a954c2ce9c81d95ec8ae7f7fb19821c9d71476a6d834f1170a96b25b739e8fd2496cc0501280f369eb172091cb1bfb176da3d10b981779edc32f8f0f056590f1e883bdb9cc6e8f5acb155a8b3cd36ee86a89c8a6d221a82b105ed26a8fc12b342023fcf3a224e3cb04c32c3d02b55a8a3d8751f0b85ccbafeae78938e4371cfcdd44248d1422723e1925c5cbb69ebebb9f006f5a758608a1ac6706c45818aab6626fee3da25d0303d6ba7d6bcea413e40296ff96807dea8056a70a75bc42ba116e42d4ec6dcdf9ae3c3a9e946e22e848438f7ab7781e4ce3a3eed1719ad275f8804ec7e183e3b67495e5dbf63d8b21565ae2f21168e8f81c384b6eac109bbdf64e8a046097e7835f3fb90d160ff7ba961cdc58e9df55e0e7db6789922e2578465b072535418a9a8ee74d8d860987a576ab2951227e6ad6751e165486ad2b9b276d7a037b6628c231a24fcda8b0cf124fa59e7d4c24d4230d35a7cfae6031b13aa4ee084af0ed8efa40adceaede08bb2e2aec2b99b50873adce020130e3d0aac56426e822220861182bbc093450d5cbde83705c72766a7703e30787450cd8a754030258aea0db1fa92b8beee19d2837712c2925bc6ee870d054b67c518d2dec599d4e771afc52faa61fb3cde829b9831499d7e4f96d7cdb567f911b5089fc8c405a3fe3cabeb035b45787328f40fb0bcaa05a6bf1ad5d70e10a28389187419a2b23eae306097ec9c1b9163ac921c630369cfc4b80bc8bedf8b3a979dc7e4abe196764119db0a655109b66343e0728858a9323b15d269ce4f4ea2320fbaa988d325ef41c01860584e4e0359da702b9c0333b3b95dfe827c1971d79ba7b1a2f4b22e34ce63177844c881cf9af8dd442312dcf6d3a98da2800b41976d9096c8ef986a3ef9da89e88bd8e1fa0621a1ca1af14e0c20bea8322c41b8af8a0e818169094fe4ac554126445ad7cd28d62903dade70c8ecb9b527c040d57df743e0227da0556d1f073e09562afc3d3695053123f39f4640c4e826a51d10f7ec71845bcdbf57b9d4b26f79bbfec2b3f02835c8b920c1b59111601ad590f645f184b1c8391c26cc264a409dbfb9df852e9d68f27216b95fe1df634ab40261e67d5f522202b4efecacfe199abe281a87ddb2379118169465fae7de536bbc7120b88debfa8f34f14555ede5a67be544c3f78afdf346f87e2c75b5968bf92fd3f7dc095fb74599d13c278b31838ce4d3aba399e8d20a09fb2466bdbca8aa880b88c316797c318760424ded33815d99e50277a9ee1c478706f83372066bbae565f6e8c78ecf398457300d43b2de2432117e2b48916d3e2d43c64f57f2369c0c163acb3ee4fd0b6652775293d0ed7de40be986b3953df9c7ffc563735f2c55be63d871e7ad464d7e1c928439f04b33bc75d91d008c6b4e14e7adc2986785d86b9fe3a7e181380eaf7f3ccdf029be42e60860c470b338d5d9db177bfce7d26664303a43d2014036e43bab5608c82f2e9dff30e803afc14c1e2aec0ebab79db7f798f367b1d1da1ea58ece2c9f7e0224e0ff8c2cf19effcc206982246df0e195481a57f921106318d83326240422f5edbc7fac9437c302830617790ff583016a9f291111278afa45b902e15ac538feec1c3c0953326a866b0821e063aa13011ad7161d4ef4bbecdcd1e19e03149d2c265e25c4fc9c425bf197c20cbc80a59bde002fc8e1eb95c6eb9e67a1cbfe257c3eaacefc1f97753908fe9ba33711366671add3edee887878504d20e59575e14b60343d70d2c7fd7e67f61b70a915cb8e36af77dfb8c0aaf0f3032132a276e3fe10cfd0e7b0f6b9274b925ed561734036e7d0a8f34240c92bfad9f3b6df28704b51658f31ce9a869fb2fcf1355890de9476ad846761a0af2a5f1b64dc95614babbf07bd8b3d820ac39c1e5fc436ca58103bc3e2a1a665d172237300b1ae59bc693a53e764dedf5d92aa0be678cbb0ec879693aa8ce804e6742ab2c081e23d314e28949b5641df94b363a1b112713e38cbb298e8e23e6baec4b97d3b4424345b05183accbf7412adb65142b666877014dd89f7341ca98cfcab5ea0472b29cd4a37e08da8b22cdf4b265212005cdebea6568436a83613bfa98c3fea9c6b853d96580b6aa8ebcfb713abc718363d233a785c69c51f47eeaab3f4e80460c8c71d18362fab2a202cf54fb9da3457808430b9153e004467250654c275370bbe00e9d24ff67fc210278463c7df84a1e8a6109c43b04c9cf370ffc0b1faf69bd1d8de8570cebdbce475214362b9fc17918d862e0a524e5b5c5ff41e7900169cdd82215d6bdf333d7db7b7b498dd91b8f1467c3f4ea2016c576f7ff6dd5c3506bb7191ecfbf44d95e75ce8e42b9f04f7157e80b8b7c26268d5afa0df8a9632a862c6eb7b11f017c51f5c1b0f710db8fff59acb4cea24f42feb8d1bc116d13875c2a77d5dcb8a90b1de4ed5c8d0326ece66abb495fd440669d1e0d7de2aa20d72a5ecce8a4a806d809aebede4f7ec3efb3eb3bbde9902fd7cfbdc4363033515e01cb94c61394b1c9892cdbe01932cc143aacd53d25016b94b0a1fb449f0e362f15790fb361d5d7fe16ac2e72705d9dfbed95e4d453b10c8b7b490379c3c49e2776c8ee5624cad9d23ee349a88b6a5a7792d94d5902747042b5d5c5d6649068c6c2c38bc4af00a159b60c266eb5a143754b591e86cb2e1086db9ceea9abaea51f938814e17b9a6331d46a58df7f28be03ab89a508934bf8de9a1c3eedb3a58b1449393342f82931bfb5e74c09c1785aa385cf3e84d35c49f36901e555948512456dd9e9b30bc3862bb773423d99b6bcee9bcd8fee3a3943880444643f35a04eb87066da2a90f238a15a3b8d211e50efdfe558418cbe28ba27bba530376915e1ba26bb5472b6a5421c8f62c7da3229b2de21a394967e6d2e7676f1129962d1b29ad3c6cd2f3cc860e88a7c482978a5c9e0c9c999f797be8bf9b7008230b6601c0beabd8e95f9c6236ed70406a3783bc926737a73603c34fe791f5b666d6f4253eaf4b27583a986312315945b5a737108bff510650cf3fac7262da7717459ac4d42883419bbafea4fd6d128fc7aa55daea9925b5204aa2a0dc3d4d18eb229d90f71ba0c171ff5fc25f68ebddc4208202224baa57e3f51e55153e29faadb66c1f6abf1b280a038cb21574e8facc6da9821a8d02cd12c7cc59fa25614493c0777d11a8a338971d86a9c2cb9742e6ea8875e3041d3cc7c4a28b0a9a757515a764505ef832f9e5be6476755c8f7b87c8fad89915ce022050b69e4e97d5e7cf64451b1737c8ddfd9be3831498b273b57271daf07159ed7c078b4af3f743b6a7c45c55439b1db1063140a8af453c098ebec9236dae5ba872e8646400869c5a2fea508b39af8c4e0dfd4c25fa222348820cc43ec879faa51c40329f9bff676a48cad9e196959ad72fa374d3e16bdcfff7a324917bb171a4fb4ab7d1a5ef2a48aa2f0176d882fc9653e0745f922d68e0e1b59443a5b5672c8774320ca8126eb5574a0d8b84b2568a98458bb202bd9ffefe853ace7954617d20cddd693e296c88c367905b041ff23cb643a3c7d296b9b7d4276daaeb30347ecf2735671abd88ab5137b835e23fb788a2494598d5a6c2f440b2b7e28c5254a9003c5e614a97b474e34551876aa62ca3707642999df59392a74ababbe706d6c9f8c79d75856330446ba177bf86d95584284f3937198af3db42ce7ee09ac0f5fe54b9297269da4c65823f915315b9a2f5f5c8ec2d5e18b2bc640b503b322fa1563183dfbf72a8ca42bfcb5fb33b24a249c941e1ae6e69de194cdfcff0803060dae84bb5a1ad254454efedbefb71e9f4128147667835c4d944129c6ca9f28e73d1260fb819744601a7daf851e35b435bfa689b67734f34880988884b995be4aacc4f1df1f4383426813920c86fd675aa8178eab212e9551e6637f0ba78553ffc328e3679e78a6165c2a37d7ac58808b07f43ad1f3d705105c54c1708bc9cbd57479d74ab1be971dec7814acf3ae455d9b07e0ea180d1e0f3c81542f3e24fbd18b4b11b3eb49723b491a6dfe1d124851ad9925e9c3decd235ab14e0ef6b35b024b6c558eb3bd99bcf3f3d56239f5d68bb8c049306547bb030b1fdd56d0348366bd94ba40011fac6c0895ba8de24a83d45bbe47d0c2ad389ac9ee1f27b626b410d0d56c3f67beb9ad63bc7759a49219246a493427f4b4f9ae2bbec3edee7279a7b2afc9d9cffc6cbd083857546bb9395f4ae6b0cd6912dc6141de6b74679d5ff37c20611ecbfb58ff8b99b0d07111082c0489fedb85c427912ca8ebecbdfa9893b2f0227c38c344f7f60330f8429c93b02e7b96dbe710d20f24616361f55725d958e78b0e7e637774501d9b23a5147a7d2ddc9bd6a0e212c04a254db81de1a9fcf26d10e480b32a037ea6818a801c6050a0b1606e8117bd36f27da6847a1f08c5aff7f957a894fbb58f3fda04ba1a3806e8e4bf6d331e3bf757c5936f212052e50ba355627a618641d542125fc866f91ecf0d639a7d2572ae0d4f4af9fd8ca9f1ff226d4ece6bb1a42821b95c28dfc1aac93cf13b90bf0ffd51a1e58dab0754f978fc4eff418f6cdd36e4a3e63c772706dc7ab62f31872df1c0cb9759d498772d641362de5b28bf36ae102dd05a1946bb57155af55367c042eea8012bfce88061be82965191c676a14b1f202bd4dcd8f539d37a7b97c51a6389b32cf6b5bb7687a67cbfe51c1335474759175943f111f561101efae02a168fa7ec6846cf72731eeed47ed4b9ad397391a932ff3f875ac1b41071fa083fa73fb78b99a807fe76bf44c6c493db29ab1d0208623cb7484b381e42c66693b79fb79db3ea58d47e9dc8e01f770e0abed90f519bacd358a935c809d743dc4c342dabc871cca7fcf2aac88c60c9c20b72117acf034ea0b8486a3dc9ba72296fce8b886fab1f5363e56b56db2b80213515c864fff83e4033d86f8f058b60ac62bc4e722b2a61a768015f599f88e8f0ec259e7c7ca5190067957376301be5fa3606568508d134819f0a51da5e71de031e9473fc3095d690ae92db7069e37852afe92c7dd5e55968436cba148acc7f12218254eebb855e9745dbddf2290480f927b6e486e9ff1cac24af9d9de18ec8a4e9d3da89b9a7dd46637ef344fb263a31a98018e4e4ae601a568c2dbf99e375e952a77cc327cab5d137f63a40c16211dd5f30acf146ec1e1d42543dc40f1293f036bd4e74089cf72ba49c68af579a1f9c0ce299c09f4a4128cd9443e31a1c8c70ff49eddb1cbb4d01163397daab3101c8399965328fe48bc34259ede9c01a4348f3a961300d6c7d1e7fedc97cfc1e3df5c3fd19fa67d6f7b81b4b953a5ce2257b69ed8f94b4b0f5c0a94dbc86a9db41355a2858ddce7239a15cb9b138da3e96ff9998d46d81a769f12ac04a76723836a03a951b8af18c093c8d36cf44c30d9f4b39a620229e22c54cbe1f39bda8632b09b0c139d230abd48e8b5c5004d039901883081f4cf351134cc8e1223371611038f9683b68d682e365b50e6635225caf915715c1a9002c8e43debe0d1e89b576532e62446022d351793df5f91ce86890efa5edb245c01b32ddb384d194cd745368c358ea6bd96c73299373c44b2c5a31c1394beacb00dbfe1c93a0fac6f631976140e3bb7e190579d8abb6d0ae2a72d5c7e3d508c01d61e270d79a1f1ba4974652e739be0a9f6455440b8264c525d03cd0e52d88c821e0f6218da09d914d3991ffd9e3d9c6e1cb7a5c6dfb55324a5e7002505bc2c07149e57d2ce1817445376ccc978087496c7410a91b55871c35ebcbc19989f2117b05b488b4c9f7eadd6e912a4a1c57ddecbeeb5c2dcf269598244dd630d0de98d7fcc722165bc8085654d51aaa815be30ee5a8f5297f49b860e63d6dd632414cd17d6387e6434d6f67e3e99b482b3b4a5093267e00e1b4c4ed8cad656d1f641d94e794444667c1482744d6d8620aed9dfc9aa1cd0eb1ccd8d5c35941b771ae482c7ec957df634c15e00939183ae049adcca83178d0a16f09b01b2f0be48a6b9a1331c78dd868a28aab03a8fca445e2042ef74a6e6a297bba26b465fc14eb3536a08e794b08e44910755631a07b0d8c01808d10030d0ee5462e0f25718c2c4e008f49995c80b4793dd49bc666b69b2a1c573005566767dc710816e5cc1bdbbb67229967ba4a3fe890847fc312e76c5b614e7b2b8a146b6bffd8cb2874380241205131b04d6e817f05184e89ff3d5bfe75d1d895e1757a77e8b6b5be3530f58705606d6e07a6a3a04b54a7701a080250e9605d4ebd90307e9c7724e0bfbf800425f4e958c1e49eb60e81c3e06481742f5d7d22b7d702cb5816924fa25e215f120fc519e26938c018dea87f5dcaea9a66c559eeda4029fdf27dd4e8fe8cede17ab1d822113c43424a4366cac8672685e39e6df66b018d7705200a0351879fb793c209ee5e8192edce00fcea73246b95a68b205aba5d2ca8697463c384fbd422752d22aeb9fd4ef22a0ada33afbabd248b8a0cdbe401e1d97ab0cb9bbcc596af99ec15634854f856534d87f60c668c3f492f83eff0edca08fb8e5abee6b786f370d070a7030caebb7db74861e52a129b45d0a0354d036b1ce32560827fe7836988e950bddd70565afdcf89956f6bc70936638bffdfb890b5e889954fbd9a6f4ece9bc6c90b0df59bee996b624ed345261a7a813358ce99711024d2511675282e6379aab97d1bfa1cd7c6d0a160fb058e449f5e52dea468684dd6bdf02825a4c04292f7d1fe6db8a572e09209e444aa878848c783b4e693548ebf8fa9118452433175ea6f32e69f4ed51ac1c01ab15df235ae7f17891d3dd09e23ef880416f3da291600cc7eacf7845e4cc427845d19d44e083ab738ea678c315ff38382a837514fcdebd720320c66cd057deb2d378303aec83970765f2ab10bc12df456781035559f20cd505d8ae19550ad7b9003135c949473ae1fbd60bb6c7b47e3ae05aeb2980bb159a9d92226c57755f2a02874e08ad47714da2e1628183aad465c7c5d06c3e12a5c5cb632651fc3096648561c0df9f646f17f1f9de3787cd0caf6b6758409078291724d22741c941b5cb9f10db7306ef7eade3fcc097c0952e39901e4c53373c2eacd63e6fb2ace626be60350e9e0b772985b08d744dd82aa0fecf22d370a822855c2e2a00e4793c726459863602e38dd8abf601fa9083ddba79df7952f7e9ff5dcf18d83df0879a3f17c59ba26f328466a3b1419695eb81525ef9b722aa40e33f2757c4e3b96c9db290b53e824d155d13ae43340ac074faa4df0c1894d8009a72eb8ff59dc5eea6f1cb995e4411502248f6ef6d7d00358ec1657bf4719d18c5b26f18f389dd19bdb0371c711b50f8e11a6f1dbf77758782cfbc3da96b1564e4e9b163fe71b0d1fa8357dd9f1fecf465d0c747dc32266fd3429bc25b7061b4c345c7bef17a0659ed48db5ccf949ba45f1fb967c5516603ce1a7981a6ee09db6ff46b399b7ae683702dce62c61be0a3d70c6537cb99913de2246f8a6e31f9888ab3690439e36b6329744af3f693b64db5d69b26f67c2f694bae516e59eb267275a3ac3bb42fbd883e9e271b0a5a76e83b79384d00515c36812fafd5c2c39a7ccf281f123eccde1554b8cd1ae61569e4e3b6ee419577c90752ac558b1791efd7339bc0e8f3e4161fb17ec17b247fad505f0d32ad5ca2bfda49e3a6343231d33d20460076ed30a90ff7d0aca5cf65295e2a7528714115373b6b5d033ba3443ac9495ec995bede00e4bea4613f95ac295850f29f6f163888dcccc77b71aaf0d9f208375531943f0b7ccce6f5a78b1802241fddc5ca786afc36d00ab19a7faac258ca3e0bbd6aa4867d670eae0dab63868f6f4a3d254598d7b03bfa0825d978ddfa39e3f0c94a5fee572bd3a9b3e5cd346cd3d146d60419e8d33a06e49a6dd0d8110ad85ab0785b754efbab1acf3b630d5d29c8f4243b87d725265995401b1ea8817f7be422b0d094cfa255d862befe2692e66f6748f06c25515434d9c6872f90b092bd8e408ae4e4824808a5d96ade2ef338aa6401eae121342413919600a259a35c84719e90ff6684ddb43f863c6a0796adab0e96101ed2f2a1dedc39a2ed21337c9aa66dae393d2753ad5428aa6ec59f648fc25763be761d059b3a3e982e6db0c501dfdba6b994cb55a1ad22cddc0e18983dc6c77e8811634cd34c8b7277638f2fef7d8d7b9962f7aae3fd8f62a56d4a3216e221c910fc0625f134f0eaa38db364df9625159b8e5609a0fcd128682dc277c29e1e2d8c5aaa720812b1aff27c4480f465050aff794e1493bf2200f75a77d73235e1b92d06c9ab0e28996b52dcd75408f980ef0d6f059594283069d3b947483cca114023e06a71c4277484d39933c96358c5feaa647f204f3ae57b4f1cecc62a751845f771d5c991aa0dd3f0cea348729206ff83b385a0e78a6eda01cbd70394750a569280f1eabf8da4924fbbe2fb20977e757145a768fdba8fe41d19a87372341f85eabeeca00351a1beae9375d11366ae14b48120511f88f448f2928d2d2fc7c7015e67ea3f68bb81316cadb7a62973476ec36da5af3fb9a0886d33a6cdf1bbb3a4db15fbcddda17f4404ca9fa42d54af861e4157549e9489f1d6ced95c159fb26577110b3dc36df88f5dc2d007f6f4b36bc3b5d1beabaf081d7610b0371a123a352fa9fb7f891935ad509af2a074ba27184f7e46f308f3f674baea1a51df7a7c391f880021227a6e594","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
