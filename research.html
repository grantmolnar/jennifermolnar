<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90c89664d7383c5501b05c7bb8dab964e868b0671c38c5d39b3c40f5ae2350f299932bbf43068edd30749ed7ead6172343fe0fde01152d72aff35719a7298832372a9427eeb581ec5e9d9ad9d27f77ab1e5a2c203a4420ca30d2a71a97744d13c60b46895d7aec73c3c6674e9f98a7db9818200fb4890df77bf019027b3b706d446e08e8c8947d8825b88355d38b82fab50f5315ccc26af453aa4a15141d0e1189a1e3298fae5be2f6ace01b5196920ee5307e498fc386ba83bf627e7bc486f998ad47db1bca89c9f01a1137205fcf523be89fc131b140a3736db5907859ce9689397d52005a5028a30dfb19b0764826e726419733aa14111a9bb5f45e9c79fe904538dcf54f46d8212d5640ec1e0e6389ff4f19508995afde260b596e8c16f4015365ae8da0233c9181fc5c93fc3ace4ed0ec95c99e05d88ed4c93c0688e3d90cd4715f60e4bdf31d6042775d309c4525063b54141ef8c1c32acb27fc6b04c7952315f3f734d88a53ab0070b06bf42f9b92389998712525917c8224b2bdda452226fee59ebcfe79252fa7b6d5c1e24631fbed81746b4fd41c185e25d6e638f7e3ee788b80f9739ed94e3532f46f6ed0d15d0369f75039c3ab0840e0b6fabd3acb203d10ecdd890b5dc8813e9c8af9de098fe7548b4618e66a9c85aabe29c4391892ad707f7c12b4fa05e9db8b89f8b032a51cbdbe45e07870546a88e3ba8a2d8b50604d4e1d0b167e0fc8d5e61cd9150123cc3b0dfd718d5648beaa3ad8277c7ad439600820d8037c7207560dd57b59367c68463609ca87feaa1f2e326b770f2dc9b64fe34a6d6a11ee4d03f0fcdf2d9fa4041a6458a93ff3014f352c0cf29f3dd66d17dd5c64af5e65c1e6dd712bc70e64c578e1fb930bb90b485042b5a2d4daf6922f2d8b049ab78e40f90dbbbcade00cdcd07f0761d63774718da9f3db44489a3db92072591b001f511e69675255a6ff0993d4b5f1dcb1ca383cf6f9ee879198f067c46bd633bb186de87ab5914eea6d4547f8df93e27dff7857196f766e45855af4d23b02080dda8b4168928511467241415264b9c6c5b4166eba1fd048bbac090b55b75e59d914b5e6c44fd68c90f6ab7748dc2420ea7e7e059df4975132afa3cbc1b70c068f3fb7b6a71f70d8a1cca8acf165b2e0f7367015ef0264391e696a4b2242198c949fe891ae05d29c0b2e894e6d0bf021fe95224c59bac6a69e01f6c5a52a5fda606c19708f9e4dfcc3834515a6d2ce7c90791bb08389bcf82b018b2c657c191563b35db06b80cc9b1911cf520d3697abef0281bb163da2eeffd1697b16a0478a358e75bf0038dc2c6dfafff5ec63fc7b288d868be055932061161271f1380466a5efbcb4daae0d3c5fe3dd0cf6a4eada1c833c6f7d54dfb3f2be5c2073ee05954e0af0f7b2b212f5b0a5ea13ba4923bc4721f1dae28f54763118b39dc5d751718c85511daf48840a96347b61a9636666100f1522f0857d3249a52182c5c8721aea624ebfa495ae1f489b80e48881943080a3b6c4c07826ea7bdc1e386f6298feb7f468fb2ad7f731f12e3d7d443b61fc52d07eada200a00a8eeac5eb34f5b8266d7cbe9a18f2e84e0a63ccef703c06ed4c05f94e56df93d14871641150e768cc56776332abd016274cb925f138ea7b2660e044e8a1a857a20d449d4a2fbce360ada386746c79bcb36411c6a6ca545b315c2748feb49261f9ea847810eecb6b043a330ec853c0c7ad0d5de1979a11c15364847cf2e0e52f0f11186f104e7337c11dc112c82f2ba283b5ed021a07728f3b32a38d79d466e19fea160434acfee47134dcc830e03e5edd1f923e6db9c2d2f6315ec1018c2ce9e501e3267d751c1c18e4dca77b916e10d0d75c12ba6de7e8fbf6f354629fbec22d02194e21bf4038f67efef2e43ce498d3eda1ebeca7431b2abb5f4608be095cadcb3acb058cae2e1800be49bdc35ad32bdee933ac079d53c0e2a7b53daa00cefae9e9620413019bdd70b7af076232f8cd1718eec189ef26b5f6bd10138a65bd524d484314215c942db520bebac9cfe75dec46103a273c36ca212b2e6162a136798fe2f42eda2e507e7e9081744431157afe22bcf4aec11eef18e4e83e5814ff21525a9649901793000621cc5626f4e39f73b279a2ce95a138b4c4fc946a80a5825e18b52210ee4b53f051ae12151bbb99e56517a313b40fa009bdf068446c82c9d37807c0e17dafc51b4dea5e7e7698b9ca32e96c348cbdb59e5fa9332228ea2ba8eff94b01f558a2dc0305fa58a6249bb354f7557a86fd6d2d04de60226a52057a4760760fc18dc9dda740eebb6c9aefa6f2d1e35aac42bc727e1858a988f798f0ca025739afc79583171e361c81f946a71ca8bf3e3f49ad2109f5a0be52a85a36941df7cdf532621d68a110ff260b23941e289753ac69f562bcb7dc78a93f00083a3ba1f92dec8e56c42c1e134a64ada1d63bb9ebfbd43fd6c11d957e28c5e66b710e849f530e3693082286cf3370b5780cf38622eb1116781d9ff2963c13da09b71428afd871f626de49103a68ff2e8aa7217c6843e8ff882fdaef89973ac681b54f825534546e952eac452e606914040e36ddb47084c79550aef4e189c0393f5d8e08f62e8ade99ffc0c8b065d000157cc356709f0b8dabd614da7b97ac358dc39e62dda1bf4378ed79a97325f9cac76e87af939599e84f4f4a8395f2810e6e91c27853dfe93c1f620ad513c0fb04c5985bc87574d62bea76cab03b62a51396b05a9d6da23e6ca8f70372eaf187208152dfbb2bfb7c8d06256f0d92cb30fe5b6cf9b0895613e6339c2315e0a41f50ced7f71334a364fd0a40ee0a549013fbea52aa605c62072b41a6558e12b3cb95911174ab8caebe698d577728c1adcff71f38d86434b9a3f5e80df5ab3efee83cd5b9873bfdccb4a48a841d8426db6b619d9c6eb46de931b66ef97607fd9239b9315dd413d00368bb56e2444a200445af9b3240ca4727cb8071681c2bd5e969794bf37d7f271b29e7cea3a65cb614284d9b1c810da7777fd2348903093107598443dd9fb852337c0380958c7f80c9e328463977a02eb841e537cf70bcede3ec80513a8467497e01c4e3f01d4957c26abfe3cd13cb5727ce8f8f4a873cc53b2e743453a4e7d63419baa49dd6f42b73f1f38c92a9685b062136ef2df31fb31f21a575e630f0be4be290a666cb277773205d3196290930bb14b38482486041ba5e8749f68fca753da1a03d1ad204963aa3a20aa927f69248227f0e639ca9486d40c4542a1a64909af6481b87c9eb00691be923e2050d9e4843aa9ce9016ae4dcb5065ebf5bb565df7241c32a7d4a5a6995cea3750e973a593f5f195182efe56220bbbef0852e3cf7ad2654ec4414df111de1e2e1c36c688536769ba819a423c8d35a0b4cc71d0c1b0396ab8a603ece17c62964769670967783378502c5cffd98e2014a57547b6a9703c6ec1f7b6dc595222d2c4258bfc13bd9fd99b9e9573a2f4be1b40a09d76626fe65d76d7d05b2338dd7ac232bf19524600510c6bde983f5e4a473c6a681ff46425a0070c7b6c09e0aa3fc0d6b0e69d8bca83ad741641776a704f7729c4f9e0770d426ce85dd77cacc8b37463116f5da632fedca939bc8ad0588ddb779eccf593f7d602adc8cd00efea8601f2efc9c477541c44ca32003bcdd59ee25717178aff6bcb95f95ee947bf5408e361713c46091257f93d97fcb0ffa571ee70ca0ffc663146bc286c9505e57edaf3314c0707f6df974b90ea2c3892c8ea20f0e1b86c00975391e0e840cca246d0b055f4ffd53e4c2ff848e7f15ccfaa9d1785bcf7abb57fd2992ea92b32f74f916b7bade540406147298560c4867293104e3b1277ef104f7e29042e38d2c35e54d8a2a7fbce9e18be9f768468ce65a2b34c0d43abbff0302b18d9f7aca0d34d77bb6e55583ea196811655a22feb5212e8ba9d4ff43c0311f6e51f61c55f029eeb05f14dae58921fe8bd8146dee233e2f79a29eb79f074230829be1f41907b6e5cc4765cfab449f3e9f5fcfdfcdabf2dfd7d26ac0e78c6bd164a571c5b3965cd5192d97b3c7999288911bc31d9f532cb2595a66905e692ae1f4c4c626cb5ed5273ea7efa91a8d315e52e33b9e25e56813db87792b1f5fc333057b428571d6d9abc5dcdfaecf15cb0397415e97484a6e5756c48ff9ad55e8eec71b0069e946f050a74d1920da3dd9e723e5b63e4c8cbc99909632866611af71d2ef356c94ce7f5d3102747f3549c620a28a1342cee34ee578c5fa0b4b0665f99c76ea308ffc3fba66c2f25a59811b251431fe7e89034c59213a72010945b5cfd880943b25860bbe38739ef5421a82a6b87ea09b28324c639461e1ef6e1bd03b1c46352d40f258c45426e3f9406bc8988ceb6d81aa5fe3086ab92826dcbf5291480eb6998914a62d01b3e04c168d7b43ee82b32c0ed3c209e14b50869770827571500a1c415dc4aa14390755b3a0311cb69d86d01351b81cde303e18aa0e2ffb78463e225d658b564b343f8625042a9529c790607b15fa4cd36983c69f57c26120733ccd99da61ee7c2eb5b587f2ad135c2c2e0584f1f10de5b15c3ca30a628c1a85ada8392671aa8a6e7cc3fed3e5a75b401e9fb062a09d2ae054716c670630ec4978e8cc7ed2525299476f155331ec7c2cfba4eb4dca2ff2da7e83de6009122d424c75f600c577cb6b90ea1347cd4736829565a583f0bf2fe95658ce0cd1261a0536cbbfaecff56361da686598afa7ea17fe8a73f4d9b1791ba574cb889d5e8ff17019d4ec81ce295c84294d10ca3433bfb1096a15333add533f80c232c4fa652971772f5126d0aad93c808ddb566ca2dbf4a56f5347e1ff7a740122b4776bbdc42aa5d832aaab15b67555a3c9dae76b795c9a0b94d0a84cf36ed6141e9a103e61581602f448c13d7987016898c93bf1039db597d2a2e8865b90eea9cfbb8155b5ae518ce3cba535a23d5d3b86c5218c4df11b82d317cfea75beb129d8181ba87a4ebb9f6467e71244a5ff63561d4a9c87678d2abc0cb6391c04ada0c0d2d354b199df61676b18fb6383bb5d182cbffd8a8b04c91ba8ab7596712e0ec075ca3ca69250a0082a3d156ba47e0bd8105ab936496e1578860e4ecb933858ef0ad8dc85043bb1c28bdbf0f4f89f6a9f030781a58b758169c70a363b976a423a5e9721ca4a0ab710fbf68f25541197c957ac42e2578ffb3b6d7d291b321df0957d2c3d5b6a476cd96c09a0a082f686e176a45de1ad9587adf9a10315c65abb8af0b2af49c7ee06998ce74d2faed5c39a1894fdbd02441793cc409e1e486d179edf7ec3ba49832185d65dddbc8dd92ded8383bf58a6e672f1b5f4033f3d458d27d50b546fc6e1209a041e8bdf0f19ece6ae474c8ac1912f5ab182750c40ece85ae0e5e3e604c7e2e44d01c01474f06e36c2af49fc3e8b947a4338f45b47f709007e31ed75f51c5a4def100720c4e795c62ed7ccf7c77363015621671dfbd506caf68813995b9377ce9435964332029a77d9783cc6c18655c7f8e336162d74969cf3a0818980559739c2569470149feb5c436e4d74d90c37b5552ec0e3a8862e674c7c206328bf4618231b65ca672071652d8f3f5d56989b399155c436772eff05ead2d40fd6734959d3b7403b8f27c5d7066efa31f1b4fe2d40f5b600f061fbfee2a23ac361bc7d1010da7949108e478afad822c64a4070673685e56488a9f0a437e9e3b91daf480e7e3e543632d70859879b42327a1e760561a44c0cbd255c2947ff3dbfc01df11a21c70269f7805fb719f7c716c4f75c46b158cf0054476151d7341d5c8301054fce53d4be8a88e2cc7f8074bcfc39af5989224a20c9127a96372606b8859b8642839ee16f8bc59e5f8174c70715bf431fb7d9085fb72d3d5e1d48cfb80e05153235f81bb4544b2094b72f6ffef438d74d1d1b302417e11c8fcfb66e3554a2411a368eee660f4d7a0eaec8c9c603a7e808ff9c330a517c53b11e561222d3dc29694d4fda811c91cb1ecfa9cb8d266dd13f2c5487b7dde428a34b20f28ac2f41b8ad1c9f1ace16101e8104ecf82cfc7f3fd2a18cae10abfb2bcf339a95b64471e8611e353f18b0ee05b9cd9a8eaa1f8b54041c99f8c4eb4dc8333fbf02f06dd50b8744fd4da952cda99adf8cc63958e4319b93abc6af083fb961871f9aabb2cf23fc6899b6e88d2e8089e3d9f2ad4a79abf0c57ce83369d997103f8c42bb267a4a4b37aa1d2f07c71d34fd9f10ea16be1b2fa2f163cd743f4ade775e71f87cddb32d64b6fcf42573d284f045590e38aef07cb90b90a78a30a122ad3fe491f1a6befcaaeed334500d4bebf7ec6f10ab6077dc8dbee6893412809c8eb93c52611935f21b541c7178f62d03149d4b075bfc78619b31edee7dff36f888e04ca630b3d5ca3a72017a94734d857e8e428bbe09d0b48c8a051cf6b73a6c94631f514099a5ab3f345d55dc67d8f17cc7206c890095f5cd2cef2dffb042a29f9c69adf71b4c9bbc3e29b4175bd85e246e7c21ab86793f729e2ba233cd124bc2aed2c59d0b0a79404a0aff8aa2401b6bde10f5f2c49cafdd5b8ea4db1af7100eb843d8741fb4ee4d74228db387776ad6ade9d276cf3ecd470fb6b65fcb9b436fa6ac3b352e578339bf28609762c2fe0a7b32008d823a691988f7ab97322bf21f29dbd7184f0cad663d21a5b203708b8e85fd64cc2f2bf97f1e66613e37bc0261bd21a517d17804ac746805646021320ed20bb6f1a3e16805807128041ec3a19b0c5d99ab21d1d31c44760a803117a52534811fc97a5f108659015a36c52f9788baa76e37584f0f8d61e8e01469dbe4a481d8fb3a51ba267626a87391d0068a9f53e860c400d6ac3c9b158cc0fee357783469004b7b8de49a27900d4a82bc6f826c4e2ae2314d8aeadd299c51ea2d64479b6b309b5af7f97c81b1b57d79fce614432fa8048233f1d60a4fa38731194eadfd734f5aff752788fb751c0da8f10c6d653c0cf202cd4fed30646e12cd48e5c076db9a037a864b8f02f605d9613f85893db2b90bb555302261ebd840b6faba6909df731f3ebd7b6d10f0628909fd335708b027fea9923501b3228934af88e954dadd215e4315420d621ec4fef8d94ef60c07b59efd530d3a7b04429887c8738ec2a22b80098be04aa1dd1d228fc49b992a9e470e6b88351cb7f7e26f394f3d5a38dc5b9110a4b41c0732026536db8697119a5011614b748f617736ef5279ca288a3ec4fd9e8114a1c16e1450483e7c2d210f25090ffe75365735248128045e59b7a4e84e3bcdf717cf87390d717acca36f8bc68b3ccdbc07a73103f42f7b713a36d61427801e230ebf1ea97f311b8404a14d6916cac19e777eb017bc1a1c83df3f15288c84aca5f8e7633923c1da065d66eef5236982570151b7273e1eeacf260d5665ff9290610f59114431e0ee3ed92feaf4a90de13a5a88e8502d0a5e5b7c50a4d0b1315cebbc0960dedf3bb80dece07fecbb141028d30ef382713ce02b4cb5851be1963a54e4c61fe859bea0ccbfd42b87aa482bae0952efc3515d8210895aacd836b5d61cd0fef34d7fbbc168bf542c3854fd965cbab523ac893145c8b4f52f04fc4c4900c7d8443bebf06048fc9e00cb8f9085c8eed55d09b48d982cbe55595c15390ab67ebf7642b691a62161819e97c45b3fc92c28fa0057d83fb7f297b09fa4e6840a4d309cbc20362c4bad594491e9930ce3d729cbb7928acbc82021f6cf492215f6608feb1ecbbc1b12ec51c0c0e2f9908d19c26434de3332954956cbb8e43a5275f1e07a2c8ed41fb70645863c0b95724ee1c94a84fe5b9f1ffaa84e3c8329d347d8f579f152bb4c6f85a35173abfc9e51095c71c3a29d1e6f10954720d5871b611b8870a65007006707420c8aa2659b1fd3470f17c65a19a7b460b7abe2b75352a000fb7c1d778d285bf009c0000780319eca47ccd632280f520d2fb74e13eef7a4916bd49fbf0e2501e8472cb3db1e73ee31fec5a42dee2c2ed98a3056b0b60a13bcc7f4dcb7ea4f585c83d2f90ca233e63678af1bb3e78222b2b95d975575210b74651069b87063448d258edd23ebfc880c03a751b9da8e89e17b3e148c2f893a1fcf31ed40593531388b8490afa0172f1e3d75d1f3910665c9c615051a9e065649f5ad8a0cdfd6f005b353bf56dbff4d66cde16f1f8ac913cf8dc36874264e0285d6694fb9ea2df0979b40334a681e0315860785cd2b2f3fb87c0c960910e349a6d51870041d8e3f54eae5e91db56dd69cbb5ea248bfd2476696166229d29e2375e1331f3d0aef86ebc634ee5dfc122d4c9ecf8d76d477af5187dfa11b3a313757c30a76f4ba8f21fa82a18f2ca3c16889849bd0f6300280cd85d4586f4a802d29aefed60eab5ca0012da7640d3d3a71cd42e36a532c54a324f76172cb5ed1c91e47ea02cc3c798a6a1340118fbcfda658a0aab00a14b653ed60445c42be9b07f7512d5dfab1250d5c7f9e39c249bdc9958e7308c7822063c91ea571f89c0f4ad2e56bb0c92b3e3ad86d85f5f970a25cff98e3c3b0c26e68eebdb79dc4a92d100b112fcbf96a92b39a216bfd6d03a66b2e889d47d0d806a9052ca0551fc2f9f4e69d1305609a605eb73d4a4799cfb2590699aed5c7d89591cea10e102c070e5223c6d6161a56d94dc1c71d0a802f3d268fd179f899f44bc37d00b7a319db7690396c4b01db05765c80268b33399a0e1ce39e04fb79edd6142599f45bf1cb77683986244b1275146c6e4433b6b03047376c3c1fb91978484c564de6ceba20c5e9f04c0ecf2646bec3c229570e484c2427e9ee061b42cef84515770a81f12fac9310cb0fed37587a8270c5df51fa81d5b1a1dd376b8399cf17b19c4eb72ad78fc4ab773409877152117bf551bf949e5ed70a85091815757fbab7ed6c6d346860dd38b35ac96c591407ea91285d489687ea95296c38d589179016ba6554688d766c27b864d5ae6bc91a9dba67a5283834422dafd65002537ea9155bbc0533389dc197c2a99706328edb14183f888aa26e93f6ac644eeb3c0182c7b359279648f4369cf60dd2ce350ef06b9091bcfc4709f2938b85a3580e916133a868755b2f9d8b3b04dad4a505e3327073a62bf32f6f8bbeb6be7d599e86337be527620c188a1b20b1668897d59f696c9dc7879ced8b35ddc6833cfa003747005d54ffd7691654977af6795147b6ea265f4a8e0b37afcccd729b58e53fcab4b19479a306d37efc3c8006adbcaff04e14b0d9bfe113c3767f1da0116b67e7c2db1177724579414c17bcfbf3f71764a441d91e8d5ea0c2fc8c4acf5a5fd3a82c326781de9858e88224d4bce58d8694ed9231e109ebc53a4fad5b3953da5ce88c125388a2bb2e93462ebb9c8e92a6467d436e9e8d6f9637e1c30d2b487e6e893241ccffbca519ddcd0eb3853d767b5929e0670809638a6fedf4ce0117b66d7fd11b4732dd2d96f36ebd0ccc11ae5cc41a49e3723096be5070308c865a936427d054ab8b450213dcd48759e64dc82c73c3857607d471115b5bbbe29bd851fd706ad596c9c7883a177e396bf29abaa70846a867f1ea143fbf1592cbe48038247a7aeae7d49f7836bfd13adca48b4c8510ba4583639b7a7892e0a637eea660b7e2786ca45d4bc3a0bb9f1f91cabbe688cf576fedf38507c931c58bc370f424e3a1819e96cc1f2311a92183af774c5c98c78552e8b2e0ba285e2208a263313e14f6fb851800ce1704d950c84839fb5074f3341313737fc3f15ba1eda58c565618c74d96df684364c6a3f1f4779ae52e5fa2b0473e52f50f0196610f6ce0051cc84fd576a4136fdcc59bf86915ec1ad18907aac851f87ddca962bb2220350c3dbff8ed91be4de656360149237df9bb8664f1bb6c8a38ab6d67cd3d4812cdd86a5dd9d062b4bf1b8941167f0690b783b59d40242bc78f5db5c7083333048f9c1dc7ef5cf11f583ef2355f4ef242e6c3568c0e86c3bc965aea05550824b5be6d75fee33d2b18d45c999fcdf78dbb78771929844a1f6d3a3005b04f1f120767a020381f14835f49159f2b847b9ac57265ea94bdd96585b5eb6fe1db3ffa2370aa96c10cad7f9a294f3b62f6ff7c6b7e574dbc2ef12f2ee8a9eb3e73d9218c818efc5008a0969d244aab6a725eb756a70734bf96853a43843d5fb3bbfa5b96e119756d446242abc0f0d0860f10262ba7725c5c79d283196cf263fb88c074df1d925819f47685d83160198d1ffeea2be382beb7afc6cff3af9cee0d460778d7d73350cd634d0bbd7d6ca7645923488a36fa23c9b5ffa54264f38429f8fea0990669d39876dd27f0a7792be0682db72127e30fd2b19db896d90b0612cad879bcabe51a8e618cdca6cce3ed950104a2bed6eb447d67253c296d8715aef13775c90449bd39a86952b6ce0f1612f3aba844c40d4af0dfba56c2efcf56b03a02b86a612ce587e811689c8ada4398d3cb32c58ccb8d6a11a326373cdfdfc9fb8df0ff5792375af79483ded18223061451010100090ccb99f8d5f37fcb5f3164a836f3b6501b2da500f097dcc31465e8d175aa7a8268f1d092072f70b1add80aa5799912404cd181be2af03a87c998f16a49c2982a5235feedaba43cf8045f609ed1c836597aead2b4aa61d81122c057594eef7a6813fedf79a4d6c6d4c55a6cf1775d463e944a23965f2d8d41b4e655c3986c82c12b73478c703abcec6690cb1a41be120b3d0e1a2c8d70621f727413102c41fe398e1e9fba5e6e4060c5b23fa9eb3dbd5674fb8c6653816e32c00796a4dee93df99d1ac53abf33e0973494b929439fc8a1b95aecbb51db86093e6b73e6b9b592337e757abac599c3ec6b94bfa228415d686b00c461de0d56708764a10b1f0dd528047db5b4b39c26726ff8c0888a7b73000027e702286a42a429328e9dc525444c2a4eb08bcd97aa43cff69073da7b3d1b5e4b2828759c913dfc780276f88e7b2f94b175652444c1bcf87fc308133003748c3a775e6730aef680020a666e18c79ee188f243e89c750680aa0843ac35cb26839007d7da146db155ac52d6da97b9b30268748f4f72a2101deb1026166b7553353cd67c2838f0ce8b36c42f94867f9dc0366dbf83174dafa63d82fd611ee66114fcffa30f2ef4d9a947fb6885328787b5b11e0b44d7d021ac461d67a5ff684f9365424b9cbde446f9fbd15f73d7026541de7dca4d9c9d10dda8ba2b7e0ad9b85cce2f828069d41fb6780ca40eb9e67ba0610f20557dea92a560b1dbe2c8d84e5c486a62e99156e7ee14b8eb90ef468069fca42159e45f7810149302755a061ca79e18665127b9c6658af5713540694ee8e08853226604c3ec1cc0997ed462d7e7740fec46c3775ae621df9c34deb0c3629413f7a119400c8cd4a4e4e51dfd9e45bfd619e910efb1001dc6319dc52618a16c4151936207731c133c9affe671a85211bfe769965ac7089437f5a2e7379867e39128547783cd1a9207e187d450c5c992ee93de43d79135b6eb95ef8b721912d85b56ae6c3cfdf8d923c005576edb644f16aa01376ae2c270b029d9213660ea5e632b55e58d5c70d3885212ea8561691946e9c69e5a17a93a7b748de0927d488ca6cb2754eaa3ad4d41898cf45048deb58c0ddfd5ac5989e1330451788fb1fec9f8d3050d712782386495fc815ce7055fb29fba1e126b537026f88c4e794188d0167215b86396ca096b506970affc422c693b7e7e1cd612b9111a288323b8178ee6b638189ad170dca81afdfa28cb1f569de7e27ca08297c0097367197a5405eb1fc860ddf35b720b85ae3a8c7dcfc30cc95d7aff758ef85a5e49840f418b0ff29a30541a9cb06cc2c8d9cbf2c7e591d241a3a59426eb23d95e56e0ab8d14b63e86cb82fc89cc367a75ca032ede4b09b8b7fb6f2da797de81dd23a01ba8c58c994f8127f810687b221a2e3c4d7adc59ce164a5354ca386a40d1342ae74d3e58a24ffc08137aadf3bea8383c9526efe7dd009924081d69b65c125b23e02c44f1bac35cc11ef9e45672969fbabd514302edfdbf77bba5bf34a7d7109c547d68b3a85781521b28d572a4da5d7940566db3c84fbcf1ec0320e70228960754ef5ffb67fbbe6b80a49de7eda6dd700a867ce13e825eb2be62cb09b6955f6c9edaacfe44923ce43cad09edae8f723d27b32b1d0355f042f06a8172762387ca12e6d5971883c436b3135c1b61b0d85a9ee1d70595b7f174450ddd32c0c62470ce9f97be5b94de731c1c4a69e019426aefca0744a84ed31a4a84aa9d0bdd689bb8443d0e38a89e83066279428152433d4ef1449992318bd9289f34a20540c1d86fdd700e6b359fd777488e975c24f0ede490d4ab45854418b62befd0c285fb2beaf1acac0841aade59300a38e9b835ca3a4d07c40c3b26b41fa4135436d8ca27845ce70945b2ea642d0ea0a6c53571d87b0ecd207983404df33eb765d68897828c458e552372fa294ecef7d744d2b7575b483ef79ad7f93f17c75686e689e4d55346a20fbf2bc14b756fa8fab8862b76c525a783e4f6d90f084e12e7f1283cdcf6d48243ca32d60896b8cacd193dbce40805a63519c5446fd68e7e4f2a3c71118a39467fddb7b4171b4f95096d97b79b14f890217dc2bcaaf36409e203ccf66fadd0abc307e1fecb893ec1aed2829a58250c81156790bf0d65dbf65b04aaf8bc0891a36d36db4274068ed9c2ccc81dfdad0b601a85c7e0001ffef40daa4d10a5428c381691da5536213a3e6f0528af17cbbc79178304578cafed0d15fb1ca9a3e56c06acd98fed217a38f5b37f6886f942bdcb831677369f97ba8075e54fef147c777d8ec54bb5d9e510b093bf7d9151fce5ef3f2f6a2c8201419db7f5110fc5528f913d9c2276c09c380ed1ca30ac5278ec1dad67c81e4bf66ecf39fb52eac21544b491ddbfdde3a76d44617f148a08c2acd9eabd10db2fc8734113b8236273bc465f5f65a55cfd710741c0e1553dbfc800d5fc193ceb6189ad91c03dc5e0f8d0508c18deee77daacaf70899febebd75c9dad1429d576ddebe58ccecf2f9d2331df36065e611627ea0b827724c6bf5cd64f79b1b3128753ddbafb401b8c0acf3d44fe1dc0d2f9334fc611e7b0a9244ee6a69e485a5b29a7914bcc9106025baaf6d504a9f322640d252a27e183c1192748bfa159c799ba50e1f76521e99e753ffc5f332d341d7af2ea7ea32ab16c25a144605fb8f7cbfdaaa0a0712a99a7f22c6d99f7c981bfd3beb2a430ac50ba9102f96e150eea68c3c505f4be2d172542c328834f621f1ab47148b3304fffcf7c8730a58c8e93511ee939ccbff82cc893b8f160425155a5e36f51409c35f0b9c87f037f6b7946173a27ec71b2b36f94db7ffe53d12eb05a31484e966db3da9a1d565169d6413b08790dde99ae8e27f34ab8bde01d8da80af83911100af98ca2820694196347452cba40f230bdae078cd420f41d9aa33b2b92c36e5edd800f29ea27eb636686cb1472c200d1306679a4cdb0a189204ea2b7f17729db4a5040dade8d98acbd3c8b08f4babead4a0359108321cac4cdc16c4aa628fe7470c6bb4f60176e20bccda8aa09fa6a2de1d77c888b37c7945372651539caac5218d481ceb47ed0892627353fd1fa0debe9fc6004711e67c00e23f3577073dbed7f15c2836ece36e389e85d3af0fc5230852a771b61944d20f733b3d43aeef360c330b6405e77c757030ac28ca3f3cced7a712c27b6dc42e2e06cd0aea83db98189c1e12aee4e7fd59147ed8e22835c1e2dfe3682234a6ab33ff87af8424206076210fdb52973389407ebe35b6b821ac56bef8053803456ffbf621ccb380390ec3b577486bf7b1829a483a4bcb4d38d00925500c9e01367ecacf0113c12b089ae703ea376d753978eb9f6b28a742f3908becc18a4a9681d5462587f13eeb9bda79ec83b3903f33694eade8773d5c05cf8bb358c412e10b6d46ade064305e106cdad299bea3bc1ab0592843d41de5044c7349aaad3acac30645e00828ff434dd21fc0a617d719dda4d49c6f63ca2a8f46ef3ab3c26961ae4b5153b3383bbf0c2b5de5b43f75b9b08df2dcb688e13adf9a40649a1ea192401da01a88c206489e5c0a3c8685cc6fbb1c49e4d37e8c539f86a3cfc1f0250840bedbb21251885d52c1f5f4f2b769a988c6ddde5586aa2f5023f49132e58621c3475b3854b717209b7d86a38069a58ed92cb9f465be17e3a358899159a7d4fdd5c1d362cd7ae2d2c00805f7c5d7308c2446f1256b4bbda3d532bd0a311e2fa86675fc294d9477a59cd494a2f0dd14d465d835a95b3f542b9469a0b4f3b27094252da3d826f409cef64fb0715e1320ff565ab7adc377bb2ea0a405ecd4a2cd2215f75c643f0b7abd2b8da42f4c16715aa5802107ccbfc23e30bec56a5cf84780f7a3266540831e5695fcad8742f750eb2358ae0eeca93c6b890c001580c58fe566b29e1436f6933178463a6cded4beba775c1e9224560dcd0c037d12cdb647c89efe4a3b2fc9f63f8e7d7977a8dd92f8c971b8ec29e5497faf313bd11f26453daefeb63225c9884af308b9725449e275b2ccd3fe9cf82c311baec10b5948c3c0ebe6a45ca618527bc7fcee3ce2ed553c300be6ac4e6712550189324ff0d223d79f69b0b685f4809caca7237e8d249f504e1d0518b7bfa395e32a7e554007bc9f3a3a25440ace13529d351d7c7eb7ff71357b89bb61c3291facfdbabeb8eeb3c34da6ea5e2dc740e78f4ca1efb672332afb9ed718426af6388d7ef4010e9cd41de6d8dd0926587cb2a40b667f2902ad3f6df45567a4f2a32aaddcfc6d31e62b9855fd9c5d851ed518cfa532fbd7e9d521c5aa0e0f2202a81cb1d18badb2b0083597afb4f5b7adb10b87d7c3bebcb7dec01050357e8543790e1e477dd777b291df9fb2716aa848d6241c324c0f6afa8e86146e215adf0137aab5bb9a64a54f1bbc91939138e9746177d01825544565ab7ddecab2026ac3350570623df14d531ab9f80de48278dd0649bb03fc8b8ffd3c6a8244963d0c2002c0068673398bb491eb056fe0a1e4c7a9f68813cf7ff5d0197927b484dd3485306a0b53984226e875754cf559a897136bd4f2c8f1971ed936be51104be3ee1a0295ad1665ae2776fac991ac1e3fcdef4b2bd70fd8e6bffe58efcea04166ba9b72f7560142a5c51ebd3b1a985de6196d36bd90189118c285b9577c8b84f595aecd905af1ffd935259614a16c884020489947ba2536d0b932b34b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
