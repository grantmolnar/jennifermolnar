<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1691e345e1ce28b11c4e11beb2689885e78cc3921dfe00180801e1be71ca509f55df45d72d10194b79347dfae3e0d55c804105e787197971343eeab9db1f739dd6be211c409bd6d0d41828c23417f6332bfd91b28d8dc3bbc357c70e4fd4f5e9a445d6b800c7b79b2fbff828c6f041224ffdd5f02249c52a82f372ab5cfa428175d194ae3549c212eb32d140edde29f11885438498957833fe3dce7b8cf08b3ab1aa8781811d6f60884150f2353b4a300e52aa6afc3c451c69b576941fd86d8731d078e4da4ae0a0dd47242f93d9100029013ed5caf510cccfe4193030bfbf53ff36989e520edb09bca320d680c1a679c0b2927b6d2a11e2ef37b061f1a91d2cbacd01e9755925ea3815bec26801bc2d932899fa49864b25037e7b623b6bc53c7527db99eea8ce9ea63c5cdc56cb12e3cef0043e30a1e5745c36dc777d5e677de2f3791bbcd4261042d879f0f38184db54f11b0ac69c8bcf5ab6c8e5798394ba65be76d6ee9fcafd0bd0ddfc6b6af362cf51bc7b5fd37b3cf25bd03884b79d4a5d40b6fde183654e2e560e2c3decf389d256a7b1635ca63eb625b4134ac7b844755992dc32266a45ca1d90f769b02de498b59331d0c9561512b79f521c811a2c62094a1123112878b2ea6b1b7292cbe7e0d06ace340819fe6e14e1965bbacd530af93c529b7d11764df867c8c172f5ba835e7b199235bf1dea8e4d6b1badfd7d280a2332915864ed56d9ce15034b0fadbf1a85668be83bda17ea85542d917022c56e36b797f594f5167eec7594d5e79978201985fcf6d525c3f785668747c5fafa96876ea4100c2629cc987678d4ca21f67d00d94f2a08fe02adc45e255e0feb2a0bad75c461dc2ff0a22be8fe2c49a8b4021b97b3f8f11b8dc3c6bcd4d21adcdadca86ed3453767de5656fac5304ebfe5911304bfee3c479bf5066ab93a7a3bf79108cbff36bf19ddc4da413607aadec6cd68be446490a96f8eb963ec97b0a3b8b6734f7b682599ad10e4c7d3776262ddaa0dfe6d07fdc9b75700f9693c389c5ef83771cfb2265bc9ef4a7568045af8586ed036357448f737a9993213dbb9049a760032b5f51061eaa717b5126bd9f8b451af4593a5735f48b7b0bc7e63edf79dca840c6ed0e785b91df0a9ff27e04460f98222cf53ebbbee2d38664a35213a26dec9ad16addceeef494ffd09b5bccdcb4a0e62d930c4331aeaf718b7807969859ba43f208790939f95af2ec2b84551b50d29d6d844be7a3b629d822b9f63764e6d8232f7097e55a675de5225db429c73923b0ecb576abf850e285823ffbb390ae96af1a367014e3803dbd70b3d47ba425018176ac0f8d46da3da48df1e127ca6a2d24a8569915fce8da6a78edbb3e0ebf50ffe35354c4b9f0f2d81863d28875b1b5dbeeff94c3fc60eb987f7a07cb244aefa60c5d8b845b8f598a50abd3835fba1ca32ad6d28d0f342cbc377d086ade69b7c47b39e2de50cce71d0ef75c5672b13d0180c20e3fa771ed1cee7b1e8963167f203019217c6a206f34f982e012a043720788b30d4015bceaa8f170a2a8463ae19f3c4e9a7f0c58a0a5d1307f2982647dd5bc5df341899f82e36dc85179be8352202629b76ad5169b653cad0a047b8552d1ee898e6784016988e70ccf265705554761aed5e76fba15a2915300a9da3957da1bfca5617ad704f9084c2ba5ab879071fdab2ce8fb195146033197c4c7c1e8d1d44f5c24f53df4fd20f906bc680b357b8adc8b23f496e6f42d75a1b029dc0c92c962fa104c5b304099196a44e0c2eb9bb05ec1c8fbe4c824cfca5470404a09a98da1e3b42b2cdec428157cfef018befb0497cdbed5fdca9aa399a38ee25da85c25a4b2710071cad0abd97ca1c64d9214634cddafd33f55106b66124fdea5b2a209350b662f47b863717aa9de7b6855696adc4ada2ac95ef80322e24d58997bde9c0fa10a330138d034fa5131756e7f03a10531d367bdd0d19a98d9e0171c07e14ad40829c454f474114966bb7f815cb33304239a01acecf7efdc02efc56876c73dd8848a986bcdb9fa6c640f09af7ee7b9ff983054e0ca6eab915f9c583eac9b20b07cda7a159757550f3725d233022f5311600d1d6c7ac8daf6f0230d74cd88bd6fddf42eac21644e708d41ba6946849912fc140ae6bda6106c60e2af64c7abe6e9f5a1067246f646ff1f50cec5e65ee14daf32aaa9b9cf4a11b470787ae5931fc5890ec8bbbd99d3c8c8b0c22b14c1e1c2deba4b883ec447937e214be90c3b02ec9c194ba78550e25b7ca80daa3c34e231e5d4f91a12783afd07af020f08031b52f54f40de81393fe15a193e5bc195371f0511820de4ab06f355902a2660eee37b067fa7365081e757e6ffa0f7871c9b5249a4262946009706b55436d58df0730b2eca0b54fd33198813c36ef26820f74a7c5ea3b71bea7c6d8d7a9005d58e4f4cd8ad3972e6f86234267fbcc2fb99991e1946a98c225d945c8badb78adb5f84ddd89c7949ebb65178af06db52f5c82d405001b84bfc90c154ee7db571129f5d43eb2600fced7a35c8cd49889f6ab22caa964d60011b19bcabb0e27d94cf3d99c33c927203d37f7959e94dbf3371cca77670db9e96414b5e18279df80a89330c28dddacd9f118f42cb0a27d85c769cdc697b1653b2fd2aaeee0fe05c39fe03d26c9f142e319a25ec3ded7a37ccc40192b953945d71150663f88c5fd0c0d7032c3e40ae7cc7080741ee9e46816f4824acd4609a720282cb3b831e56e5003b95398e20d69d510d18ac4271ebac0c9a9b6abd986d2398bc40e603b04a3a02b87f97c4119b5333aabecfabc9e0a3a7048ed4b9669d3268983f85721098fc4f59ce33228e28c17d320a8c005fc03674b4b0c4fd87b507efcdf01ff68a10e6455ecbcfbd1aaff8ca456c62baf260de7f5cade6f2cf5853ee265ab84df63e68a6da2eaa67a7d813bbc919a067be27e980d80001592d1686742dcea53e36581f0161f36c6061ee3eb007ff85ba1a458d09eb7a572ad04b01419f5495bbefb472babd3b77cc0ab5d39c3a19b818b124c5cb8ed9eb846b8bf997375472c12ab74b299d609a2b7809543e58ab52107c2c2be0b70f3b7caad0d65acbcf7282c4a444480785a4ae4b8ef020b8847f0c21d4484ae2d580e7912f13e0d2737be38215d68e97b6f52178f24e46f8e82a8d27c8addd9b8e7f0c6f187db57e823bdad15e021fb8c22a67870fb55ba69f3dc8e706bdcbdf96de4119e8a62744e983d6c0b588374e6e7860aeaecab2c443a4128ae19000c5b7243362d431b9739f64358858fccd5412c4a02e43e0473270303a395716a2fc836ef75622394f219f2308d0d026ee82357fdbb3d5de1fe3332b51faf2a52eb7a19d02c83f4edb309aef9f9c3cb57ee2d6f30c40ccaa693a4d09210b464dc49dd49edb57e0b0967aa1b967eff422b1dd611882d62525c74b30cebfd72cb157b3c015ecc654497287701184de77568a5879f4d18e815df716fe07441b4141b40cff163d216ae7da495958f3ff70259a98274958d20a4574bcf372f3b5751e0ed5838c5978bc9e36f69e1556ce8651fb415c16896d62c31e64fa292005796cd35c612f340fe704b91f828027e09e93b57964c84fa9d8485e7f63dcb2f83cdeca803b093383600d0c9737ddb9294609c8e8432832f45a471b11bc8498759f0705f7e3b93a2bda3a091affc5b5a795ba80ff28bfa12534cd73922c8b76ed717e76b5ae2de5ddc8eb4dd6c6daf55f10fc43df8379d086ffadc4f03de2e40b7d1348cd246fb3c2f206e60c1db086aea10ac26ef7f0164b83c15a669abd247536a4dbffa0ec24373799a8ddf17811d0df98d84cec2c0165ddf7d5fcfdb406a7a59d84420b314d75451bdacecc98ba13909afaf8d0be0335083ab2b1112d1d47debc745ce5e6145d0133b1e26b299fb29b3f1ee1b7c789b2292c12e3d8909b75c120077dbc2f4cc58392788c112229d797b4d59778abdc879f91a2b6f741a0e005945c1d72c6dcf87528a0b707e34b4e84cd9f70c62017bbb9f9f6e5542eff46ae8439abaaf02f8a2757f19400586844f3e82b320ec4db893198c84bb12c821739d3966a06d4d61471f6c7cf6eed2e45250761c50aadda024e26b2efcc9e8a1b578b6435b053161546de81a423144229824baf9e1487f6a096d4da9eaaa6381900d61d445af801abc19c02f19f525ef0a93c17290982fd078acc743cd046fd4680367ec2fc3a98bf185d7ef72c5a2e1c787616eda1e9acb2460f9d8eca7f457c4e468343f842e2e651fac6f96099a1327c67916afc892318302dd14e9dd4508975f59d9e84d8b42644a4596e98bf736024a9200a2c933b9439ed3c50e9456ec4554c50f043aeb52fd45c062cb1e1e119054a81fc8093fa9a063e67fbd96b74edc16a19ccf3bb8326990d0da0bc0c4f377a81e54c3befd2a638e19479d2a9dfe0fb489fef4d6af4d42c1a4c545b6b0d0419bca3dfb4eecd462095d360a8d8e9a0fd87780ac0ce1176a8a1c140cef66fa2ccecd15fe5ec30e5158e49c6492dad83649b33717cc2892b05e598d6faab76695c1f676f00b5db8e1b8e5437443c16f97ab0bd2c447a45cb07f57c73ce0141e94d7291d207673b0d4c242be298626452eb6fed352666cd5e46914aa43fa6a48242b59705514a2346c007e8d01e5ffa99dd0d7f19d3d01dce17cec92c5481e3e433c2d828ef6d951e0cb53b2806b1dd59074181774a9f18b781801b6224cf5b88232afab26e47eb6e83c1e50c7bf59d89d01d83cf5fc621ee31627e9a77b8157f52453613e678313f6ac634893fa5fd9cf927848ef4d9e2614bb0bce913b8c9799c791ae1aa70b247ae7df866413f08cdaa6f77f984e379bc59c9e5cf66828c367da9d6edee8cb3ffe31f724db646059570d59d2dfb01f0d17c6d7fddc11e43483e3f4666a4c1daa93deb907a2332954cb5e97e9a2d0638345afbab2225b95ee03c3e294853e77c2609df85033838730982053434457365d17aef5a78330ddaaa6d2957ff63250c8fa96d2a597cf988041bec94545b98ad363bec35c3eb2611ae30d39bf36f0b2bdcb91475e68e2423a37d426613c3a1099a13a1545d058a7ececdde699c2befcb1c4074fb97f84adc38b33dc17fc527c01a8693fd7aaa07c9d8b2a18ce77608d4fb8ca2f0963bfef5b9ea97376f4afb588f3f676092a1aee0476f27ed958157ea7c97a8347447e16acb25fb289dc16e9ffcb453f8f3086e352666acae73d4cfa87dac2fc737236cc529a853cf577e7be82d0c5c01286128dd8be5c4b96c5dd4d8c420101f247842760b4c86f6deb0119b1ae747c4d0c3026b78fdbe87ee29222246d98c89ccfcd78861f011ebaee17325c24438eab5fffd5c8303ccdb2cfd2a4884a95ca734c92ed7ab5e1280b137e79101acd749aa3917b045ea7ced1b0e39b57ea249c8971dfc9c0dccad3ceeac1d9e2b4a1b8a467358e6984a98de576bee0f831ee3733b5bdae7bb89a5506268b1fe813140e6c51570cc4473fa52bb5d981f5864bb684506ac1ac9e028d591b573f8ca3ad95a5047e9e01f7f70fdad8c54ab6dd29df09cc9b764257e6b50241d7048e74262f4055345bd2a4e1688a42bb4b71130e706148adf54ca3c005060ddf8684a40d3b542e784c39d71e4d04347553012024918ce73ab65b8c8440004f9758def629c8cd76dd57eb8adaf928b40912f3aaec6116ca6be77788d740468ca11256e8992a51869b75250f439e9eb4d894387a011a71497fd66deac963cb4242e85438936c9d7111d165e0da5f1a31c4ed6352cdf770c28bc6191ec6c4de04d9138e9479cdd37d098c13d7e3a45deaa3070c6762d012d75e2dd0dde678a7dd2d7a40cd5c997c553076597fe1e07df2ddf7ab7d4ba04ac08455d84ec1b578b9ce780b34659e4553e5f5075fb4eb5c4e3637fd7893d3635c34650f2bbfc84c656fca4b74531b2b9195e18d380459ad596b1aa9cb8f479db8629f6ca1d75e3cff81ee1a23d8248bddcfec6bc68c8930230eaa2f7db490c1e032cbdcacb3f0bd86e09feb5244c7859443bf000fe88b69523713424eee7c8a7e5c9901772eb312ab9da8e4ee971a5b3f65f6f52018fac63c6a769ea10c696dd1a9f2f1dd0f41ac7900ae8062c500341ab776e72608e85bba55df7b642c8609992789f49ced395d3f126b69b6656a00da95d050af1ed02cd2405df9644e4dfddecf361c5d3b6d43e0551f0fafb43334cac6406e9ddaa2da44ec732ce0dc80ccb27c7e5b1ff261dbe9c5496f1aad24b12cca8998378e529046a853beb9a883847d8566aae93c56db9ff6fea21d25df83355de2d1ef538407129929702b799405e05a45bae05025b897f89793589d4f8df3088b25c929e89312b462db0171df6d8511c908337c3927363fc7d5e965f0489283631544d4ed446ca5d099b519a4f4a5d0b58ee09b20d2d8b6e6b1a81291c33e62de2f36b3d37839ced246aad6c578d78d587e89917bac1716943d7c633758ae8b3be08dfdd6e0ae257f0b305c293d4df09312a5a6c14e8ae6b1c1818a60f4232471c6b25170fba0996c74c647436cbd706aaadbfc2a54a556b968496735f14517b3436da8bc40d7222200bc9cbaa791506fa4463870eb7778761c0b53ad16892837ef0c7c914b65e8e144a3dd2e4178078f0ddd8e2d2bc8b4ac888114a19d66c3815d63987d7747ece2db8b05f6a4fcac33759ee6657eb17c44e6a273ddbb612c71c4d584821651e8675a404845dbe2f2647a1146c120a0772e726b4e77f07dd8f34ae76aadcc1f8e903125801e8f89e2486e289bdc364784e179fe26df977bb28e101750aa30044c9c75477c010993d7844eb5d999499210ae33776b868ee8b5501906d1d1c0d160ea1068655b80c9e59c554a3cdcd863749eba43678db9830ed14814f7a287f451ccd4c1445fcdc3783b21927b6658ac60f9d4d5ebd03ed66dbcba5b09354ac25ab549b933d85096c5f42352cd521a03fe3d4694ab4ad6c44e0029deec349bdacf2a998116d08827d845a1c619e7493df5c06c0c31b7a0f1286c558df42e6d083618893e4b878f802e13520df071d8fa751fec40a899e8d8e1fc878386c3d8452af757162cfca91984af55053207851e4ab08637d5fc80953e99d008f91a74e8ca21ef1c2d2ec5299a91c5f596321bd3a5be6dbbea66d8df5dd6c68cf4753441c1259e717de142a7dc360b869e985933f36ad4896c7438a99852f4cae9c191afff3042bc4657d05148f16f6623219274e798744d9cdf36e2abe9b75ec793d77c9ff1d209b732afe6885bdf8666acd29fb5b88a40bc26c086350019eaf2ef1360e43f29af1556e48ed69c5a6a4c12d1c7e18ac136667de96b675f96c92072edf53a06c7c41d403395900e33e3970f2e78ffc7364da3d5e6496728434950e0d08f20de49b49976ae4328459fa1ce9a37d8dd5cc0540eabbdb3b4ceb1b9d6b559e07b86097d5422f9fabf5e1e4545cd4493fd057ea9fa309cf91634b7bd372190f91b2181203649b1631f14ebd7542d8cc6a794dab5372088cfaa40d0d848d88d7cbf0d4f7b8ebdcdcaa187dc1732e18e3a68ff82cf318ef4f460ea65979e288f37f3162bdd0179d47bd92cbbbb98532a89df77bd0d0c0648cebcb800974db1f8e0549a76bf30c97b32c8bb42635264b27673a3d1e86754febe410dc02e32f1786c2e049b0a507bf6eeee44258c59a3a16c7ffbff403b1e9a51e5ff1cfde4addf6ef88364d57833dd5624506645b76747f13a110aabecc5985f9d499e19d23453f42f55df3901c588d0b874f54def5c1ab27050445fab1e3b13373a61898a138ed644db21e128a7363566ced3490fbcbd55a8ea5f82c562bc4873c62ee8996897106b3493efebd166b27e8c33af3e25964fc79412731b8d56871b810294dc9223de3279ed14dbc29fdb50c077a4dda0a062175691fdb5b7f62b9e8ba27c2d23466ad47840dfe0572fd5076b980a93fe2ce736cab45d64c6b168be943acbf1ae63f94db9f1975ab6493bdfb77055c77126bf450d66fca2439173070564a507232b0237c874962bb9598584dace6a1d40bc221c247c14eb703a4446ec4eb7ccf402dc83044a2336c0525cabc31f3df5364ebedf9854b41bb506ab0aa876abc9886c60c0bcbcc84b575b1563da11ff48bbb0d49a9660163792698e6673ff7469e438bda43f758c9edfbd0a69d4d08a0c59e01148607712b4c1465c173f62c1933a7a7a7d282bfa758899706afd837e1d30ffdd27a7193f5ea265c56d154bd1a7d3be30c87370b60090d62e5f27ae0b36aaf0391f7f2173271a6b3589873f3fbc6270c98657c159d63c473c58309a98e4f16943057b78858f9eac72100eeb82fb49e78140dd93ea41ff857e6901f42231e3d5cbf815722ef74ea35533c0170d99fdb97d78adc201e9e941d72196ee0b109db029b4814399c0b3287553f628b23c5063e36af1c28375d7accd6d763c5c5fa237ea409f20246f24f65182861f768fa6e48c48f63274c0ab0eb88053606e60fd296b705d240484e0d6e292e0f5651f4436522b7be8fd019ced3232478ef0b6c67b2a0e3c8906a689277774f41da3395fb3c3bea0c09dcb0e30d6e757729caee79c93e23f2cc50cf3012f7fd95475068232d4ae26656c4642cd910a9d8b891b07edd72dcdcf3d6434018f56732db7fa1719d45f013aa443910cc2c77344e765e5b3af04a0ab5a8fcef69ee35af8a5c5853474e56abb5ded7942d3439c0dead4f99bcf2e50bb3a75c54c5ee6443ee4fa30dbce7d1c10ef75803729a10ff8ae2dc6a7e1ae9b309538f1ded4a5cff428a4526ab642b3fc7f374971097151681bdba31f09e02d5c5329bb98c20fc0be03c6a6a352b126459771ad5dab64e6df94a3413d48aed9bc1369967c15aad9d7d6b84f28f80505324f6514750c1374bc21ca589940f1da5364b808b84df4ed7d6bed39d15fe06c0ba24104eee42e940066fd78aaf02f8bf99cd04feb83ffb90173faef28631e62f333dd99e52d4adb934b2f7a2969bd06202811f66b3255d4ffb7d090f041e1f8b2ba0ff3930c6cc5b93e07168dbef3d0fd4c17af6f36dba7e97ccd1e46ffbadd7bccf621f13940b10cc0a59816f11b554f25a8b3276567b9ca96fe80b0bc437baf6eda23e8cfa3a1820795ab7f0e36e1d58426dc55959a9678587f6ddcfaaa0ba87d4280b0f6b8064bccb343bd93b24b9343a7bba9da87fe283540dbb18475fc7e1c05054e8f7da8c5d5a2af9e1ad51e972443bf97d8478fd164393f93b9371ae2e648a2863ef0f49821fe9627d476e8df055b5a9070008cc9d5bafc35ae01e8bca37dd37eb83057fe0fc33f2d9b7c324176b329cbba5d5e8661b893fa84762f1ab767eeaf0ed2b585497e76eda08bf79a7962992c3b945b4f0b51eabb1b6ce917771e7ffd1bcec5546e6b2b18eaedb24137c97732f33c292de949e6a3694b2df1e13348e36c6ed77ecb9e93edfb91e530fb993ad6363bd1118ea8593201d17f3dc02ea0a6e5fb4affe036d720759b840b61b66d8c29645b556880fb870d2d085d891354e549a6516675f90cc73e95e2502cc235c98d35f910101b3dff4be6aab8501422dc5d655d32f88ed386264f1c0273281228cb0bdee934b99aee2d9ce2c0731c375c02a72aae2f6a078a0d3fc0d5a14ea3615f1b3b81f5375ba5605009fffcee50de24e62b162354da51d3b11a7a4c59b77c21fbce3948914753f92ae5dcd090efb37504bf33ef62b89a69f7c1746ce9e490b984d3bdf186796eddc5704f4e74eb1c09224edab6151a02ea2bc790db656dfd05c1ec0a91769885a28a06d4ed7b76b2fb4bb7c5791622e91294ccbf9d44c9b802c2107d5affb877473f674860f3e5b52b86c311867768eabd6266ac839746b34f00333c328ac427052444050c3c32ce4710d1f3e7bb4031545b63a9b0526e873dfd5567445a840257971be5bb5a758a5f7c90bf4c43f552bfdd2fd0ec8d52fdfd79f48fbf62d907023052459425cb1f66b18c3c24828e3429a3b4010d46914f39800dd35366cf9a41b6e902fd98007762e1cfb447ae811832b22bb49a1f320d1ca9e72281f220f54fbd691c00ef1eb2c70120766d73c5cc95170f2029242b0d17c674dd84cabc96153477db2b12b32ebd764042116a3abd3be1c2e662ab81763a491947651ab36156e6c6d0c3904225488e3ad8cc73c42c556fff4d6091d9e7202c8bd0b42084986a0c51804b9a3721bbcbbcc5414fc40b844c68feaaf87aa73dc658fd97f9226ed094b498a565b656e776de3439e9e06789db3cb178faee942771e3afd5d97b8bd8c8b17d6b36f11bcdb41d8f6700fa303dd8266e5647da935229eb0a8eb3f19a75ff1d051250bf624b4c400758818d5d5b723d0058e83cf7bda86ac052a4dff9b9bd6977f8144cbd17dcd5c240a31a1c14bdc1d7f955745271a081de40ad35d6c7145446451413f34e289ecbe2ce8506a8b450233b7d94f84f5231097f7ec5bcc5e2b67a36fec87307a14445c6bc1b30130ae353a81ee2e9d6643c228e763f3b88db613d19c89b96931d8b0eaabc6dc141322ca95a292dd6f563380e34015e47d4e3ff9e72c8b1f5d31f00d9aba91848ce57081e61428017166583cfd189b814445ed8f5429176ba337ae1f7bd871349cc72f790a52887afb572b58d4a362f9d972518144f5595bb55fb77c6291cbc33e655e208d0fdcba49fdc1ba6304e6776f8f08bd3d0fa0efaec20e1dfbbce4525faff13b5469a1772e45f64065a98a0c40543150ef79debcabcf1d8940a676e58e6def7c09c9c8072e6d92838f16700da42fc005d3c106c42e78bf9bac6b85223ed6b655bce7f1880f6073c0a5399a6e0d7bea910fb567a71ae5136d056cd2b9bd2e28fe4f297e237841b858b03d5f58e72b20e1909e73f9c663f07a2130f2857fa319b123c1f6e2aca1e716804a9f8dc13b38b401d45817130dedceff94b4eb6bc351f8d6cc63029a23ded0797d2dcf3c886057b01a0f5ccdbca49fcff272218d9843674b62e8b68afb6100b0c862209fb9c5c104ed22477d0b74dbbb1f2ab38ae6e888500cffe76c3c5234606a2ce6104a734e9f3e3ee8d26176cfab12e7c60d3f32ea0e89de87a0660467ed3baaaace8a758fe93aacc46b88439de1b919b6dcb8f97ab5bf3222933ad1821adae84ab06b81fbc7a1c820d66deaab3c9ff9560ec976acee2aaeaf9f576d8300d443bf84db5b9eba6d5b65ab4489b36f34208b95e55758570990510d7c86f8d345477a901d80a1029ca03cf8c81311f855ce789318e953723d39c4d4ec9e3f4d00e8aad945263efb50a35a7bf234e442ef3bf2c2b6c630417da99e9a9102213c4f423f5f38cfddd0edaf6cc5c98b363c8634a5b2c06c01209154c991aa7d45ec782dcc67109ac7c70a157f8751b9a1ab335cbb1d7c71b9329beac4213677d7f2b25c33fa1fde30c9e049200d98b88ec8942fc1c616e77ca85ec289dba1bf266d93bd637c498b6f498f70960854ac379d623e96b5ba69c9fb204908778c890a49f73f250e3c6ceb63753e10d5ac62972f1de0b0a0e33bd4b2d72cc32a0fd0d0bda62b3c904f533def7330e1b1e1734a2220f5410c523b6704d216d826521302317478003ae053e9242e6463d1ef5d22e8474798b4682a7e22852de33f4cc4733da7a84abcbdaec86aac2af0827f6f4cfbd0b00701976f13c142be72bf8ee92e6fefd5f88979050b7a8a156089cd67998fc4155ca3ed60ed07fd27e11f616c340f6dbcb303ffc1b412f515c479ed9a678fc13d309854219f1d87633506d6ed80fc99bcd3bf4b92f0ddc8bda00dffc324538d6d791f530667ea818176954fbaaeee25d1cee55fb6e22221a029f98b18773083b6861e107c0dba39f38a72afed429a9e8ffaece412998bc130c667f82636da3523071853b075f44f35803aad168d43edc4a92cb1e2b7d83aacd1a9fa2f88ba9b42467267205343f25ac80939ae4d6e45a33f4028167cfc4071a37235ac0769d5e263fa051ef7059bcb38c9ac00ffe08663833e0c79769704f0da325b695d7a2fb7c8eec4e3c8af769bf817e3d540ca3b0ab962e52fd9258b4143b0ed9adb5ee61bcfeee532f0b833efa20c010b0555da3271a406d8556385fe15fa2906e3f6b031a51d57243025f2098cb01913aa14ae48e1edd296da06d31b6c7c96356340a77f68356fdebce3dd10b1671850507d01ba2db70bc5bada946401842a1018f0061b2ec4e4ee3eff93e2fcbba4623e2955d3bc1c8cfa7e1465b2151daf01eeeef05fe13ce72620d78cf9b4d620e6a841caaa860cffc2d0de9deb3c2d61b9494e23c139415a126d012383b989255903d0ed7b6c5589ef23f626829f550921edf9b4cbf35855b9fa6fa770e5c7134e8f4de5eb407afd009daf6309ea25826bfa92c7e7f99d70a59de1e621971a717578ad5165e686a88a07568c1b7685a48d542063ee044dbaf0df9a50b37ca5babe2acfef681194b493d1524ab4ca9ae5bcd6a101c9b73a86eab11623809eada624d065d81cbda798c528f9ea8b28197ba9a8403278f578b1bda29d6f76add515e41330a99a6658e7be399a182286f43bc9dd79d6708d551095ee90c7ba78047c222cff18ab6b9dad32d9f930b45b7f9a67b4300806a839d884797d8e1f9e9bb3bea4b0fc3af0f07ba322bf72c8d0c2e8e47c03b9290785231e2c0faea2805734b53f6dbb1ec63e2e412de0c4f5ea40a390a651594875931d267a9505132fa3cac330187120b9ccfe57c437368b2b0bee0863ecd8c7febfcd3d3913e41af18c28e668c797a8ff9391da8d3a8a67770c71e7cd56fe703044c4780ca1cc8262aa59f670eab7c7fbcefb790cf3f9f3a120d0a047d5302f0622db245314188f322aa2182dd444835bb06de5dc722581e1deea052b44e4e876f5c3bfc35e6093d2c98af9fca645baff103086fcec2d92a80bbcabe7dca984003ab710069c2e9bd30ba3effc3d00557f1c6f1fdcafd9bebb184c145de69b7ac615a066a2af158b5f0d0b6c8fcc87addcd617284fb77da1f1eaf13cbf426c737db6ed11503ca2b8dd7d5fe4c7d694e77625ae72cc6a9289b1694f0e1ee8b93236adfce08049f441fed90505042794a8f7658fc34a9b03ab933ab590ff6fee0124453a84b3d4689e4186fa50c716827e120d91fae610563f9af9798746c6a385c9eb4fc99d99a743b71282138e870e7fe98a88eef28d74c7acd5009b1ec15b132eb3d49e4076a6c82e3b6542664fc2dc93e128ef127316a16bdbfd49b8596c6c8a0a1fc1ec22035cfc4450dd4955822efa393e994b05e8d711ad03f6a699ff6d175e626bb096f265b7f7523ddc57cf29265316eb6a942e4e4b23d2911686f9699b5569c60b807a009329de6cd363addb8d4ff89178391d1ce04c1f71a489ed4ed6186cb68b5bdbd0b61d3d200651174a1e878fd859f2ef545dcd15773ece3fa2a5dcc010dd555b52bd57710392e25ddd43285f4deb00845a024fd829967263cda562559a65dc2d6a1aa29f0b68f9b2d5b8439c747cd7d7e0a5167b168a2881cf752eeabf53eaae20f47a6654a28dd6558d1f90a6bc38f68be92882859861afef9310782068d6f9c26ab94a07ef0b77911a52d9a1726ebbaa2ea740a8e81e22ed639a69c74a7cb4a2f9e6534307bd6d14f88586f0c006f6bc460da6fc1246319313ef2dfd6b244c0ccce303dcc00396c5f9677dbde4e763d6e15368d92f9ecb807f79ccfaf847518dfdd84e3e708b44a58b5875b030059776bc4008cb31ffe1d697c5e59c0df15e3fdf4a3b683deefcee27e9af88d93988956c01c28f1d0fb9f7c95712c35724a6e5c5e32f4b1033b9b3119149b54613e4c35d05349fb1166d85e644fc05bb8238240273cc808ea63c598a78e68d77fef38103e6a5b31277127075a173123e0c048facdf0ff72fb091521ad3deb9dbe1ba1f5befbd79feade2f1f2af103688cb0ca45ecf7173b837047a8ed3acb71a606672df143d02216832aa4eb2a185a99b8d298ab6a993f0b36702b87f510e410d512cad4f822908b297d8b1abe13699a77d283105dab0617351c9b575bc259fce9f3189b9a6aabb50bfe8311c98bea56ccee1bc1abff7477fde9bfe2dafd501a3b837d9485e901b97af545926dac32131eea42cdfebccbc6958e2bfcba924e416e133ed678f4db969e3c6661ea14fdd0063245088f1da50264ddc5af66983c193188f682c68e0962f6fad872e05a3637f155a593bc14c7ea0bc918b5dd57ec80677f83d69cc018818d0617e4cee264add42cd0e6b749436272fa9605a1fcdddae281e28bc96aeec2910a83ce145f9c491765613b69f291e49621f6cd9a1468dd767d958fea2250ff3415057e420baf37f6cd2d66a9fc51a67bf958ba1524c4bc95e5aa2318d1f28899400aba062df071f0fde63950e84e75941ab70100aa24155ff20393f792e7bbbac5b2eaafb7516696648ad0c49c4efbf9fd0038d757d6fc2e40be810cf08221e0a9eed30a6cd2a745e6309f9ac73a16b1370171f865b72c5811e813ed3291bca7c756c4c992afac2f34f3a680356cb2f5fd3f49fd4f3e1b06de582c5dfbbe1f0e7caeeb154fca17b197a1ee910e3f397cad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
