<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9b914da2bab552dbae72291e7dc79002ff921554acb82dbc56fc1a572d58d588f1f3eb998a499fd2ce5d7eaef5320eb84d3963fac0cddb72dfec66aa3b18ecb3983aafac07d8458c831dd732d7ce7eff5af827987c71fe27342e261730598d43861f30630e6cd82d123a0180734096aec0a7d784ad84701b9e18ce95f4a0db3e0efc05a67f48d6a6ce8278a852025b611eaedcca8d3e697c4631dca6762c2618bb0981d469147961001454bd4c60652fb50f7794dbeca722af02baf990bc1b4b951741a8e22930b5d898da16a8f94fc68f0f65a05348bef653dffa49018f52d408a4f0aafce944d7a5d5378327f8220da50d7ef62e9a7693dad6551d55fdac4c28f88c76d3b106baf9baa0a0b34e1766490aa98154fd3443903db7e71374e33b2c63ec64373ab1e2828ce67183cee365f7811e9d2811211d5b991e63a5490a87c8f503af9622666e8cf4692abfdeda2457ad223dc0c707aa21a309c8a6ed5212ed160ad14febc9ba14f210b3a6a3a41afeaa362fd4adf88c92bd6d112f05ea6c23e54cb7eba36e2e4da26692bb4bb1b72d4c06289293089c4746cf6668eb285a669237f419b0bf29622d04079691de268bbe26fa27876674032e07020335599e949dd0ee65436a414d2c53c863e974e61eb45aa573828edf407bfe07d6a979b4a86dec4c4671fd5942f053d10edc3ed5d02c8d1c5662a25e8429dc380cb6f7db71eddfe9c9966730d698a7574e9057fe6fbce7899ab491079afd20613e3f7f113e9a077e361116ea5ca113b2a43a34c07afdc5b0c5a96dbcb692e36e2ab0ea9336c07eaaeb870f6bc77b8919346c9a7a2807c2d507674b60f48901d7dde2c7ee430983c784231e6630d9580c205324a7eaa9085279e2f73791d0a6b37d55c465bc6cae07347e4b9b6f8fb42eb477f62c552b8fb2bd271c709e73ca71fd2f1f1ae8cf1e3fe0a2f1e48f2935d2db2f9005590d9ede62308a71a3b1542e5eb0e7945a3a77594aabfa5662be587aafd51290a26ce896bb9f0f9e06e67dc0e84628eabdd77ee8bcfe2cb97223759331c6043c3d1624bbc22e7761411936627b8976724fb7a6b21ee8d4581604f5e6c5591d28b570378a7d0fba4decea9d8859431bd37d522fe30778f7843b942c3fedac92482343015edf5d1e0dcfd244e4cccae9f8f1f2d44c9503e866c8da1809a63bfaaa023f2177fec3d2c3c43fcb880ef6dd48009269afa76b707a7360daa1f0518a2d446f406a4fa52fa1ac33fa0823df71d87bad19bcec77358b166489744efa7200c71e7dfa415ae8b588354c004f8d3f75ed3af913a120c3b5c936a62ec0f9da7b29f6b305d1cd05495d73ede2930dea98fdff7b94677e7491cb19ced1ce584ae7c0063314ffd058af066bedae88de6cf094b64118e790309109d31eecc908e35b7f667afa780332da8135abc3d4028b7a3e6281252dd98efb5921499bbe18122d6c91df922e94c8d18c697f22cb7fb129ff03efe437722979615ac598ecc4617a786af805bc9897635d23e9de00cf902ebbc8cdf4da0f7fae5edd90f9b772ae742d18c3b5d67638c0f7e6e755fef9a58f3107e83ad4b84de75c3339f9c96ed7a63b2658cd720c67d2376ae005a17f8ec51780c1a7d399a66511dde5642ec819a5d972d1e15988efed4210b7620935d3d818e317af0a4ee63819a4a74e5e476e1196476a739070b0a3a9aab4935e03204aac05d10c2e6ece66ccf2535e9282eb8fa1358201ed7b499740ce36d73e44b9ea4807bb3bb2eb0f6993ef9d13ef51d527fecf0fd9be42ed4284d36a33d3c00a503e40a2b13fd3c55bfe72f98ca30adb15641b874bf94d8254e8c483802059f2adfded459e1c5d246a5115964b1f15f85bac208019dbc4bb80c25614610c90f3a57fd181e475aca8644f70cfa67866b8224eb62e9b30f44a6f0bf21a3d0473d306133cec351d6f9f2d6fe0037cf3a5f5af08ac1d7fd642f2a4c0c73be698c1e5c7a36fb866df48a45460803df47e829c13617524887554b5b58b494172c0171538a281a13f1c530429ab196588ec723a7cb5f698a7a52e14a7f16b5463e538218f62bb8dcdc8af0c007f42ffa3fe44c21ff51174628041ce3f0c70403190d782ff51f6fe54258e1533a9afd7c09ef901d5493bb8edbc6bf5cd527017dfd28296baabd53bc6523a9067ff07f465001e100505bdc2d3990e28355a53c592d26d75d90fa1e4543cd3e35e044a9720ec1724f37201d3e40fb0e56683d1110a392e2f1263c60e9033d21575ae3bff3b771c97e097ea3d70e6b98950afb34fd2bada61e987457184854eb80442d0037f2c40a251e1b6610238e512c503bceac318805d2f633b8aaa18112439191ecd6c5d2969ff9772b1181751c40ba055c4936f7698b73858e9ab67732ce611e46b29e17e64f9b2e6de8654c51739a45d6a1b1b8d7bda7635de501c2da2c2272075fca8d6287474c823dc94acf82104717578f54ac8bb4394af9e160c1c085a70c9304f531e0d1ca3da5b2fa1cf6751b0809a18af04b8f67c620bf204e69096807ea6013c761791c42670c313c2b14372e8ff662b2ecd5ad8fedc6897b9811784a088c9d7fdc5e5eb626288be04770e101ef57d8a94f061e3b62fb1495ff52c0f3bfa05429550d1afb15f08c1a1eaa708a9aeb23371a55eef61e9a3b9309fad6d46c9807f9b7bd56ef6921f7383bf46c5cba5756597aedf1ad86a7394475e5113834e7091f66a9df86ca5a5ad7187e70e917912baa39405e121c95da190b6e741b52ce018e6b388c69b0ebdc5a6b6e16a4a4b4c5a005faaf44da6a88d538065176108355edb02326d5e1eb5e0eb9e633826ff7cbb35037107e5d47a6b7e0e54889166bb1ea9a42c9ca5ccebc7e4ed0cde47860b6de24cf01c20cfc00ef3207c55f4af73c2d896ee3fac669a1e6a12f00fa0a54e377bfd53776fafe04d55a74b73e4d785f862bbbb5f1e8507ccf2b6c9d59ffdad1b34dab06a5b585c27285dd8e175fcaa25c9f4d90c954f030d0f6b765e870580d96fa4b8d3af6c0c08e1aaeb9a01f6e894779574a1e724a87ee3655a414c534600ef970d94875ea445f2065c9b1fc38b860cae824ccfc2f93e882ba905da307aab0f3364a83eb81034b15b101702b73f5e091045efce4b52f91de9ee8d69f5c183e67400bfc63458a201431cf2f6538ccf48a3773af330f7e6ad8494882b248016ec33d9667a3f3493c2d3d2309190944c64a56f98a583d09f4419abf6f47fb1f927dc32299185765b29ab728f2283be49fe3ade7289ebf3c11139baafc2cd0783e5ebd4b7eef8e37a5ea38b614ef50815f2e804eb0a8b1739224fcbd92a18a1de05ea87d967788dc9418c6f5aae4c94b3f4e59676dd9fa72709e78574750200dd468d68b6c827080d4b2f6cdc7cec8958feba234cf91a62a59e75a9f7c2eee2b3eda87bdbbeab257f8490c27b25ad8bad2de1e170ee9a947648b0672a77e12ab22ce652ef4d9682b49f64818644af62208220bed063d1fb8313b9ade5cda8ce2cebce43ecfafca408e599b45887309fdcfe1f3aea56d9f0a36a0b0c63834a3e8b8fe746b44db80af1627f161bc8b6da4b0daa3f1b6b2f63d5e1c06aceb72a7656ed6cd0518de22ac71fe837b6829b8232e598d57f7fd025e0e4f09bbf79eed7cfdfdd3cc68b8dcc3a3c415e2962ec712ee8e840ffe8746692eee7fb031dce5fb4816f5d4c18020b1ea1a58be04b9a0df0910680d4c9989bcda54beb5094670cc7abe2ace9d31c335f6ebcca27416a764e01dd09cd862d7495fee04b1979d1a3bd1186a412b91a07ed1818555022d286c4ee7d58cf8a41774c3ac84ebe7ba855847226e9b0248a85f3d3111e3956756c84bb8e8877d4ed2cbf0b6f902847fb62521c51440c81b2e95ef8da86688009326ec30173795775ab12ed54fcd9a2d602c8b93a9ac91107e37772720b99731a3d26ce77c0043daa5c13ea3971d9098867f0bc16aab46ef5b5b4e6428ab37fd68571ec25ce8505f7f17d20c83c1674da4c8cab6f8a9a78971d7f2f5bbfa2a7462ae0e8526507df171fe4e0067e8c696c79de03811e2494dbbfff2b1e293fa4ac2689cadce8eedb1ec5a90837ad6e9334cd1f79440c0daac54cad2ef05626045e2bbfddf99f0b83e5d269da0dc5d508341d8167afafccd0bd314a5d1d15b6f9645d177cc6d9c702b1250d442198e60d2825f5cdf90ebab80ebc0725bb0dc5a5bba33465fe902f4158713e6814ab3eece9a2cada267d26a0afec6d0fca8355b7c8587c0d07e4fa00bc4b0d73bc8f4dc3482fd9aae2f93c37ce093ffcb526b2631025af7088b251928705dbb0a109babff01f0a1caa2b20b12a30339015aae725cea4e1f68a3e2aa7722fc10ad038b2953fad3b681c01f25c9587e7000cee5dcc4523a22b9a664298bdd8b0fe9088e966d32bdfb73315e84cb6b8ac666f87ae357a62a92d48972f3d496254a68a286c54af1b314371af7ee81937593ef7ca8cd3f4cd9de32f2f2c0d9d2ddc479b67c5901d79861a052b5164c2d58a1fc843e4681c4a709184f39980d04ee996a86b43a40f2a5e3087ff8b7e81babfd48ff55783315418d4be4de745b2043e3b98bec113edf7ff46f23993a028dfdff1ccf12745972dd156d66bf98096b39fe33bc293e49a87726aa7bc260d8a51f118278ae28d5b2665544d0709a51590eab383d32dc8829d1e451dce3c66e56fb56da037bc63a28a99c8652b3286ce5c5ffabadb3d30927e66d6387eaac2df43062b9352fd087d604d3ccf7aaec9b61a598680ddb7e9d3b5af60c4de34375283b97db1d887aa72f3133aee3c7de8c886488534b3150178bc629d5503a38de9eb899b0af2f6237efb6709831a7962b4b6e4d60699165f8e807b3f7d6d77d06419337679027a361a9f9e0775f08533e0a16895afe9f6aa48a307ffb3d44b9b69ea8a055596e7e29fc61fb5ea1e7f60aebacb7003b94498b4b3681dcb2f73504965f907e8dc3218dbfd528e11f6a7e29e8ec310f66b7c3f6de32b032ea30d3f2db72a053ee097e90137edc10e7e59d15461f086ce389a5df06773552d0c9a58fb03605c697344b303d33981a56e338686b3de2a5ef9484e605d9de14b3381b84635e7495b9b39256df529647af8a9aebed5d82024d83744c55d37bf14d53e00e7083617d9a3efa4f40623ce78e21b9c44c18b4428387ad7d8b193d14964df8113fbea595519a455126e840420f2a265ad0214c849064338bb0579ad2b7268d97babd1a7e97bb3953fe6a09fb2035e1de7bbac144b77ee90a62dab9be6b079991ec14044be6edb67a6d82fe19ee676d2241d84ccb43287cef70b9122005e05eddecaf0006d12b072e7b01273841974d39df4c01504ff964f6b38cc27da026ffcba85ed6e9ebdb374b728f25eece7cf96efeeceef5606ca9e8f515d8223b425dee82f8a5bf4d18064a066b2341c417a1faf2b56c88c1271bc0686869b78241153bfc68d89d69e570ebffdbd2350376dbb52d6cd8fbe2861d5d56ea0309d7d219afab3ab48745a4bce5bd6aa146cd9d47f123a7dc0b119a3244c706f74362d04832dcc5b9f998b074ba5a3c53a5d6ac2ba29b03e82ddcd524f2f19aba2762194cebaa2641fc6e3db49691e620302e055e196127d69b9f25a0bab6378e671807f259212795942dd2799d1eb2de8a335fee3913f01afaf5e6b3d325b25033610fd13ba81fd58dc3c4275c1ec9509324e5c2f7340feff4851458980ec04f2513212fdc1df1ecc6267550a022df94defa0c9241f2138e429eda6af89f2007b4437e117be87eacba17676c6695d34d424fd7f4562229290ca824bf6947fd3758c9aeb3b9f3c94b86df3898ca4ddb170833965c0e9383963316b785ed51a269e8bb20622810fd46def512368a8e8fcc5d1ef026826bc75c690c117f6e779d9768910ff99abee87642ff42d05658f2fce5ed682b234af379c93c5c2994f15a792ecfc0e7279a6be1153a86bf18508dfd192abea0e079f01e4e6e20e20484c787909422e238871c94377552a0b6a744bf17fb0615e2cd71cb354ab217d52530e90bf144d26ab4c7d1bb8ca4305510d3ed05e43a3c3353d5b14da7840f0fa87de869004e56bcc7a1d642c842bb1a483fb3b5a5b38bf2ad1f461931f7918d991ead8bc2af54a451db2cb795b48a1e44500e206efd651cb10f4468c0b32c67dd60dc6c3a9d36c6b24613746ba5b3895677e4e117155d3beeab9b46738ee9943f840b1ccc36c383f78b0f39d2f4956ada3a2725a6f051ebe7db77c0b29660f70fcc9482d619d6ecc57523bc46b9be097217d48aa5dd485cbcfcfd70c723cc37678cac0014f87a2e9407fc78dd9cb171c5954a11d3b60bc919e21f045c7b3e7ad9a96fb0b08ede8ad3ed82ea02f39b9176ce2ea6a01e81db829eafa59877c6aaacd4f96ad5746c001d8c944b59c47f4da642653413a53b4b441b153e6db3f7fc46e8604436282301ce247f809fed2845b2f054b13ab7777b8e1752cacfa5ecd7839c1fff1b0b3ecdbe1b0c40d61c805e1835ac96e7d7844ee6696496f612a3a7b7b9faf54004e1dac52d7e3cd397a3dd5550187f80bdf49e846ca681568df6c1b80391501d6b6225cae6d63230fdf3b5cbf45fecbe020ee5058bb7566118acabfc8112f286393e2cb32019e5b27cfd1a7f8793fa2e21e6135873b1b25e56f97b47865829d7dad69248800e56b4e5a9b9c1ddb7a77a2af447f9b7eda3fb890969e339ee0cf803fdc308b6a59b12f6fafe41eebc95bc5caac91299d4e3d7054ecc8b6678ab4853c3f03acf69820b690fcc3b62113455910f6d95242aa62454639c9bdc04f5d96dc1a7a61cc8fa9fcfa93b89593d0dcfb853fc29195c3125dd56067dbce340f8aa8f71fa23ce770cb2ef37e41e35978de4857160f136c8150a4b6783a0ff7d1f800263df7d48a675db099019f7c5016689993fc7ae748b5b1e9a8caf7986598ae4db31c27eb1ac402fdfb62d3cadc31225e7f2d1473f5aa4151ec62c04f69461dedd0b914676992050edc314214ba7a35cf57e3a7ee9c33017196fcf99633f6fdc5465f0f46a783d9a7515a3be1bf73e915c6e741164515f678787f3d3bd1f5bfeb881a81ca8d31b92c0fa1a7575d1924b13ee4c8a6b8c5f73a8957a3e78e3fb9998433e887e3ba344090af6f9eeacf710a42ca4681bc7d812fb4b818e333b509346e3bbea7e4b2a764ba089ad7f771550988fbfb9db9fb7e7d61bb7f1b4dda34de522a71af96ab9c5ca7ecfc5575b3397a697c03e061bb10989eb95cd560a841780a36ace5dd1d66091f1711ead5c509286f6120db98e9ddb4ae5e7a604c226f053d5af86bd285432fec03296dc75fbacd4347cb18cf20061f15c7cb4e537a077d0108dfa7a646153bef1b0f81d1b5662013e99e3bc4511bb7ebeff90200d29dd1eec54d348b86fbec75e098a6bf535169cf2e121b412369ab22782dff2d5b6b437b04d3cee791d0118014260e0ee9d40e529938d745bf8d10aa0974ca9260e36c4a18114f039161b784f3919abeb5ff8452a1a3b61c580ddec1b694ff9d6670d40d3bc0ca472dc3cf2f6e2001030fe0decd14d76ccb986f16deb1a09642977ecfaccfb986186f045f85c5cfa6440884b0cd58be3d1e402913ea71d04a6fac9173ce03c6538dee242d68e2452d358376edfe5bccb90f1173ea8dec8df438730f629ac6cd5d22be317ebede584175d30da30ea3afb8fdcf024cd68a474d735c3fa43a68d59540aa34d7bc1827e914e71f884c3423dbf958ac5354f5b360b5989ba503cadd7a06daecd366fd2c00edfad11983bab6d0d03c8d6d260328eeeb275cc1e05571377575f56ee31c41f82604f89265baf24d99058b00e1ed63c22f4f782403c8efbbf805284d2b2e426155debaf9320b14c0dfe04ccc9ca1bf1b5aefb83e12b5275e9f59749819275c8f2699a15eebbd17f33088bcc48c3a6e662652a40100df72ae3576c523bf051dca77b6e631b286d30dd9af2f59c319b4c7088ac8c815618ce319965c1ccfb9d1a5a47126ed0c2728bda122b48482ecbd672de4ccc0ce50a9fd534281c146dbca74283989929159b78d580722da94a8a964f66bc012d1694c0bb330f2af8076d15bb2df09d85003b20eeaf02180fdc94241f3eef84e3462152a46b59626505986e411a11a87a525a9425950ab4511737506d40003d38b2a3bd744dbf22f8ffe659db4eda77dac625ddd8c9547038b1e118349ffc902b34ba4525ce0801eb78c80ee60c3f9e9398e53280de1690b79beafb23e4f265426dd3cd363d79035fc528fd2c85d9807d513ee6ef738851f889009e35249e612fc53b4ccfe896d27be44a2feb61c39b05da9348106df805d09f9a48196adc76da4826cc98ea577ff5d99a926d7b0be5e3d3d1ef57cbe6c6ec365186d50588fedde46a22c08fc015dbb544ab5e06bd528d70c0cd7c98c7b94d7504a050073b3d0bba8b16e048f86e17cb9dedd1b5b8ab2f35ded402e7e84c6eadddd34c3771289523cd0bf15ae75317cce70659b45c3497985498aff3f1c36df45466b74a0111df6a6b0da1e651fe9a12a459f590e4ffba2cf3ef38b6f2493cbbbe07b3a58dc245ebf461e4e27970079e2a3a3738d3789fa71cbd7768d5aee55d9b299773530b87234f22beab5a3998098d4ece3372e515072e8ee9a7fc4f2467baad10486bbaf330e0f75413e6fbf5980454a8063a3ca7c39e31f5c76a02cf1594b9284d3b3b0b9f4798ad3d121b71206e221c391453f641f645279299b5362ddb45eda38ccba3b3fead5f0ff8a1c09cd9f69b1d5123ae852acd9a8aced71b34a5f9b29772e5b06162e6d1137ca9f76765f7947562a712abadcaf73e1f4151ef1a21daf78e9c0042287183deb4ae1c7705ce1692b0f2bcac10e90db14a3c0856b9b05ae9b7966e4a21f493707499e38294d5bfd3d469a83827420bf0ec54037ba4afa33ee4be96f5d49d91cc988cd90195ab9f152f3fe2909ca229c7899868448efa3b49f38448163e989d5f4038ac78708f1e8d4125a9f3da79766614fb3f5d4469dba919db77c024047e428fc8adaabd2f10871bbedd13be069db7eb17e4a1b9c7a732be619472aada45e3e5ad352d99d289c5235f7016842cdc3d5709e6455b74321e59c4f8dad8e32a0ec4f37397212aae7416a4343099b6e5b415e3cb3399bf1035009b0d2e1b9142c451786e437cb5ce2dca889e4a3bce192b9bbc9f61ec35390aabacea6695d25266894d8a0651b0befcdecba5ec30224fe424e72a5dd80c3dc4aa6922bedb00fc0a9a4e640496ac7cb379ec36e27fccc20e6b91db72e08c1c84b033b5899ce122a88bde7263f0fa14da76cc67db85af5b94348d02d25b2dda5bf72892d30bd98821710d4697be2146268b2bb36635040afa7a826894bab91e855a8c4c9b9a7c6bf0afb9f4a611e18b53335f76591c7814e0484eac4f63c4aca32cbb0bad3cb8eaaa1f42737df3a69194096cfc300342285a7943ce512aec5b82bdbc95e027b2b0132baff6d408a2ab24bd4965006d92d999411ebf2280b36767903bb139194292cc76c651cc7abb1584bd45c975cb75cfbc8195bb18e613c2bc3a7b1c677e844728964812d3334efd67d5e05b684f86d39e3d3623d6694fbd707b5a9b5e7ae7c9b94a9d223353b0f2bb425194221ecf83957c75af8ffb1496cff8a321e7b81062cf10c60089f077028ac5addd94ed895cf4469da1c9a9db5724790866da95a3ab20e25bbe5c459c1de8f53c110250a2b41b1b0ce26db9abeb6e96b2fb4afeca7638d99c7ed6245c1b045230ed388db5ab283be1119814d8bc258e30c7754c33a63bfc264bf8457972cf4b980455759fd97f9e5f6b5eb96211f8c81f48e91f2615f930612dfa658d94b1897ac3c088939ab452612c5c88d10f9fc765431bb1ee79cc294eb0faaf54bdae51d3904cb796aa0cd8655e4354738b8705865c69f989a7a8ca317be8e842c03556c0201b77a2142167854910f987be12d0191182b95a93510a6f8072ff78e64c7596354268039a9fea7471573d8d64dc41b484911b49f81c47cee416a494001b1a3e41b47c842e6836407005432105885d3b67588df0c1cdd01850e2bab3c11250c1804286f66ea5816a3dd82a08115099a79f203f0c78353fbfb827b85c1822869c4784c68f722cfb69203823e1f5e65bc16fbfbda9f2ddcf843384fbe6eb092c72e07931299e3584d9c5d04b771ff37d58fb9a58c38d5d2a2d9710eba9075c978adef7035ec5e1245204d82874dd287d47e62967071eae5281b7a103219f766b1789568b597a83408515f3ebbca46b4a7e7a362a07f5a749bb63e51d319732956c290927400ec68c247a1d65646ff8238b8a2f86e12113374af9d5389c708d34bca473459ed10e4d5bab7b43da0e460bd69ef93a023269eb17e41e5e18cd8f414338aece9b41c9222258dd1864160948803a69a616517408233686936f681905359e169170f7041c566ba39bc3765cb9daa3190d4aa916bbeb0c44db155d25655464e3dade0d8eb4b4d36fd865b3a148f81a090ffb734f12e6a24a05d8fb69757d001ea40185a619a67451c8687039ac3aebbea1440b3d2d7ee79a2e3350ebb9fc8939ca929311da7c058a6b17228a2f8df946d25837acff9896f0b25dadfc9861ad231a688d3c3028eb651e625642534729f0d5e1a0e6b7c1ddb225211228f7b8fc3de4cc2d52dc40767df1bc9b11cab03964180c94aa77f35c301d7de3ed6509ca9ef39527488ac8d1ec6ff42d1d0834e961ee08074bbb4fbc9ddc875ea0fabdcb4e5fcdd4ccce3fa36eee02e743a4a82fa7cc888160103127f09546e7f8183b0a962ab1acc8994a6f91fff36f297b50d76dfd429215105e5685c2ee0dd4cc4d9881b6523e30c2119db92e0a1d0de5bf76df045dc117cac3cdeb871ffba4c33ccfc6eddab417b42cf16c434ae2fc08e32bdf8d5f48455ffa1b3f803e301592bd4a0d0ff7ed4b69c06077b7b2fa81a238b84fffa80f65bb9546212f51c67852bbe054dd43280e8a3efe7fc55cbaee2c77011584fbab66e1412233659cc71293ad833101a8a579ebdfa43af8d60e81914be52f592bf77c6daf9c5edb407c0b1f4e69dc2dac2b2ce108a8ca9347238d045a5c8e6f44c951c0e5d1f7c8407ada5bd8560e76e94bf41d56af36e6561105f1856fe073c7559a435f1c4c2572dd8f35539d4127743e20df404efbe7c83e991bb8f0f70c50688ff7ec983a46ae69eaddbe187e5f8078d59d6d187f68baecbb276f7767d48e6c2119c1f14770936ed2764d5e256efbb862c6f2b40abc6c96f1aeda84ca5390bfac4789dcd982023a232ada8767cb1dbca0c3a0807b3d009363055b6186c5d4500ea96f68c9f101e22fac555d8b1c58dba4afb05777d7d81493278cc9dec0eb4578c74bc9aa603571016554c15548a62004d86f79860ede4f7e6ffac7f88214c01e8dc0f208a05ffe458c21ddb2acfad4866c30854b4d5209b508d5b0823309dfbcb2e6df531fe4f5074c92d24590add61b23e84dd933011b3552b5a1bac705479f431ff970dbec85a835c381b6fe0edc794f2af9a59a1c594c5f30f715b942bdc15dfb09883019e0ddae9ef77c4f04791a94a4bc82fa536a42e8883e319125cc78434e100edbf39b42e18d2a757d5492a0e15b1ee7933408cd1195e308373b2ebf8c5b6685151c63eaddc90bdaf463e81827afaf0ada697e9c411f2665477660affbecc13cf2ff6322795134af5785f71aa24bffa6cf78ef3004cf255b8b4deb38d2e668ace28b80d85f76c2c2d3b12251b10a240b82e436f48efdb65877a69687b4ee645badda40aa79fa4aa9fd2a9117691b184f4cace821e8b73c1edf93055d6f78580ea8de658b9baa4d6d00f976e7d0e91b36b18fde37e30abeaf04830b449a003bcccbf47b26882635dd4b4b2938c2e62a2d3101a16a68d1ef6d2e1b1e59d8aac3ddde2a2f0e57c4b500cc58f56f5a53512318db9fbf2e9d4f4f94f900665b6eb1cad1a7f5d2f1bc673cc92c7e8814fd49372e4e8c8fb26483ede1ed224911909e8036e2a889201e606fad83ed33b0386d01c152203748a80fd891dbc7d08d4d6349290180b5ee07f1bf2067818711db2728ce56c5e214a72a343b29421e86ac82621cdb90754b930d98695204047665120f4aee39f2ffd8f2f21c11f80a4634946f449bbf84787d5b29c61b4f0d43743200de095cd176cd0b90c5344d48c14eb0d0c845fb307f764d05efdcb79574f68695acf5b829af2cb05539a917e3e9bc040c0b8d56de4b73d31a736387a6b40c685eff6b7365b823e5a85800d400ed8f4bb01291e35b1f5647bd9b9e125c219d3d7ec8d108da10bd67d82f7c3f28a6e37ba21d0b2ff9fe253585f23e40291e37d61699f82544cd40499512be49bcfbcb5d5408f6a4baea0ff8ff20f82db621b12de958e677ef1f78f6dce67354c63099ecf389ca4a443b5a7f6011fd0239ddbe551546b14a4eea2c0d1b83a6604f64cf65b2c64b73e1eb6106adffba4331283f656f0785d40d6219621a012e76d0cabf36db3cf47d26330a7f502d05c5c39aa4addd8a9e5dd2364956e4e94668ec2e10a55325bbdc9298c0589711535bc13f5273b390c4f1054d4b6124f05ffd0036e46c51b66aaabd32bfb261532ac39ab59b7035846dd082654e8f08b26fa084dda61decad8f6e98f723680551353199ea6b514c468afd32b18437ec8be27273535b57e139cba85dfb1ebe787304beccc492c2c28f4b7d8be1dc504d8e31bc2607857805ac7d7f13ed6fcebb867ad91b9114203e3ab446ba4f516aa63dec370d0659a29b726779a412bc8b611054a618449c243b568fd53b3b9799c5c46add48bba33322fd077de811b038e58adabde110e3a22a1739ef7a11aff6d42ff880f03587c2f367ea91791fcbb7288194192963a12c8ed4491d5c97b0a13990ed7f954b46f3538d84286341caee6641bcb0fc1f693d2e5dece58af47cb637b4937bb617823d5b4d11f8df6413e050d8eb9a362626aecfce94eadfb046b79987b7ceca8d7e8c068d5debb44ed9f9c9a42663687f6b80ddb8afdbf34312d4091cd4d3211ea0449f7936014c4ea8fa6ac64533519d82726519dae746d4adee0d9fa737affaf437066e0f2244af91302c64bbbd126956fd787b1a90744eb558baa904360475ee17bb7263fcb1b7a146b27c5010203d15324e122960b28c590b811af952aa029da954b629295992d8987520930468f94ee6767382f6613feb9a823f5b9935fbaaa2d7fd0c70126533fe8848f9b1ad71f1c631d9e5e3b068ebed0b4b753645215c0ddb8a1029fb455e86fb16aa26c1270b4ad4b96c7f22891cbab9469edfbb4e12cd6c32c40ba480a32b52f1e2b62f04015a622aa4381eb8a0e63943234022110ba6d68ea718edb612ad871c6213165da6de01eb95e5f38e064fe59c9f993ae876d1032e3dd5b523c0b7fa00ac2132ac90a40e796a9d3ea7d5bd7feb460248e8c664a4081e842a16ea28e3b41bb3b336f7c9f56937a19d22bf4f6dedf01d0879d3b4ff80db0bdfa060030cb9b71f798b3a6fcd6f5bce10ebd94e041465fa4fd29a31ba789564b8bbb0f97eb2b633ae518cbc5157e533bcc16719ea0480b16f613f96543d604ada57b80050082227f1bc3cac822134ce4ef08f04920fd5512d49242389604b6376228d8dd0b4492fb1251d3f5e9fe75febf58128479de5b818d10272c3bfadd45135d0fb4693d0d6f32488b662f2c24b6afc810e288e8ed5562bc61965e87af5b72deb414cc5dd1a8539ff24abe2a140abf4d632708e5c22655d09b11dd510eff4536f230c49d8c7de4c7fb614cb527cee1909c73e47c13ab1566c2c39e9a566b47ea6d46ed54ecd8bacc6d57d0c7cdba19c4619d9105404140de473fe4ae36fc1aa0497c41c4eded70e42303f65116825a16659ea361715b8beb91f008f87ae1cf9cd59d36151ccc0fa4c15bcef3aed47944f5b9d33c092cf00bf9338ec446d3be33da0a50257cd33a3c2655152ba557c06a62c0888bd61fe4c287181bed84ea37f5db57ce475dc9e1a8d1665ac8e7a6689e6065f036d3078d3278e5ac429f5f3880d2db5da4ae8bdd2ccee1ac83dbbcf06636b32063de7461fc6237aee6f777437048388193165aa48d8e7c36e700f35d189c7fc7c38f5b342cf776ef3fe6799898397f6c7080e9f1d35aed9af6b2a7514ad3d4bb1d0eeae7bbc8450039c50945db84e6e2297aae16a18b9ea8ea8a16c947222df6de7812cde091dbf27ef82d3daf6387cc27c3ed3330ecd48bf56ac95d27eb4c6f54958d9d2784012b797c4e55711e21fd6cf4fc2294297f2f19209873455d8bea3a1de0ad3f7470f3bc15cc024614fc4a9b1811d594fb7e075b01a7f24eb489c01caae2df3ac3a4c7a9585be893eac8fb8b2bd683f528c5fb8134c34a9dd4022b48d8596910d5b3baf27820abac5cb1f176ac769c63cd8770180be74a7f67c5331d62f6abcd7b77c95a115fbf415ad945a84417b8a2b7dffe820f265b3108f74b12f264c8115bedffd13a230","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
