<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21e5db74661b543df69e8bd797db66ecf3ccfaf8dc902d0912fba953a9b8487468664d11a86028edd2946d33b50413c572809f17a7a5063373cf2ad9986329c32c272f22388639975376709ec9cafaeb60682d482ddfe3ba21aaa9708e02121577dacc3bca4ec5df32b1d56f7d484e00e0bfda3610361f29da8e11e6c8d6d4e132047a0edcb21117aad1f0eefa8795cb40827ec51d11c89d1d49c5c5649a8269ce1d745245a6ebb9ab11346a2b0d4e4e7eccce9f2ca4208f33bfadc0e4977c5b6d18abe0b78695f1a3b2cd49c5dee468409101aa43243d071c37d1547c1fee1952fa16417f390b826e8ae1f06ac9b97555be25d6cda732b93477225f22b645d6217bc8154615f53c9421b12c699362d42199b036cc385e90141dfbdb600d858e0321ea52bfa3ef4469fe64b89c5ed43b994e5a45305d58f58663727c4f36852d99a7cfaa04aab2512ba597676c40b80081b43f8220e9866c11412985253ace44e8751b63b869a15d4ed74a445e5ad41666671a64cee59cab56a41adc262ff7b3a667386cc01795a13e84da2502cced601650ef5405200af9fffbcbd0511516a37da41ad10b464b6a71525bb73b91748ad594fc93f1caae20736f6ad52b852b231c6134060752d9134c9d41d2d4948e0115a73679107e0beefbac1d3dadaef058a91472e1575d8c60764aea9c570161bdf109998e3f6be0dd98e5004229fbce7a21b562a6f3cbf156c269c4edad6aad63b6c5f12347bb9dba033989273b86333415a0997c7dd422598b7d6233cc97a9e88aed7b8f3d11049b728cc7e6baa1b0cf20192c29cf962ccef6e9bb4d49a5f007401173d629e780888fd930fd4a47feb353e465ebcefa06a923d0c1bcb819840bb2bcb67fc856c0f0fad2b82d4325f28d912ac3ab19772e2274add26d98620e85f58f624eb91f09fef115450d580de7a98636cabe0d7b8d7f1fe181838ab5dbb233c0f735639b6990c9a56c816667bf1a5e143a2ada57e813dbb219b54acde2649f5d6a701dee6d21c2b6d67846a99a64ef7bbff2b0fad79ad500b15c57c4cff3a0f2b3068500ed7cbe624d7a112205fad6f42493daa63941781c0b65f86d98fef09832fcfa22e4b3bbe06ca00c30c9bb50e0b79fca383705388dc0b057554d49e9e294e2a84fdcb1f24054be48edaf5dc13fe1551b7506044adac5ca1b41b65124edeac0a12a9538461cc0d1dfe3028c712743c894d8f30844c1e909eb57cd8f77d04a71a65a7ddd6b6771a21c38e7638297a6294e83c281dedb6ddedddc3be1b057ef84d9726a6254f2ec38809ec6855b730b3e0624ecf093062ad8188070d4a1a7728fde2e01aa5659be7e69a0a4d252c7cd94d90dc0e5d66aba18c5835ad15e6f9179b307beef3412899d4e2160669e15cf822db6a66a4ef08eff38c743348d85ee6429e9f31fd51f8b10f90be4fd8576574fe2eb3cb3f018435316fe749bfc8c697cef54e8a6138a6616e77b85715245b8a3918f0b0a449d1818c123f54f69ebe8429623978771847fe4acdbb9f2ab46d7fbf1f5fda5c47bab11ac1671721f08b9d12594bc4337e59037332e1b6d4fe10f14d26d714556b74bc6c4af802ffcb363b566c31bbd0893c3244d56e8dc7c9c41a582af7abf145849523ac704b2ea4b6ca57c2e7d39671d61aeed20785e3a01117c944a992b8235b562e6565c4a509e90d1d440be579db24ce17a5332ba5a65837be75de14094a4b0f5b7cd248accbd993bfb43f032baf4881e4dd11acb8563ef781fad931adfcca8ac2b81c194773edf8e0731e94a461c60748a41cdd97c2715e488408f476605299c5e5b0453b730445f60fa7b31bc857715fba2676d12999e473bc8a133429b399962fd6f11536a158883bfd0bd612398f4d46ec6de6f94c4b1e9db133b92c1767e501be5d1b2bc9d70e90998675ace63f92b6aa5c7a75fe3fb434edeac6dd128e835770d344455fc4cb1e851d074550e3a2883e7e9d2dfce461485a66bd1359a5767b937b1e218dcb4be3bf7ebfd590cd40f756ad79fc52b3f2d44ef89c2173ae55ce558a0c663cacb22df8ec479ad94d5c5229f758b6e5b045ad58791a759ff4f8e9d44a23fee86b60068996591450f3872b3c6f5bec87899bb7de8dabcd870e661d7d51bf293384ce77ba8ca361b89566b5629f71ce9f7b5727bce5c63f20ec5fae4a4a7e526ba4986fa294d2ede3baf937b03e75caa5d7f5137e1afeef6fa8ba98dea83457aa6ecdecfe4fe9e985370156c1d9d5ed6d40dc944730f980e19b5f7cc6b8c0df9a345a635c6c68784315234f767c8d490d6d6fa9b84ac3a944c51f0c3f98430a21a0e35deb040796a15fdd7e1c92341478fa97487da18a1bd127b8ef8db202557a2a1a5907e8cd4c49a3f703121485d89b9923eded4a171bc7b388d3cbc28c97d8f0ff1e92d96b43d1d9cb427a0bf9f4033147f04f0248970cad9dff8b4208013274e26a90ca74b004186032fb6a099e35b2fb4ac38c89c526a434eb40b89a6526a9a667bf850e538c96f80d7305bf3fd6f83e624cf4d76838d486addfeb9d1307b667a3dffc599ddeb37c42bd8e62ea6cae4f32eca923eeed2669f06ddc80befcf7067080d431d589af0907da5a46c18d2f783e02d5ee87a8284b0f406932b2b8c1f84f8b43e78471d0536c197c86ec6deb853732004e8d197355c1374e6d3c9711aa9547060868bf203a190b32c54c08532727539a7b85b65caaa6139a8b1267fdbbf861922d42b1a0807225cc7467159bda3177701de5c5abf4f110c8aa65a4ba857ce03530f727ad27779434795c316b5c305660fac91d58e294ce89419b767cf9f40101c355696ca78396395c4b0c0ef2f682937ac01b7398981cf959d6b2d5feb80070d28f64e61577330b134b3189863f1d9b5d07c2b425092460f508029a79820b10670a2ae4afecc5fadfa54bce68dc13deb6da74e5e82327d3dac99f349472b900a3402685fc04bfd477b77a63325b35d507c1ea15f66f076371c518b95a761742b834561b8e7723523e655d6b20def419c6fc9607ea843e2e39b1e23b28e395eded4f5ce9b465e42cfb5506abc6ba8d615b508e0ac692f82dd09d97d64914ebf7781b0f105df9da0ff383cd99c29b3d1c867435dd787a91339d9d580b2c76eed352f83d72a871bf75607bb7059f1a0fb891d6e36ee722d3574bf534449e87e10f4f2809314f959ee29a8f7eb81233566d9710eccdefa461ea7a5167ec7af75383ce08347e5489d0872f3a42fce139e242daaccb0e352d219c24b6cf8762b8a5f418cf4a7874185ec740797014f93c8525075e839148a4f789eba2bab18061adb01ce493e760b135e03aa090bfa92293f8b9dfe4983025e7c52b952205ce51db0ab5e80f6428880e34b472ac987b35a8ab2e7646afcd90e399dc25782114a726383875491c28d07ce2b4c5c29a43e16ecdad8009bbdb07054ef5a7cab2663bf82abd4fc6332b2aa13d997f2012cce3375dbc0eecfedd32f7020174ed8a47cabdd0afc6aa362b03b1da03ac20a9c7b50e79804fbf5455bf208e5b234fe185a432a9071d240968866043ea2898e11c905721fd4fefb2e5711dfaaadda5f1365880f9d74242f89d22b0e4b6e4a3b73940d4977ab3139ce087ad4bfa83a2fc64155b644fb1832c054a7b44289cff1f213957aa58ab6f3359dba95401bda752a084e091c3b197585ae6210c434d7e6a68d81c2e5563061be86f880449a635b9c41984a03c03f9b07fad874b8cf270ca0b5ab197e17d603fe8c50d7c7a2cdf6516fddde8b7fc2c4100bd213f85ab3fa2c5454c157747e3aba707ec85e1cdbdb19fc8186a755ec3a90f8e5c7858b0037e089b36b6c12b5609b31f335e1a78097e8b7389f4c2020ce9b513326edaa0ee91352fe3e5c526db67cd5095e155eca1a67695c5bd337fc73ecefc059c84a1961e54e73a63c098f345adc4a247da198979c05bdf4e55a0ec4b47a33a6e523cd30922bcbfc718e7cc402d6daa015b5294f202f0969b333ae8660decc65aae009ddb149020bcd45674536e362057abc33de8caab7e67bef40964405061dc0e4cf0151893744be8df952b4f40babdf91c7487bcfa22fe2b898c9798a7e5638ab2aaac9ce773c6e4e83f38fd1d7b3cbf57aafc24b79ee092524ea0cf59ff3233078c1d484c49beb6806e67b5067946a6b6c5ed4bb2a70c80f499803eeffcd8cf8ae0216080dc36ae9117c95e58047e4d723c6853ef8fcc9f735cb8894a83abfb65fb654a2275778fdb647fbffa893b26e34a4444bbf7b3b883c87bb62427fb0f1d078a5c34440fd3c01437321322af7ae7f4dd76733ef130927e74f426b850c80dc548eb06d2eb5f1169734d8085b7cccfb057a443e3567c4e4301ad049d967d8b1f5dbeb4bfa38899dc70705806fb2f3020a67141febf08bd7c10ff08bed084ffdcceb57ee3bbf1ce8d8fae3d1ddfe306dd091d10a632537e13e535426eef2a0044babcfa0c342a8eb7751ae124b92d351a20fdc0d4c360600b8c980bce160bfc72e0867dc31716707542874263eacc8cfeb6c33cf9372fad923a7eda9c6fcc20b691b5d7b68971aa8631d1cf0ecffff6f94943242a17cd4d366b6f351985f140c28202b39f760951a337a01368e854f9564586e17aafced2dbcb1c92b87b3bde38fa0532ebbcaf874fe3eadf5500c93a418ee49cdcf19d6aecb0d33eb7f838518ce4bdbe8302578893d3064cb2a7be3e0be15dd59907ba20c518c5034e71878097c82dc5dfc09593f119d6c8e81d3c6b6a3257bf63a06df6b8336a32149db53fcfe1139fef284118fd179a3c28adef3003d2e08f56d48b8afe295b1f1fbcb88b1c4d769600336a6e87cb2339455d8da7c6b8b3d92aaba7390fbb27f841e3f5204edd3f2d36c8434080ea8e04f07f85ac2eb143b1a1ecf2fbc3779fc896218c3ddae73b6822b0c64acdabab6d6b5ee5680031cc08ae37ade8d97760c42e543848d33f3c287da058ebeb540de46d1457459527b13526ba69d840189344817f2c5236d3e5239cfcd66807bef10a2c5b48e4413902b0b3115c15a645feacd961eccccda0a1ad1835a3fbb117ab0c59bb84fa6a3bc821d233d2b3184369ec285a0b5e8c651b031e0ba0ca1ac4623a978743834ccd7c33f8a1c4af61ded00aa0050e9bfdb048887ef25e21be37bb1404d9c7f819efb43b12d9d51378204eaaf39c34951583c5996456daadf343e5f7cd9e3f04dc98bf1b8b655af8d2d4ae8b2ffc881640e1bdfbcddf923807868ecd4a2f54893f16c3b322154bc0f3863a9f3f27086d8d3291eef282f9a2cc522fab1783958b2b6a940c884abf3cfb0a2c7a654efd4df1aef7b7956addce5e060d98e88e43a67d14bd4dd314f21ab9c3819c8f095fe94b531dd14472cbf9e99917c53c4a9ea10392d06172e2f71b4af962ec3da80367d4f8081b811e1d60ee57fa4ab38aae488ed73f7fcaa9f5583456459946ec3ede4f590fadd118a9d68926647c78d159420f452aab3ac45dced6af592be3ac15c0cec0459e6cf913bf9d0606223f9dd3ea1000102a478a1f69d7bd8ed30c2f82c8d19d305676861495ce50f24fd2bfb2e310c42d4100ac4bb69f16d9481f2283d356dc7b067bc5dd0a24295626cf84600563ed3e38155a9ae36848a243fe069521d46d01abd2d097e4030854bb0a98034d884b2382e4de22b0559810c68e18a6d35520ec2efef7c24933c15d9e3e0f10e402ba0ddca0be99e423e954f2645c23ea4ddf21af0bf8641b653dedb829eb0d718b6517b5a8f26d4844f16d8fcb1cbfe075fcf0e5acc8696b12e3b2663b4d8572d45baf25a26865366400aba55e46cb85a60b775ac2d1a2622d478e29931dd598f5a5c890c009561456a73b0c84c400fa71be373643860abef842ccefee7d11f26c2a27d5fa7624500c207cb8ee86618dce1ddbab261369e3033e0d5fc6e8a8a7fff0cbce9be2bc8b80eb39a1e56c10f32d4bf0c3cdaf034f383f1f4d9e1497727c359df28479c0be5d0e4433ac4a3d5f46161f9ae0f88513b43170f49f3e183475b35222548d8b8110cca19042617dd356ad10badf206a0f54157e0918a45b60f02bdd1e7e8ee7c6e3cc6c9cec2c242be8eccb8289cce3dfbb1ad61c45f09a7334279bc81b0197ed46ca1306f13c2a28e5fe0f67c59d22d984b3bcfc8b85c71eb6df07a3d647092c8675e6bdc9926319d805b438a09c2f52f53c78c72618926ee31f5db2f9897e5b6de7b16e22bcb32161d9da2dadc16fbe0ec82a6927f4414c84511da1714219ac81189040fa2db353706db721cecace95f9dd0ebc14ab5b0e23b562794c94b25f3888bbe3a38f6d72bffcb1d2b1f63a0ec814212152f30fa9c688c451e7102e244fe510fe311a4d8e220db70d7f7fdfbd136e74c7eff5bfa8c019f62112b6248f6373049350f17bd431d39b75303cc0fb6b0a5672b2ad898a87442a45ae1b07fb359ea8be54c888111b7b566018b5e4706cbb82563cee0b248bcc53afc2e1abf0613311c4c0549ec0492b549b5379618ddc5e4443e3d96a1f6810d35ab75774abd9a7c9b2eb4bd52c06fb11b8122e600a52109fd4fb8fb016e5dee9ca38d0ecf123fa4a50a9faa94be633b2cccf7413a71fb3298a36a9ad370434bff0b4740d10f251b6f803a5a8808e2dfbd2122b2347cf86aa0ca5a893e322798b164ad485fb8cf5f3260f64bda3622f7e05b05a9085bf82885908a087a3c04658326613d8850f44f80fd162193e13cc3f42679b114f721f7fb98656b6bd9ce8429a7a6577008bd88f0abc3e9b36b424b5010a27e80b25ad5260520783462022c51bae1fb576d48de4e2819fcbce0cd8f342149bf32abb66d774c26cb5def456d6b865b0515c8d29d86486ad1aa12dbe8b4da844a2f5b33d44a235ab2dccb959ea7c74d00923abe9b9621906899ec45acb82cadb49adacf2304c95177823aa69d93902eb1fc6281bba77a58af7baa5edf24109b56f3c989b1c2507bcda5bb6f9bc61bb0a2626d94cd235b5e289304fe9c02e33550b9b3354aa5c7b55134f07e69eb9ab48172544e570a982fb440273205ba178661efc540ccd4faed6c866b2868287850495c26c5761bcb1ccec9dd0746a5c7f8507094f519ccfa7a3bff55a16bd4d8ca8698c286accd5342bdef8e904a6c20639a27d5bc12c02ecb32673150fbe52cea13f2705d464ebb40c23906e22deb2780670040aa12d37377a2dfb600a64d3340997f90e0bc6e10ab6c1145c0b0ff4f8fdaddf690e27f86519f8051c1bffaf988f00149fe2d5a48105c9808be9df16dbf7ef8e04a1451109a20293a73681ef95bce1b83b35d408c172ca84878b7d29a9efc258a96c9e9813755ead675af12849cb3f9d86e9dab95be9371df3598ecfbc81ed6eaaf90d35bbbc4fbf0d9425c89338632a7fdc2977a17372fa310090f85e8bf318535e4b3af72c4140e7357ce9f11693c946477dd5193e1b880095bb7565ed4a39605ef292c7392dcc2b224b4d7f023e86352da81f20751cd4e4b181bd92638c85551aae0dbda70dc5ca5b30fe66e55d7a9d59e72a405492b288c444a47481321d1b3ec55d608694e90b2b8e99af00ab29b59dd0ea495bf01f5602ead182db247c4b0a2201bbfb9646b5e5d8727f9632e7c3c26c35fddcec7f0bce8d8aba1f9843f9ee833c236b6c140be7999719f9b94cb3a7dc7699520c5d885259ef1eabb200af28e01d86698060176e2d389f98bd090a3b3e49357cd0c1245c52384add299ecd05fdbe74fccb17c1523b7526e0a222e81c08dd330ab5508b04025e5fc1bfb10cba8a5634427a8cc81834267f775e3da473f16207ba88dcb38be6687a8c92d1b8effca1948da1c669653c05bd6efc46610a9d5008b5b010848b5d7a670bf4bf4b2d21e09d81e579d206c5f6c0217641d8650ff6af39ac6bffda6de00b0f373f6f1c1bbc0a4b5e0031852c1da36396c99a9032e52d3949dc927b2bab2e2ade48e39e4c55b57ae9df4e9ece84ffc541d2a9122b3d2cd20e48c71faffa585e4fbc7ec601aa399e95d8fb40bf678c7bbbfc8a72bf0397bcf96e01b465ca82b84bd58a9504e3182c5ca7f83a2a09decf2dbde342aff60695b2acbc69827b70d98c90d26bd13be0af535b4f2140dbd839b3bfd61fe46062a7e222e777859d076b68fb395880251023381e2027a9e15a50a4ebad0db7a8b05e232438abac824ac75bf9eef963e072c19fd9bb4027d63950ec8aee3fe35731268e71d555bb4d291315bb195b713bd1a3c6f731cacefb59d8407b1dc07002f7554eabf370f0162e4f51dafa2624d1687a0baa905c0b44542ec48e3534168d30bb12ff0f31d6d5e4cd67048462a668e7ad18b1cd45c1e2cf2814e3de7d4ff12b0cbbe085edb80a59fc46cac2bd4f7932dc78367318d8133b972a9f2dd7f092e96238f1eb082b1040de6af73070a15e5d343516e6c723106dad65dc25ec8d665bf0a7c97dadbab102a77b729bf99dcb19313c9e879361969b8940f0e499ed97246725bc0d904efc61471ac5bffd598380684d3d98f22552617e47c926a507a99ffc96666fad11f1480dd1232af09d18557b9b8b3a60d86cc7324814ce7446feac89df316d4894ecd3a6234621a9342e279231058da11232e278addbf8024bf54c8a0235c2ebbd20898c2a7db3ca7e45e4885ab22856f8ef0027faf8e013348c00274b7b696730e7904f1e64b6537f53cf3e0a568b5dc94cbfca2b9fc9da2761ab3b304bf467590c1a80f6049484246603953af52508fee6fb189ebdbf7a500458ec6107ece133fd57d30a06573867d45d08685030042a6a77552099805eaafc3786acb4c21fdcf9b1c49cd10af23238db55fbc716b3603569d2e925b4cd752b197a63e27b09ee48149a2c316d343cb30f02dc4bd97ffb3dc0d1fc7aabea64c460c4ec2847765ac31fe68817c840cb7b32699b713cfd1c44a13f43c3f6e1f246f67765c65ddc87d47be2cfaf3c620cea5dde0938d6d77e90295792ff16fac050285ae3955b087a451df3f349d0524756242dcbb0777911e5fa6c2e803221fda6f29220b42e2c7805c05334bd4f0c2d1decae072c1e98ac3422ef94f6e600c7c6012e245934926d7779bdf549693e33ab939c7ccacfde33caf2a884e1c53e04dc31e33f5b05be73edbabaa537a9571ddf2bb5cdd7343c67a519d6139c522e725331e0fa6ab88514d4bc7074bfdba723be60a005e49388493a7d0b60d6451d24a6eb6667284857c3649dd1be72da8cc89b3eb4ea3893cf4c9c4e7196217b00f626acc497a38ab13a82ee10c1f503a77ccd209b9ef60013755f740b4be79bdb339c9ddad028a78972ec3fc94193c67e83e2b5146731cf8a4f3d43d154b577fc9d139dd5ea5738e45b153a8fbd8868926ff751cef16ef3cd8e6d05ade7598a48c4cb2976a8586749158f95ee9d9503e1410ced5e0f0cc557ba3a4ea125b7a662e1ea8be862b3f5a1a1ecf01116b09efaa5a188c6c4c35187d0c3949d66b46b3135a043798c391e3cbcc291198974ea0cc5feede5c4f8a90ac71542ab7779ae8874a5919eefb37a00126fe10c0b0c0f8447e9b3fa65d944b1355d96846bb7730172676d4f0411a24f6db622390c648f507d471719bba33ccbd77685f26d7047dca8ca95e89cc30a3cf5bad22924a504b56d8e4dc8c1f0d857465a7bd64f77024e70d35ae989db62176add0acdea9b5542a8fff90567d0b76dc8ca144706eeffe170008b9ff4cc33417777ffc7373070a4e624088d66568d9c73ca403b0fad06899d80cbba2602d8fa94309f46c217204e6f690797fbc6889b20d664e5516dbd3dfab17c8dc5b80d85a2abd93ba9e1e89e24ab4d8908858149e5ac2b69962e26ca2d8235ab76ae48bec78ca30336aebd83626f1092c421f709f0f53c70fb014a747ead8ccc1151852bad3fe049847c5f8799eb4033064fcac7220d4bc3ff333722827ac685587335368923697cf344374ed297ae67c1bc86d23db1bc429ecb6a5f82f2042284c2c2776601a48067299c281891acd696472d7002d11981e34267d28e356d96156f7772bec214e12a9f9303a617ec781b132d163855e680f3a63016147687869508cda26e0fb70b7b37b8091463876800140b0d403146adfcc3594e51b46045bc51284210b452da1970485f9406611ef33f15c2349501875b5c8054dffbdc2fd64852834910e7c18de5397c464ae2f9ba7b2c3e07989ae7b0bf2ac6f7c7993dafb5887341435dccdb7f73056f3975f9a63592fbe0122ba02db03926f42100dae3240d9accb749748878ae75898847379c540c8cbdd562b34f4c1e1193906490dd83b649a8c6b38aec7aab5ab53091c9c6b0b5ca132e6f35aef6898c408e30ff9e2cca476b6612f90eb7b6f0cbf811a1100c88eae75b418e5fae3c7014c1ab7a4e9f8580e24e9ec3784339237de10e335b3de451267967cc338a86dd35d5dd7525d874ca183dbbab8f38394560892ed2f426b1ef0eacc9036ec9b7c43340d7cf9fd5e78eab7482a8095e88d0a1b11f1091d74be780cad973b4ca6c3b5544bfff5d3614f61f471cc34e987b3e79a5f6617eda0e3207719263401fe4fe9f52a6e86d7fd118113ac008ee15a2a39ee059cc6666ac918c52cec158dff6373c5c6c1c0a5864260d18e282cd0b8774e059a7a2f3f62b10664e92e0fdf17916fbb98fe81adf31be4935ba4e96493e3aaf29169b8739c8f71ae115512616c0a320e862a7b2ad9778a4d3697768437165616c51e93b9354229282d696e9e2429445c8481bdf3c56f5888a4556181a07cf13bfd103a0c8367a3ed505b283ad0267b38b767691057da2ffec7fc9edbb4f71b2857504077566c05b04312cd5f3445bc0fb030db86ec2398feb1dee48b8ad0d5a4b7868d14f5785ce538bdf56ffa368608255856ebd1853b4a90cba77121e31eed2ad497ad7411a353dcb2e276f25756becfc6e6350c67d2a764c5ce4931bc694e4e763472d1bf0d1e9b2b4958fd1f65142727fc116afaab06d9e7feb4d43558385947835c94d18192d2906793c0e252503776c044ee7b4ba45f2349009ab3d530fce144a61a8d915c9423b1310590f38837c27431a17aa31af1c6ea987451e8c0f43291902030ca1c72338b32b68d296450cf337926a03add08b19503cd4b5f205cd0b2ae5d33371e470d8f5616563c2a71e8b7c676a037c6bb75db20651f0c608b4d9effa01ff338d0b3d861999a4aca15cb602617a278bfa6c31211f99028c92e8f9de7d27df81b419cc53d5f4965bd0cf6018408adc307b2518dc98f476f9646122e9908286fa6950e6ae434d0056397e54d33b8d09cab9b8a9851995189592baca75bb54058ddeb8168ba7f7ec5df660566effc311e6ec09b49012744a0a201e26e0109660e1bdc0da38ce4b90963e23e7d5fb3b84324f81ebf4a5f77827f8d6d08654b01c7ad6a3906eb2e300830a4da7774ee9ff6afd795d8e579e9c6dc4612789ab04f0eb1081752bcf2178f19a18d778196fb756a7dd2586de1d9e1256aad611033f77b36305917e28266547188b5fefa5723d441ecc8227c5ccb18adb8d1ee4919bb06c088724008f6afbc3be70088a6c5e72909a8cfa5a85b524e080b05aa82dd9eaf11a2c43ee8fb940867b8b5967e83e9703400780a10fda2e9cafa92070c65e753f07651695963a008eb4010a45740e3f29b715b96cda250117f98d32876da6fba65fafbe78fca93ea00156fdd64d3c6e0c1320232a0cecda9534e1ed25b6aff9b6696d76cf6f89c8c27ec96aff4d5610896a0171d1170a59e8b35fcebd0963f04df70e16d176080551a6ce0a3d7613dcb9e0407e5466bb6a1db03d2e0d6dc5725d042fc04c19641f35e59455d41b7c07e6c827ce1258ead96a7355386de43e30f423f4a78bcbd3eddf9e819a595ebea9c08f17a91ed79a3c5b8d46d6b91c3edf0aef471c9dfcbe6018cd8faac830f531b96b412e8b0ee9108a58929ed10fdcbb96d8bfdf1fe41a035d59251b19bd95d78d2d39b3efd91efbaa004abce5ca1630e33c75b9282b6f2f92f923e72aff465fd2dd925cbb5bc658d7798a95530a5113feb90af76e92f2f5b7815f9e33bdf43cd7cfa4569d8ccad8d45f34f3fc6a172c81dcc1969ae146d1ff04ce7ba34377e9ba4ed2ae2edf07f5abc1c3249e2a14eeacd4f59915bd8e25c87a7b1799b3ff9d84f3ec06e2600b7dff5c467ea3cdb2b0fcdae9980610ece2b9630495e0fa64f4a60976844ecfe5677cbc051542cd72e391bbc40508921a0d62d5d3984ac6ac5a6291bfcf31ed5a6268f21cc3dd9c6567931428353e9768236ff1cbb0bbf8a9d4b3c332b8afc0d68fbb1955e82a5841e817ce8bc678d0d5a37e65b1712de5680326bc380ae565ef0bb0ac1b165ea08fd03a51abe65166b4f05e3aca8885b17806d8b4404961528460c76307c63e36bbf2b9f660f680838da719b0a9f0e6a684f94939e54b57523159119009c306e3b35096bf15d49a3ac800dc65a7bea3a457189462d110157c259a53f2cefad2dff6e9cda27c56b4514962139063b046e041e7ce6c43cda75d1ce8a67534cd0794e0e4539f156c4c4e8ac6c792e0d0fe309c945c779cc1ce82bd084e42c4af8fc0f3a8fc9d9bcea65e9a0142a0cafd639157d13acead79600469557e1c00088e861d2486efa2c335ad21160a7dca36167a586db7b588e573f601d096e89574b6db579836a9af90cbd31dbf3939c0cea4236d66ad9ed1cbd214a916b8a296d8df76b5addcb07d60489b98ed6c10be19458e5b5a71b4c3003e4eafc2af4c2ef3b04217052a92898fec4dc5e75c676de6b3891ade06e6bef2f693ec83ddfb1f1404280e00737a873d034480670c1254eef53ae38443d5f4cd963a47b7fa806335be0763b60b5f7ffa3d6fa95d5bdd3f6b80776916fe45c3019f05ffea8d6e4f90fe3b8417220fc49fd886d8e218b4a008f15e8965c5e258f3a63f19c913116b85405f1059378cb2cabeff9286de45b9f9e7b947523ab4acf923b08abef697f5e52fa2ade8af59fea29c47ba71280568684ae26bfac2559e37940f58e6f3c234ec30dfcb116b1e47ed9b196daa3c15c8d219956f6f29dbf120e4b33c9bd765a6823b4763725b1ed093b039d9a3141dd7e527a842f153ff2ce83bf70f0db3f955bef1379a4c2063f8930bdf36ab638a85381ea86ef872d0b47f59b57366e71fb86e8fb1289d17a8d6cda17bab55b9872691ee71eb548e39082b2ffa36a432ae679a24b40b2ed0151e6e61e9b49080804907bc15ed8afbabcba7c32066c94d74788d9daf0bd27a19b97382eb710cdd9197df5befe01ff6759f300cfd31b8a304bcb7b0c10213d27d0f6ce412ec20fa9c03555fbb681cd1a3ff3b214793a6fd265120df3c6dee88592898ceed6f4da27c0ace5459898ad21482de8f9c006254322c15763be928d7f2ff1b6a19a11b9302c5ca45fa87a5e321ef1c5598c7d63d615c32c6f975c3faa127c38e9fb18f338a92d6be952c3bd29353f481168bb61faf5935522002a3e3cf77ba8025f0789c59e6f3cae34a99f787a12a869ead99483d4fb989d34dea9cea00bd49d84d5a895bbc6318422bd8a0ad61f63df9f3ca69c5922463cd1be6d7bdd38d38e604bf28c78f940d2935659a82cff4a3e4df76aad01caf5e54f5aee8c7130bc73635795bfc513d91e62ff218bf840963ab552d379bee23b1c3b95254b6e7781640a7f5669307f4cb440d6bb58b778019e46fd9a951a4ca96adddb78e6d923cab600fb0233b58d742b3667755dde1076b7a873b9c1a2fd5d09bec25ac1b8f4ccd0b85f1be934ec4f8946985bffc200199a43b3802c5ce191b71432ad301b7ecc4b44c4a9ed505b14dc0e25d21dd96cece356a55e988372e85d05d06326e7602dd4ffffe1104d8517b0df5875f0522b8c78534871fce3e03f5aef1bb234f6351cc695c90fbaa2d50fdf41ae3f3156204327e6fee8c21e234bd2988f9fc9dd5ea874f65fa77dc32a4cb54a4c2d7c846bd3dd16945e3dd1563e5632b7cc8d86cab084a8bd5514839becffcb229e51506a446d4108f2c31885afa8ebe20941e51948efd34dc17d4ec379fdd8c2826a9649e9725d608ba6af8bb7238b6070533bf8de6d5e31e14b82e9d59ce4871740da01f36fe17e51665834be3515f129ee80145af7023f33257ba8a524d1ad8fddc10a7f244d9a4cb965e8193e0b37b2316915dd4370c124e433bc58a5c3a9b6a690426beb02a4a9d5fda45859d335d29148a555ccfb5887c32130d32b64edbc051c12a3c59a216e7f3d7e14102fa622d1284977541f2a340344df1797e434ef64966e145133425d0e033fa112d211605c7ec1580618edfa5404da7e35d95efa1c867dc8d851364d02c6931c250d21291d69303ec14cbda7506a8808f57909c22147536cf332377536c2eede1307a232b4e0dee77395fbed98d0ed0cc6d2b44c75ae8991eba0a3ff06181bb6fb89f441e608cc5b955478dd27f695348e5e99369d207c408c3215def24295c664d6b0e04172a6960587d3547239148cecf198d646409ed4d4246edc2b27d1433673e5930b5284176b6e0e45820378e6cc7d1c1a988940ec2c1d6c14d10467b0407c8610abf661e3ecb7d75c28e750ed415ac00f6e607c389a3a4ee4894047a57810baf3f874d275d78e5baf9c6682701dfad68979868c8988b998372e6f4280e0dbd8c3d8620b65d5d231e66f1f1c0f469208ed89f707aca72f1d110beee483a9398b010d49c49232ba531dec067b339b6675d54989707fa9bd2437b13d818ac790dd39921129f35eb1e25c4039f4e33ace3838b8b9057a8f30e25346121036e1ef1e30a6faec27c0fbe4fde2e9114402a63ed3ea697bbd0567d9f280024a83861d999530424a3dd91530bed26bcdc76311de07a9821d9be21b1e3176bf0906ee0dd78b21a2d5bddad38457913438d34b75a904d4e1bc2999c5a9a514cffd69ec78829ed17285e2684553822bd68350fdcfbaeccbb79d35ca6e4f8e05f7c839ea6494057062379d149a8bcb4bdeb66ff28ed0db29cf2d93dc8c87416d5c1f6515819ebb099c4e0f11af09af479317537bf6a9dbb760f82d500f0d0e884f74d5d3dddfe41a3bf15954a36cba374a1b6cbda395c0f330451bc183b49355d1764bab7ee238603aa1bf64da1beafe87752e34eed39639f1af56f46e379261c7c70295de7d90d245473a8a7939356142c29eb3dd5c11952a0348587a98bf3fe8d7bdb9f86d02993cf9532d97407d875fef550b758e02bfb07f7802ae9227251b9416a376ec1e74aa4a5876cc20330d784793354b5f2dacf3efbf15b55a110aab62a5f2ecda4f1ba3c1dbfa92bb989e1e5ea2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
