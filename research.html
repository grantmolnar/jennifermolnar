<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1d6ef77f2e80d292d87a7aa6dff71e98a3f8e4cf1ddcc04579c2484c0fdefb414287b53d4754329092f747e19f526e4d99c3ad6ceecc2b9e2c12ca4ec1447beac1ad892f7b1cea56422d7ee99082684e6a073007edd902427da6bcc3f174253a20bb78982e00aaa4313370dab19b949c90d90dca525026a69330f0c0531443a72b61fe01e8ae0158fd401160939b9db9bc296c24ac7e04759d5da324735f2a835010e43d75807a85fd8eb68a322121b2f4a07b8f7e85b1403047351b10c8280dee2cc26d6d238bb9217b7949cc6326d399f29ec95c8b3a46ab9d7d916ed9aef239240d80fd84ac575e7a2f0e14d558e7ab3b75aed47ce38d8c9cd48af44bac2b4d89097d87646e0dac8f5d6978faefb323bb5638ca235c0c1cf32443d83202a102b788387ad94de5ad5472955abb278ab49d8780174ecfb5cc24c5c0d816e84cd1a3fe11c20dcec2444162a81221cc60b76759e43d639d9b9292b41d3dae596eb63da77dc63782b4e91eae05edba98bc2cc61352361ccc20ae1136204b8ea61ab782adce9c2abc52bc1fb234aa46e1531255b8ff147ed59a9be25d2b0642fdc2e054b01e9f3d52cb6a8790fe68fbe0eb82c3b2fd18feb4a5ea11af1a182679c9c0d86d60d5e4512e9895de679b42adb0d701597eb159160b7079925616541e2b70f6914601e9fd6bdaa150c8ce3efd2c4cf525e521e58662f164a068530bdaf876311e50c61303c103e357a4793011f47908b5be6a2c9f076a8c3932caec4535ad7df6a077f4017990204402ee93acb7dd3c5c4da24f3c22a3aae9897a18058de877c29e18da382c6f1d2810b80693c360b275dd5f0390077d9207aaa142dd937061c62ecbf7e7291d4fffe24f7fcd3d2007f70eb44df33160a82c221895a98544d3976a6feeb66f60ad04beb0d0f2113d37ee8a7ed4d235d3728e90ee59da17e7f2fccf3805f0370aa8e5002712a5c99c592d0406f4ae9847b529441e6d080aaf481d23a9fc68cf947972690d370ebe61198119fc723047d1e59c986545569e63d92f671568f04c0d33b0bdfdd2f6db020000dff514484f293b568f3ff137d369cc2be9e94cf78d548dbea199442225eb38b15e05c38a27bf80aded73d31677c98684be1cc0adccf9cdb3cd0fcc60b1757a7a1cc83b6288a4d174be4f43d56faa1aaeb9637eaf9aa6a4870756b3b3b62bf767a0b122ecb8c54f0fed374ee9369dac0102806109c6db98bd6da01b31728ffe8e494145fe08cc83f8eb5e5b2c0868501aa84194a69371da9eba3281d3edad5cd8afcea2817b9483c900e74c86cf0b8f7f07fa0fdcc3d32878ea17eac0259f3c8f12a13e644aa5e53589dfea79f6659222b7e3ca7af96af6f1d0befe5a86e042e662f5640d2912d3f36cc37184d899d1da0c52873a5122a2991b36c41cd8f59fd9020f6815aa0cfa0e538749d6dbc8c29c79c59ee03046adeed6100954a89ff283b4e1a714cfc0d6a6f011bb29386a0f3c05d7f2cd069196d32e54135ab47b1b652222663e3850115f38ff07c11323a3e08e4442821a0b2daccfe06846a3e89a8f2ad6c49cd31ec1ed93a4467ed98200f3b5f0af93bc13fdece757af2577b7e604fb70490f565222e71318965ce688d268475e9e8f68fedd6130c4367bca217e607ad74f7e320ba077428def10ec88c44e913224c872ac6832a1cd9f2930c21202873af8250aefd89f8cb93fbeb15e8574a72639b30fc37b2d9ca6ccfa026da65dcb4374927432687964bb27c76e5f753befe9f94356fc985f08be92f3c7d7cf4ca4db18ebd6178beb14f06ad76c07255474f624cb4c7d42e54e7e4426b1ba5248d80c94e64ab09c3cc94d3f2f7a4d13a95e34084600b9f8637358d8a1d7a9307d42bbd4bfaf8dc0d1e778fe663acfbe74640945b6f976c3eff1d28c3a2c56f1f5f907e0af66baf877c2f5b2636ac64ffd589c51c91e0fee3e3daa1ab6005aec45785082d26ec437ddcaf708c46d1e6207e4149668fe4497c98352fa05cfebf70bfdf56e7e33dbe3036b36b325b805f21dd934b6b0754d842f73cbeedfad740ea184dc5d79dfe4963feb111f1e77841de6230e1e7af1a3ccd4dbd6a5850dd711f86e4e0c8bfff95eae71e76c569557cc6e7cc6f302ab26867151e1b4aba1d2cb0a6c05689cce35c73efda5ab34f3d148b983be406654601de3b6ef97b978566d451e34b547fb792d45abb0179963da92d191cc8fbd89cb2d3c9de66502fe8d1aeb7005e4d0ef0945da2ebf345ce9c8374316a07334ba84c1f08234374f45c0343a0a96517ba2733cf28a4d74302c99cc68ae167e0b20f1c8adcd4b5ddd9e27c918691e50983fbe3ff3984e528dd9b09d00f8122f64a52a1331478419169de62d770d4528df44c265bd4dea8bdb3c2bd0ca013d7ebaa42cb9465943181fd0c5fce762505d7f4475412009e73b0e8195259c590d7b49f83a9d41f12396b9601ae3fef49a109781ae92b19a98f425ade5a6b49983310f6939a0c73eef6ee2121c00c0917140dc95e34ab7969a97d1025d992c2430a1e852ccd791122c2b74ebb7f63f5e6254cefbeab8126c3ddd32d334c3526e7e5fee0544b9031e79e79bf9501ba68b6f62649387274db68590cb78548cc8a428595c0e23fa8dcbf99542ac74461e2c2ee586e2e0fe7da11180ec8eb586d2f9505a6f8b94182692655d9e9ad4980b26d49b1734348a6ed914ee65fa5f26fd2e207ce5316c168d7aabe1f2346c1edcbe5502d1ac702c5cf07ef47e436ede1defd66bb0916c631918fe0b28353f9760e5840959bfe944279392a097a5d2e42aff1da247be924796835067ac49561d5931a8fa88aad585e8267f92273c3cba1d3ad325fd4a389a1269be960d051961771f92f26b65f435e56100cc50fae7e0a6d46d7ab4a542ff54ec9c6cf036f8da67ffd6c000c905f4c258f93f8903e31fd2cd0e9cecc1edab2ac956afc1e5a9a17b0882acc10daa6f2b16e98ace9af9a53b23781a4d4af1a12daa38eac3ca80e3140b17dc9147c31565c0cca4d9ff768001ba8786c08d432fddd7c660712ef723cf09f6ea210f6e4a7942ac5810e7043a16a29cc314e598e784bd93038766ea6501b4e8d1e61a3829ab0b3797aa4ccdaf71bc4fb810eb77cbba4fe2e4e8b08dd235d9057f3e54351ad937a05f0c0bc2f6e905aadc4168f85a034d40b39e3ac948f03621885d0936ac0db9560867266e5f30b5e0b9323d99505e647a44743faee8ce7b29873986033282d2f47f05d94fc0aa6a59067ffac47d219d9da65ec320d65ba57114bfa12ca78d286c27861b82b019fd308403470afb910741aaa77da591413fdb77cef51737df4c6fc42f9de75391455d549108baa55fe7d6a386e9083000fa4f9be5c7150660353781b55d2d3beaafa2ecc375773f43c81b6fb70ade1794ab5a61a6f7a2e3e3e56ead7a35b15161b4552f1ea13d5a6408886f18d6f8eeeac782b6567dd21e1d5d4501e97977ce269454720059511a4ad736eb2c32abb9200e8036702142b1eefc62114e73465ae09e840410b860dcc3946a72cca2b4789de72ac1870355a680dff34e6994cd80eaaa8933b35bd981821844505f488f0c6d9b74ab873d99f83a1a5ab2465fcc946960cf747fe30a723b41ca0692603db1e261ce67a507a10ff99fefad78b9e5ee7bbc29d14aa5f164984d0e7a1e840370455fe42383e3190a92b73a2e5787334f10715c693e7434da47325ba80fc2ef9e99f0d4f61278f1e5c8dad435382fb666a0ab53fd6f95edc8871c9f8d246467f09f380b7b0eb5eca71405f428877c4884934b95f97ef7841099c22b193651e93f885f5491f8cb1b08c9f50240df30e830b290b751c6f992a857637e5e91c0c1f1c48fde2857e85078eefc93418523b84d5f5fa7c6267c51550487b640276ed9d7bf81a65c4b4d7c77f4ebc01833b6f46f6664393c886d934597a2de572b031262d875ef6cd38012951ff3aa8ac18353cbdc6bd8054076796a375022cc89812a3a8c807395315f97be47e3426024cf4115d0688db4a3617bee087dbc1503bbaefd42bfe87a57156ae04ce35cb79b165707aa2faaeda84824a6ada6ecac484e6a71a3db2bee5b57d51f1970edc2ad3c2db9da4b8021d92046b2b4c560f092300be7553af1e98583ad73fe0b43dc76e6dd9ec581b378cb1000f5ed23a94bf93dee49c879b9cadf887d544239aede9bba1299103156aabe50c43e5d044f20d3bd36e583c41b0fb93cda1ee5cf61925164908de26e0c571b16c3d8aadcdfa872ea43ae165857ab83172e807fbc1021e27272d91639b3fabca46ca8cbcf9c293fa3e8c0bfa5efd2aab6233486c7a3c96486ac05248e361252fc0d77caeb9122c50bc934dc2f85663873a851d2fb64341aca679c4819db8128f01706c5718a3c7ea6d93c07f886a70fca4ebf0a35938c5699452fccf8db5f34d3e90bfb577ab1982d75729aff96669625c6dde8cfb9fb1b217dd70fb69226a0041d5d28ef05b07c070cc4033a932c49ddfce786c1e87bb7762a9879faa22d1d7543824360b8af47627c515d2ce12cff89ec50994ad636f2a3fe486398740ee79e5be98034c4c7ea5fdcf4f84f8a1a5aff2ba91e8179b967627ab0bcbd3f8f3c4689043a84e5337bb4389ca714f43a2d300105587ca215f3db22b0f8652db438454d679d3512743819f99fc696088abc1540d28d5cdd164e43719b69ce09a276fedc0be5e7f93a322bb429ea056e8566fe9291771845208329b7c4bf7e087ba02cc91fa182bb752c1e13c7ea79c21bd89ff679bf232d3701b71c681b381660faf8d574c52d0df61390b0673ad924d5af2af9b659b15544ff082823e789cdfa0f9ceca0048c20ae8717b90e78acb63eabb5ce9a66094f59155e83f4be419cb26f4925b26687adfe3226e3f4d625e46dbc29d4389043cdf6207aa04f5c200e9b19b6ed4956508b9858d832b74c905859c90f7fa9b3a31163d4f1204da1a50ce2eb067ed0bc69f8ff174c79d32d62c2a357f425f07e49949e967b194df7f0ced87d15a18dd560cf256202b71f363b8cad6fbf056fc35f764969c45a20cd1aa84948d3acdf6f1d708c54d5d92fad53df77e4ae9ea86b04c5040ee2bc2c49459089be7747db7551af720b5c91b4122c95cf173644465f194ad5d9c9342828f89a9c282eb71dc4da5dec25215983d90b5b5bec10737ac311f3ecf627591b66ca63844869e0d40dda455f5873244bc8bcc12777335a8a869ed1fd8886bc00c81139315c5b49462253a11290f9619f81acb8dd70a0ab783acd8df4b44d694aec714cc9ca24cd3be5ef67266ae1bc8d0b3f5e70cb4c9989d92eb7cbc3c39ac39282bc1c6de8ad041aa97a82e63e0f5516ee1b3e61ca74d6a867d91c107ddbea19810b873e6b8734e628985f818665e0718f6c2dee7bd7e0b50ab959663f2abbe35c482a11775be86aab09df21138fc9f406cd52d4c4713b8383aa92129b53de68d88a67966ad830286713a280bf20502ee1410a25c4d54d5089b9dc834290030dda2714b682ab3efa1d8e88ae20a3db6cec6c87962bd4562853a7f83ab429e8e2d9b994930161c6cbfe945abbc283339c6319209f08bea5ff920c7e7cca4d3db7015ea00633d00932f33c2fef2e1523aeddc7683aa5ebe14277efb6be2d257d699f8c5146326e8dccb3d47720e843836ea1cd87f54d560f4ff7dda253a39552c4c20103d7f8a3d53c20d4a3d98adc70cd2e4949dd27b4216ba9b8938779b0c9ec4f4c730ef39c68ac5876e4c4cfc40d396ca7e208acfce9a548dc1d4a1b6aadd1c78fdb38b7847fad4eba79ca4a55c4f05ff08fa8f1fb889d2216635a38e1bc81838bb1a4d3a1b9ad474564fb93acea349105e899b0cba9d0fd34943c5893cdc22137d24d6a6c98cb18767a0dac8fae2cdaff8674f2079acac187c5976b3e17c43e721042e9ba048f4690fca36bd468017c567e552ae7a09c6328e6d28acfe0acdab931c16e75e4eb6ebd57cf1cf5359dc5395e532614a4c913235f606cdfd4dacc5a2f753a554938026fe7e36c15e3b45a19a70e5b0e1481d605f2733291c4b55f55aacc1d422e0ed33c91a270d76e0bafb25ab4037527aecc88e91046d3702ffee001db666fef69ca79f5d86a719d9d19dc47d4284c6a3607ad703342e46829c7b14a8282363468a82a8f042caddf28bc59aa025afdf985247a91566b871cff1f5cc51057f961b4f0210261ccc674a1fd204e69abe714dbe5030bb45c1f0a5358c2d361dd7711b888f4cfc33643618b44ed27c22393f181fef0683d0955f30027ab66e4790e81fb295f49cb9a911cec0b79a4587e11ee012115d770bf1255c599acfbb4937705bbcdbe19181e87a41bdb8c625db08d8265897772f2fc41714d8874d9e91a7f4356b9dee57a0b9ae34be5f4f004add10f55c6165b3629c11a51bc892b4962f70cb46ed0a764faf8b61edc93a2a40f4d43715d007d93aed16e79cee34027cc8e2aca70c2d538b8d3fae6ba297985d03319b0a8b81e8a73dd83d2efe01e0e8ed8246bf1da73fe8ceab15cf843ca7b6216b4c77d4b4ef0e8b816a5986631d888b06c3aa1a5b8a8c99df8e381ed7d9a47331cb6c5741b686e0535ae541ac0210cf24b6b5b2b6668c56025a0674287e06c4283f3109c80f8ea2f4db2e5156fad892ab0334b24bc0a2e11ce0eda0e7b903c987a64c666f454b4aaa19b5de4e39692c22be0df1a6aa86be40afbb2c5229034fba39b4e0641b6bd45b9c4f7f58baa7b2d0dbe273f0e513fce7857af633d1332fd68cd68b24864e82c0c8507afde51f5e84921568589f2d62bb746f82c3b0210b109ebe77aa98bbc2d49da9d57c9b034eb6ad7076ba401e2e730963f4c9e89c9b9f816fc24034f8cc3678d84a718d5a9683c41503a92f87ca6a486f7a44eeb5a03b2cd7ef0468b696372f56b2e985912bba340f58d17a88f6c1024fc42ebca97ea3b2f0b3531c581a673d377d13da1944ac8b0fa651d2890fa61b06ce2de69337d95c7933e5a0c9f453262aefe1f087ad3db673308003b2ceb36a7dfa141bf76acbfd50191d973f1ebb884a6c0b75cd9188798e8f5a90a5ccab9219445c9ad788a9260bc96f67f29fa7dd54ddb68a6bc17b6d9eef35288cee8d6a414b4bc7afe0b8004b2ccd283500b979a02b271674db7aac86170f74d790f61379636e1b0e8c6d7c9019c6326744bb32fa716d3b1b66aa51482345e7ab44667f784558aeed3ce7fa987bcbcf924ae2830ab42707baa12433259b7e02e638f64dce6eeb3e3161f9281c8db9614fc3d7b034c1a0d27cad1a44bf704ac9b884b36cc84971f89be72c47a37a9e002be961e25b1957a91174adc77d3bcc7d6e1654b757cb48a126a78fc239acce3a4a509c6351af3a9c79f71430449dbc4dd103df36e5372df084a0f2be51d8a243af64dd87cbe0604ca50ed6120ac066ae6406a9ac5a4ef60993475c68a3dae124e10f6d1c4c8adcf05e6c64cee1a0b44e1d1750f3f565daaf98cfaa9b03aaca28ae24b088fc61fdefa90eeac9eaa8907c916b854b066c48f6fcd6da6b9225c0b80567366fdaf246db64b85c7921476e6b38ee1afc527a506a57ba44a03796bf07081ae2ef21434dc3cd31ddbfd223ac20d470b7150c8798303a65c094ff509814f20c9a0aadc51f1b04d0d485cb6d272a6c4626621238e45f7ebe72e906d49c2292db662c89db979118eb065b38146d33e395810d329726ec6a64a34513952bad8f9c49119e9b76fcd9e7a00cb94fb7859eeaf5843a6724f0130cf06f1afa82f7934d15cf7da61a3a22ab97fba2432c9c5f24012d7b12ae34bd0a0dbef6b58c0529b6c2c79183484b678bda2aee8007645ff22c6b44bac2405bbc06c0348159a63e53effc52fad0532d4d8093b68d6bba6a36d28dd62d4d8d47713bbcebada24e7a7a461681773ab2743f50435ffd06a9bdcb7d3e6c53e3c2decd2afb820100fa744b652ea7cdf343689e0c6f3a81ca4beef9b5c8eaf11e403953f825dcd431b6a0251688a949a42f4db0130230ccf2fe4d7b7a5b96cd65f9cf927bf63ab9f06e32c3a6f68d9978c225a76f73e9cdc0c783473278126aa8c6eb2de4ed9a90cfc3a87da85bc90bfcb34431e12380824293ff569cc8ddc812e98f4cdc6c6f8fbc5cec73b297ff0de15b7455b0d1dbc888d7d10ced67430adeadaf0db5d3d5903597d0ce65194d93fbd05177490bc3c689d6d9f5a28f5cc3c611d0abc31e19b6a9687faf6c64d0ac7c4c2ffdc7f9de471534dc4e2e97db874b9b92a345476baea6f23beaa4bcd06e3cca92dc39cf91cafc7bb57d2b6b80d5f76595b0c63eb1c831ee8c25c31a0594ac0f9e244de9895cd019033283d948f7fffffcaa49b365765b3308988139e80cee42bfe6c60a09f2ac0bd17da957df1f7a6e37d28c0156d9bb824b5eaeb254672fe397ffe6069ba8883592e067e5d977e3aaf22a6a9b5adc406f1f0ea04a9148cf18de586241d607dd9786d96be455b21f99296c8ea6a0d333853faaa56ccb59a812910090f64a1b45121a26864f622b4588396751af30b813ddcae20fd2d7b8646403ecf5f2709e4f1a04a1ce1b21551eae3fd26f0013b14b2e1488cb8e9104ce1a44a124e7fbc13f512374076068e9dace7ffd855a6bd9675cac35b8c416e6990f45ab313a8bb808d2450400523519762d2f7ad71e3adfb1c0c11fbce1a6f56e9403efcd54e3fb57e84b5297a8b73a657418a57bb2dc63345e80ff6601522ee2a122b845c6020049cdf5c139a0c67074bf33981f2b412b12cabc88c37c66833b5d6f28adbfffd0ddebf26166c3fa807a956e6a5254b4be7244912f4c99c667d919676a8d02f09ce7e9b911d5516b16fd90c8bb3bd9f253722d14cd31fde9ff593ab727788699a879c6d208a758de348b5ea55006bdb605086ecd71a3ab4f78b44c8f0b8b7eadb47a583151d1d734c1bcf0a40c6ac3046dfe4dafe525e84cb260256e482820134aea575b596ef21a816aeb48bd3a4bc83e3358438b23a122c08b902787fca00a01d99597b52fe27aae4c028ff361f58ee31c8ff6fe29570a1a06e0344940e1dfc6cc5da8864d90eb83c025907b6bf353036cf4652d244920382b8ba9e9925328785a8d5abf94eabe44f8aeb302325bde9c0f582de4db1b3367a8cdbe60b3dde0d94efbce7cb1766d7d97802626c86b0e53f056acd570d08a577f1e448399cb2d0171a5c31e9d387606ae5e0a61b622788b30d02dd099044d7f984a57e960ade0222357524ebd5b88ed9080ccef7a176e265fd9c94bda4c85107f9b11227ceb972f8b10b2d2e2690e0f3f861fb9d73e6148c54c2f480c7f8b099427805d0e8c86a872892a18a5b95ad0d1a2ec4fd9e56277daa13ac90f449d20d87f1ac589d43ea40fcec722dc5595eaf16bed1b2e6f651386262a981960bc11eee1345d775650cf0a3c630939e33b74e56781cabe94455c1c8892b14629278f011167d76f5f0f0f97ee3a1d915fb830547ca1a3c15a9ecfc43b10a77c9ee8eb3edfdb0fec9caee33a948f4f76a0563841e6a1b66365c10978e3c0e963fade24648719745112f30287e2043b540500a62048f2d5dfeaa987a196865c377e45ca741b6e572525eccdb3aced0897211918204ee075c8ec56db2d23c160c568f0e743e3ab618967173419e241e7530b1611897eee17ec3ecd3a16b7053d5a8c96ad26efd48d01d4a461d1c9c667f36ea01bbdcb911d719090af7e8c90afdf5a25a7ce5113fd7354dd662915a97f77e7fce5b89ddaa8020970936c08956656038ef0f9d8b27c1f9548b79ccb533868573fa2fd28c7450df57aa24aba8992ba4148e92a8e448440c34e468dd888f9b40509ccf8e55fc7883270bfc493b30b204551d5d1dad411d6a909458d3a10ddcc15eaab0161303218396e6f4acd203dc1209a28329e7bbdd42bd341905ea2b5e14824b290b5437788c4d7aa0363a7b9fbe695afc0efb371c8cea43636775205f3d6acb9a75bbb51dde56aab911abf94b73c7073f46f457789735b93319d99e55c42ffa8a0b8cdc6b20d8e673654b4b49cc9676089b8da6e9ced05bc94c1f519e44fcf97b20ca41b6903b09aa42b4e55ed7c0dc553d20ef9751e6e90256a046c14aa67e54410b8c85d269add0d934056b41db38e44d598fcbf1862fba70e376de8f0c6afba7e7d14f300045fd999bb18ace3a355e057b5908ccdc964dae44470bb4e17766f8926fba43b6c7d742123675296ef19ae155cbc1c4e824a64c239cee40cb9c1b666330f0f1f57f66a1986482de90d5cffa712f4095357e872473185e892f66f32bf47c37d4cc91de86c5a53b79c08911328a060be8d4b3c9b23f7173fa43b9582aae76f54361b5eb1970abe5a486797caf46efe470721bd51fb1813a7adeb0d783479c5033b6c1c1bfa4526245ef848adbc2b14e4769335ab736f7a39ff9ca77e0ec0da16854c2390895b4d6685ba093bece2aad7ebc8b7297fabb07ab3793f89f8bfbffa3379ee2d0273cf268342bdeb8130698ff38a86a09acec04fc4e8f3f137066c93348610506ff557e3d3ec947c0cde5aceefd4fe4428f92d23e795d23f26111f92d0f1136324dcc34d9e8a037bd54d3b8099a9a0de1a4ebaa731d284cad5b8c547b143fea0b55ec9d4740c1ce950a71d9d96b9b111fdba60d6b856cb2d685c0e2a3e897eace657f7d07ba0a543344b7e46fd2d4d7a827baca83b129d4af86b24fd2410c9027baceda7fade95a40b2974b94c8b6b4c55d694c080bc95131af4c215a2d1fae00b10f05aadb64380555134de0837a2b42779dedc076cfb313b88da01db1bbbb20b6fb6c920f415b55f2be4b6edbb34814cff485122c227ad2d686ced3c1cf9349122fbef4ed0201ef64844a85904820527d3cc7577f80982c74f0fcdf37dcd5710a9d7e9b3bb8f8c5cd1b663250e2fc7479128576638d2fa0f74c83b6932a011472c47fa0fe08072ca91914cdba3b0813613244e7c5fe17616e77cae85cd158b147b97d104580a147c94a6c52c7e99d54cf8604098cdd43fd6fa41bb0fd92f4487df86e90ef4533857faf958faf2c1cb444ee0a5ad44f28be5ba19cb54dec2f6b137248496f6397a5bf1c2ebe570e04d6b9ad39c63ad7f5d7824aa20eb35074a470496ce4e95bf6f54ff028d9168408e0b23cb290d95e133c888298d80a6e00596f2d6a92d206d137dafe15166f69e545416d1841c7379625aaff9fcd233a958daa928c6f4c853b45827f580887a22a94ca8fbd3ca370c9ccf60d0af7e0d9ebd28f90c3dbd3ea0ea7bbafa6dbfe1ccaee8e2411739076471a8aa4d18ebb3a3a51d4acbc490a2c55d916f0d75d041e193c009e108900474c0e99a29709fcda12af87d9b620a38f9921a24e53ffcacad5ff88eb6f3b70f59b7f1ffee6de7fc92430ec2642ec595e6adb69e860fb5335e4441c71364d53c7a0a44e9eed52cdd5434d8978028cd092bddf1c8b255e19e0d79bcf9c262d0934feab44969ffe351de1f1166a45104903dd5bd8c4a3cb7c7f983c8a6ec53c9f04cd4755345d6f4e6832f4c19b75a6b6bd2ba47a341b0961390330afac47ee3cf287e76c6fa44947e2a162eaa4c799cc092d30e227845c967291356420e376671370ec40a0fdd902c4c551b0ef654821ca694d143741979a0707e424f3ac5592d50e78e3cf1f52ccb4418bca5017a1dd4ccefb641932ee6a2274285adbd52cac23a4446db50b4171d90806b4a7f3db3448887cce47b925035fcea6a4c65d503d8ce6bd25f421d6479bab7ee326f334e255d5218c8a845333cd5f55c223d6c7b2912d8ee5e90783ed45b50cb7cee41b7a63e70bdbebd85c8ec55d178bd28000ae6d511e659ab712a12f2416173a6b64bcbb2fdd5c49cec123f4a9daf110bcffb28234c81844dacf9e932197f78d863fa09a2f5ee9a93a949b23c4b19e537c2b5fec44fcccdddf4ae81f8421c86371f4130e8d51e2940a1763fc1899d65d28554f38d41e552ddcdee7445670e06408b535a248ea5b03e426503d0ce938ff499e338c230660424983b14207caac539f9511bff8980d1601fdec265817703b3ffd701278a6a9c5a54115e8a8aa42ca31fb2a25782b4b659119b372e7409874106b197b07c8695f6e7425e57011e3ff2941024bfdfa4e8a6786c1e4e3936c79cfc515c1191de23426d5c0918791927673b7787a85efde6bc542196b4585fed31c7babb784cca7cb0166fa36297185f107e51fbaa868ffc37b3dbe3442a67e4a5bf60120307a8914611f3780b8d8ef1b8b6ed0fa2980990834cdc041f0d07d804f6f947b965a8099a930fffd2e2310f17525234d1f1cd2ea664dfdf6e365bba0e595004329ccc3fa99a4fe86db9e4c1fc4ff42e60cb56b3bf20ad7673feb75a120d89f4adfb408c6e437d6ab93c73f91160ac8ef626f6877e6dacf6d5feb179c0dc9d455e725133d27148e182846a3d6e0beb3c9a4939e8bae029cb131dafc28444b5fe9a16c7ad479a727d289a7319a9f055d4c990eaa01f7dab0c1db8b6dbd4eca568825ad1f09fc39e6611fb1a42812af41714bd6a3d49831f398ce39720ff476c627cc40c5bd1d84b9675b5c2923ea96a8bdf6164e1ab66e4c9b59b9198323fbdda7b02edd2af3ab934f6b4b5344c13336be02a20f446899dfd971e717243de7c40ae9943dda530eb46e9ae5c2de56b22f740babd5a1ab56671d120def348a63e323ad0f4e4c70914cfdc08247a637e3bbcf66025b69a25ca62d747e049bcd7b5d72365d550305a6c61e1a999b5c87ed61fc5b3e7e17a5afbadaf955d2713f90f4af1036ccdf8f60112df5e36403c48a6fa90f74d5a53cdbb5d6e415261238c57c4358964eca15098726c00e45c2298e441f2be77368b74e8bc0dc1b985dd030c21137ca6d9271c6e54bbaafdc78916e14a7c7f1654edf952f9984231bd44cd0cdaacf3785f95bab279bac463a9f6ff84f6d517d2198badeafd54f8ef61a3fb3754498dd7312f694a2adf62255ba3954ff896ecba1876dddf0254eaf13eacb2c33787dbb466c067069f6cdf5613f90fceca8a81b805243e8db1f888cff1d4062d06212b633230582f31a47e9837f0238a3aa34a9ff5df6a7127e4ab84e39b5707b8c2575f33869a4f453bd9ccdf581cb21fa4ca4c10774a674bade4c9fba83dce1ed125c1a8651ea4c67b8bfe6d245a5dd51651862effe715b9d2a4ef162cb1dea46c428abf9e479eb2f804b763711ca1ddb3e20669f311ef8e6840cd6db8883787ea2d31cdf1abe9ac4d518b9a9ba8b2e6f86b7e8cb7d2d6f05022c4f79191800bae8de73a5b4c71d90369209e6a69c313f38cd804f16adaf630ec46a691b239668315cc39c65fc20c2bf1c8d800c5c401815db9e14e083d6ffe8ee51b1f3a5d7e2a350ef37abd92b91165dd238157d36c4969e5d7923fafd800ac4ee29565227615eb62dfaa315cedbe160c8b34c7dc4c3502bb0c161313cf809ccdf9a4d3405f38ebb98bc4842f927cd1151209ab14b9cf644379317b6a990236123777a9fa21dd0a11f81fb7fb01e07592bab9a273c38690ce3a762d17747a3f533acb71e80a71ce23fca78c82a957981c1a96a01cace452b24ba721c04078c7e1f73c1ade7d2792dad2ee4ee2b153373fac6792546e36f10ad7f5601494a510289192bde13702dca1b4beb61d1bd0372b13e85fa13b25310990defac64f6288e87d407de96b88d62e68cc4320d1bdd34969263bbb97bea44eb940a36f580cfbd26a16db86e984e6803dcbaae662a587679188f62a90da52d60c5face8b1eb421489233e27ce914de9bbeb869dbce3c694c3181255fda31b0aa5fc840eb4ed8072b004b03f78ee5cd558d0d766c1630d5884ad257f8c071d5ef5a211e98c175be1488bf314079d6562e976fac393c9f971b202ca0ca9086a3473f6e0baf2081ad6a85e60fda39e639bdef160396b2472a52984179365466183f33327ae73b946a46c116747a2bcc5710a46d7d3e170219c46b974f920e0313a47b9137648121f2ba86a33d7dffac065b4b50de62c0e92c25ebbdea81e48309dbe46890324db3895cf6c262e5b629d800bc7ebfc9a081801f30a954a0492e70e2e1a352c74fcdfb5ca6e5ef1018910d781af119a1c5220edb2b825abd219a73869ff90f0f3429f7b862637f2092e5d3851413ee3cd16cf5f7d928ac6cce21f2c3300396908ff73ed894a1a7d2cd242d932fecfef84b2a44a9ffbfba4580378c18cd46d16cca9ea35a77af148cff451c9498618206887042dc70add9b39e9ab97bb2f7d2f56fd5922efbd44e49e193d4804fab0fe69875d7ebec8c5c6f5d534d71c79ada11f905f79f4a5912cf9a088aa4eab6eadd82682176914489887b84196ba05f85e828b6de71ae7793a150ad3877634f77f45ddbad0d1ba5139f978821ada4bc53f79ff0c00c73fa36c7d8fb9cad4afc74b9855d6a4ba78b535b8cb5c005e58315e79e5bcbde066af6028d9c55e432c116e2fae79f93d48bba830bee7075a983b2da40c1a9a30c4633b52842bc9445444e4bdb629039704e6b95caab218839c8bcb8e9823474c16ca5ef2e26a819452d689ebdd6a99e8121e31a5919c1b455c5c98817c28c7937bd0fb79f4ac9468fc188fd44bfb70137b1bdae4ee944fc0c3c5d8a85b562565faf4f8dae6a95c484a49553967b2537cd62ae310f3e640c0081e626d3f052690d0b0911c6b4a8ce3684c3b512b24eb915d7f579348871198fca8b6703e74f26dbf4b2b32a58c40d2a97d533dc324dc8f4a87cfc42f92d82131b1cf1bf9acbc4ca934d2982f8e0daeeca1d2873689b9f40b612a03bcbe928d333776712039e20ca200bc69bcca2e8fbb3e30c8fb3a84349fdc3864a17b6719578ac8e30f1769b3fcab672bc43152586e5ddd4aa6c0e83bd65e2af861808015cae28e3736fda7a527e75d1979fa2ba5a2bd3b6cf458d6af7c2a3cac4e70b21cb213f997f64348407f8211f96c6a8a9079d20d2a852a0978069d424f634824c23f99ef446ab1750b205b19b571d4bfd42e42c857b4de26577c260ef37c3537f0c4d96b32eb8f351e0226d9d581ec2a87329480f6c14232bd2c86ebf8c9f9192fb614516d98de8b79955ba22b5d7be014c86af5c6a488166de57758904d6a864da132930db9fc062e21c031848b194df96f339bf7bdd1b57f4bac0a7abcdaf1202ab2d4bec76dc9eccc87e5ad50eed130ebe7dfa13b015deb33960c5623dcc9c65e0411b949d3107ab7184bc896e14f0f6c3471a2a11c5b11","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
