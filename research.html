<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98a25eaadb19bdf95f79a293396d54fbbef027034df24259ad3858c19218acd21d82e5cc1c97ca1aff5f8a2d3bb52b96f3c8f1195ab3b389f2c0d75f9434d7c54df8131dde05a1340dd4d7fccb79309652d1cd42053c65646c960aa62fba825199e0681d1fbb52461e50f582ad5c242cd87240fe3218fd505a748c363810668ae2720ef457ff220017952e433779b3229fc49c79f3987d65be239e3f09fe1c151305175f64c718ecb762b75fc214a4c0e9331cad78cb4aabe4f62b8ad4bdec63ddd9dbe7d4c26cd6c96496651661ea7d061d5ae3158e3ae725abe2644bdc2b337be3dfc918b2f51a75bf6ba8af5c90891a72af382551f50d5c3b61f4f0216f22c8b1e6955f5ea738f74a2e18004e2577a3e755012c6c999612dd37845fec33ec484215babd977b03d706cc484f64541f0c2a955b8552d17b299ef307544ba14c00fc95e0a1e6fea98ebed07c2c62ab7dc4e0e66860e1cac24ad4305e4ee424d1aa516fb9bdd19edf11e131b8ea35163fb026e92c89b405abe2f44f6be76abd27a8cc4290d894abae01a8a5f6be6f5998e91c6bede593eaa7dd6b4f8578d43d09407ecd862fc744d012937d5c677dd87aa92948146e23c7403712e62c5a86b0b50cdc0778227561488eca0b2bfc8a620652d1234db829a5eb0b9e608171c0cde4b39f9112b04dbfb355588b82f59467327597cd42c04746d2f79b36256c99f861ab16158549d66ae241a05ac1b000c56a27ac0ad8d24befb366e5b87a9150a3be8801b20d089af34dbab7d0fdedb5b750099f2f3c82347a1af1f7e87979de7cb6dd28d1e1f2b915c4820547c0bdaaef5f8c163e1f27bc527e0a3381a960ced2ee11cdc56b0a001d505663337aea87948a011984bd4f7139bf50ac77c97e659a90e271480e9661b5389d51321dbe3b655554e8b0cb4be950fba5e3937f413e42512780c7536df9fdc08c97a09c198d6a17fee1d3ca7fcf39a3b0dcca2451f1b59e33b4cdd14437833f96073fad17029c56f10441b47529c2c274eff9ccce2c4c2b01a478a13086faaae17c9e7bb665c2171d6da9f3d0893ed99e2509690685faad61c73a3f93cfc1a164217eef10cff8f7d79d9307cfd9f648b7446c4f43df36624af241d2fae8cc29e0cf1c871939281cfd64b2743423cbb7a72f5ff7e0bc03245db87d50d5fb584c9a2e767f5c075760e3bde5fe5afb032ad012b1457aa340d744bec5b6a0e8978f4b1a468c7643410bf32f367c0204a71b98d024fe464a8f025f361ba15e455fe6f1d3f3277467ef5ba325dfcaab95c2733235a90731b588c5717c2b05f487e462bf1a767aabf1f8eb0599034a663ff0f060ed335c29f47c5ced7881554d5c419566fa2c321c7a85c2496a9f9bf3bc6f082b6a1186e0cff26445bb1e086befa8f83ea20729d67bbef149d2600ac15ab61a511f400af89d81ca0fb29a6bf9e0a8c07220e73fff68c2c183abfb8d56122aa1707bff7c040dbe3d8e91307643a00db272a6cfc670422297175227e9fcfc69f97be0723b029d07ba0f228308594d3286fc5df2ddf2d05b24f02ae595dd5cdecdd18130c1d45470a002cf7d517e3eccc1f7d1956058d6c77b3c7457bb1ddaf242961065002885fd1817ef87716c63dc458564eb7b2ac672e27bb93894e6251e5f2c546c495aa97e805e5ced66954c025b4a633387cc4a5f148bf07e66ba2a867759d0cd367ee87819f3e41656ed9775ed83e323a7ad8a04a53ac085e63519bbb0634b07215c3acf1cf72172603892f53a032a67073226c51eafdbe60e5fcd1477016d83c7e0553e333f8f042051b5c86714e8d1d4b55bb19a0fd4e23bb463b7b57b23edb1521f1f9b15c475343af871f5161c5174d1a1285060e24b97fc15993942b741359566d5799470f24dfef0147ca9c9d59cb1b1ca393b4115412735690b20b5e98c7bc9ed46f0b45328dfe91f2051c13917bfb64e069c3a695abe5d065826a1ace43542f21cb1492393c4c0fac17bcef94fccb5d6543853ba6d7547b77836768d1cd19454b7d414013cf5f6d48152c81b595e55dff5755f3a9a68000fa54b431439112f7a1ec98cbde791e39337d98d85f5089ce166874e3caf87e7cb7c59524b6a103a7d8d07583e0aaf1f0917562f2f874e97539c95ce29f78976f64706f428bf836e2d88e7b98432b4d32f7be87b2556a6dca3e03471d6c7d00062bb8402b8d2c71f6520c4600d0220fd57cfd7cad3ee251d72d31a5e75d27c5ec8888b1d2a549e94d58bcd15e91662300181fd7056b2e6e01caf2cfbe5c67e84e107310ae82afbe31e7f955747c951ffb336796ef5d703725de18c400aa5d132100ae0bea281322523711932f9d405bc39f55055dc4d998e2ec07114101cda918f3d74da3d312c33800e01b35c187dac9190d7769cf0fac8cc18676dd847b5dcad9a6fd30d5b21466261784f5a09caf037978e781f4f98ce9bec2ffd81fa97486ebc4350c0bf188937d389373cf31545bed82f6d50420a01f1dc7215cd11e33d959e9f39e82309a8cee700a635edea59dea98639d407220c54fbf97a8785a3faf81b71ec27f81c5505554bb45b819b1fa1ab669693dc68138fd7641bd5c2f866a397efa5c2e709dc5349ffe230283418532e57af63d159ec8fc32f1da8162d2dc2c0be53a7e4e0004d57935390ecd57a4cd80e4d469b7553a843082b8a481a27fdf38a3ae78e0e5fa5b1ff6c86bf3f31b52358bebe8b1c97a6fd807392967860e1e46c61a15cd1036f4f08d6d2ae2a32961bd9fea59d88815cf83ecf0578ddfbc89dc3ed4b77576cd920b2c9bbf7cc3f4cf089e621abed0f209f624604ce6d166ab2faa79638f0dd24b27da97b4f40102130231be0deafaf3fe22bd2f56871dc3d99a7db4942f367746d8e537c9f4c0d1c64aaa33803643645b3018005a5329d8aea67f8348333f6078967f6bb41311b156ab3cb00cf408ae694eadc1e128bedb50a8cab138a8dffd3caa1289762d0bdf6f69f00e8f3251e76c92f62c0f80079d3b839db5f632c40d64265cce8bbae04fe9c3f1402f88861947e492e50961c29d4ff3e9f42e888c45e747875f2da274702ef45e75b28fd88bd3dc140fcaf9f1b65bb28641cc1bbf193bc464c17c5badc5930793679c0c7c38ed1b9066954f87340e9ebbdb802f3091cbae0029eebe5eace29df3a57ec71ddbfd34a51d7d045ed55bd69a344c5e8eeeff241bdea1446b1ebc8457d196c9b1ac5f2da0d9cc67858514ba65a894a62683b379d168135463bc516e42e1d3ed9c8488a226bbe80c8bf73a24733c0a8a88d7295db36dc85714c564ca0414ad77c01416746ecc22ba9b3f1a485817c0c1a7d2e511ddf570ee981e9ba143a6230f1af6cdd8e7b22187c66758f016c6ca313572ef5ada6e486a92a8070a518741ac40a90b2d9e2540dca1c170935493d5e67e8fa3974b53a1c6c7ae139617c35348512333dd93b055e2f5b836639ffe5bb09a105090b99d6680f28aea5e0133a7e42483053e0740124b3a829e1046e4184feafe28b2df5b34b8787c4241415841f73ebaba57e6107ce878086601f62894ab341746de8beb7c85c10ef9412302cc43e6e1d153978a41bcf0f8bf568f58decd393d7edd9f63152cc14872e1c1d0956bbb4772d00f0f85b88862999b2f39849704299bd1da90c087181e4ed551ebe52b1efdcb97e621fd69058980de57471c49efc4c328de08adc0378abc07bae59cc0f96c31fdea070ba4d93316eca613025a811993c787ee81956d984e7358d9b4c40349e2761c53d84f2dac42917b91256309b1490a5427702833906615b269587e67880d1fea3ee0c8a06c7bfab9d8574fb1eaca0032e09af3991be8a31eefaa3068d4dfcd05f59f8402b3262b71ae0926eaa05ca6c3d4ea81632cfd16419318631a087873499f0530ff3efa5d82277f9d6b19415f1360103596e225a1d261596965add701ffeaee0ed6a9bec3e67408a61bb867527299156f2e5d6dbfcda9f72d5e638380161c1b11e7ad5259edfc41d99bc241e3fa50e767409795dbe1e63834f7c1118a2fc8c6575afcfeade2a6c6cb1021b78bc1b1765e1c27b985f2e390255fed4e4e497b01bc6481a7af773fa27b5686da58e28109bee3cc7f620768b33891eccfb236a28a9ca24942090b008ec1ec2c2cfdbade28e3b5356dc9d7203ce3fe0d4746194c933ba7df12f8d18311024efa9e2accc3580e0d5f51e25ebeb131d3fa7aee50c90a7d6d8b958d481809f30369b23e9049a221b71762ef42b98e6185f0f198a695d9a6d4452c83eef99ed157190bc18c880dc1c832b8c0935221294cffd5e8f1b59b545c91af8c0b219fca761cb591d7cd3b7ba65bb77bb439f472553a73bfd0f7affd25f3748d64473333ec77121abd81508b16c5968e80b336f69ef30ecd148101db41d1db4e8ae13bc6bb9e5f56e8571e14c5247dbff89b936de52eae91afbd4300ff10722ed5524fcd58297edcedbb4a5505c439ef8b5c246d7ff33b49799ae9762855f057481d6913a83da40a3577e57b5889c6c37eb5252dcfc7e9f67e5e05ffa55ec4c261311172a3ae67cf48216f5554de8f136bd1db6ffbf3717ee0addd50979bfbf97d8e940980886801a15c46168a302046575bd980bad4a4b8b401437743d2666936c0bfacf47fde511df1ef0d9eb69c3e376db849d8125d9d5ce9d526c613ed2bd06420ae4d48e3cfcf01eb2eff548a9561482ecdb54043d59f9bd6e5b7d7180bac89ebbf218cc49b9728764568ee505a0b04663abf6038346f1c15fa2e45fb585e2fa641ca9307f7e5f6a2399a14e536878fcc24ba9dd59bb8dc73bb47ad921d66706d9343b6bf60f362e43bd9a6d2938d4396b0989df217839a80f89a38c05ac3d6c5f2acc0300d9ac3dbf87ce142b383cdfb7d1e86f783c590fa4c65fe3c6d3e810396c85deda7069855c53524d6a6cefa3bba0c0e94f032854da7b82f7e820b22888a28a23ab0e01b0d16bc7d5d4b8694317be9f00fc2d628c29133f1a9b2583e6df40c9b613dc35e92498bd69b550f12e224a12d4c7a4f6349f58bf03c5357c8e5a3bc4cd70acc25a1a6559e96c5b3f0f020c314a7ba59795cdf15e220e62d9ffcba91bb18e7633311d061d02c69359be385ed2fad1ab92c55f235b57bc7c272cee111b6710eb2d02d53b6d038b7e98c8f8f1e72de6fbe2bd24ad3cabeb9cd4afc4123d68575a814dd46de0096b86443252a6bb0653482861f10cf56b54be6d104a42af3d15acc0aaba6adebc54b7d8da14df36e1239c5692f1326fdd1bce5f40f0c094f33228db2c66c35d4f317300cc904bb4584fe96cfcb5e9fb4c6f01e6dc39bf4d6be4f0775a7b4cb04a16b24a05ef7481dd69e17d5d592ed7e069153d1af5591764613f22b260f88de92f2a80d2e7dd5adc850097a75b47f147f60cde1bce9ac73f38ae543d17ef5aeec66f070ee13edbdf2bde6d0515bb35d1ec2f39c45f8482b393b5fa6eaa0c2cc298f1343ad2f548d8019cf090de94b1930599ba404a4f3e0c3b7fa722daf01eef02fbc5c60fa32ab67937a40869f016be0d508ffc27f96ab20b57751987fb2073aeaf50572e5d3903221fa11d512104cdcc061ddf81c43e52eea4736fa03c94ca8f3d15d2fc3e06104a65a056b4437d49a8e7cb15a1cf22651b5b9573d0fede3c01ba5c3e4d50200e52e2c27ee1a33cb9566497ca37f6433f5463812bedc84de686d1eeafa9ae3c2ecef83ad66503c07f298931419e1687c58e5f510a234393f1a750bbef5e6752d59eb2edd487aae6fff6b177488df33848daa9fbb1093d3e3ddc4aa78a711e8f7808b7076b251f092f11c984fcff37ddc437bf5e3cff3aab18c8fbd1d99f46f0ba1b49fd7c17935e183d89a66ed4d0fdf88d893db6c1aef1e488c8f03470e005cc460dfc453a80d390406d4ec04b497ba0141f7f7b10993fc1dd35c4118cf2f4641fa73c2c60cdf6a30e896b909b02ee6f8ba7ec9bc7c61d495c20874185b6f7e4add9edd6dfa61a1bb5ebb7d0daac1433d51f69016429ba7511d43e25a29bf583196d4f514a38172d05de5e72a94fbc53e825d3b72499db344c8fc154285ec4636491ca2a03058968dc749bfd89420c92dcf870fed1305e2e6e7c95525e63325d9afa65a34b26aa677470edb3d3d0b34ce3cdd2095c7b91bdb42c5b321acb94671f6668f90f627c61d39c32828fb87e92ffba45a47c169d80648da9aeceb0feac0579d6280913fea87e1bf382aba4ee8332adb3c0b7cece01d770aa6ec9f5637cfd44c6890a62cd3dd22c20bb0b72f5b3b09ed1318ec77b380804f6eb5a8a41152ce35e1a6b0d0a24ce69ae0430993b37d3b63e4a881448503f3bd9df363ebe6ce07d9a78557b3c93f06ce28d0cf81adbab757e2636d9e5c9b7560b07484b19059516aeec7ca77c32a523b404dc82ccab0aa7a90df9b02c0de67695e3e21217b462b380fb70f15ec33a88d4811ddce35366b690e31ca6a55b0cb6eb9a8404ce365487471275ade4f222d2eab78878b60d1e08bc62b27deb12998d9d9709a28ae74e8c02355c621a9f81396c656a0a77f08f02c424e6b3c027a43415b0ac1c76526c1cad670c9642f56a9e570b3265a153fa88fabbe874e6b231d0cacc02e99085e6769f7b84173e51c45cc3393ee387ecd99b1e1a0f10d2fd56e9623174f990f3d70ab77d2fec7ead8ca732183203147b36a1e85db8b16877bb038775675a9963ba933b12d0176ad63d2fac472cb404f9b668e2ec68f212818d585e0ca9a79614ab49957d9d322a1a491b9994d425d240453c1879c1a505a9b477ea433f480f6ce93a1b9ad640a2116504128bf20fc4187eecef3908a89b6bdf8d6fd613b954bfff3fd73fab1a0f353319c34089ab6c43e20c145bed74edcd28da38647de2313b2267dac758f1ffdbd962ef5cb1465abf88aaf0146761f0a8fd96cbb33cc0b3b1b9945b1153a52e098273001e89ad6d77d5c3a53dbb966c95a19e318b53adde90115c5bb1df3a0b350f04f147e641bbbf59b303511813827ecd12e337e22643b0ef11c9d845faacb5cc5bccfad3630f30b837274c874b68db23dcfbefcfd7b72181cbd6b0aea15221c881115b745e17ba00601cd286c50ece2ab37a06b6c9a5f3c829046157d89cb8e959fe62d970988b3ca90a425d551bc2e4a1359dd163077f8fca308f4a4daa53c8f1fb2b213da26cd3f6587a6fe860623119ee1fb1f81fb46059025f82622853f2869459a6890190a289689d7c89a5e37518913ccab69ad22288796ea57ddbb95f7f28ed76e1562d9d9ff8280979c8e7cbff92326340a529395ba4d2a044817958a22220ba5826f365c00dd84a92b6064013da6175b5c44f5c5db2fdbb55f2199896ad5b19dcd9ef5711a255e1affeaa4177af014da7c8e298912afd1136c0a137df821df7966863a1c9d31410cc5565291a1810df77dd585f9bf63459ac3fef728908594bf9f91e438e3ad07c0d222e160f2d7eadc6412870686aba599dd4b02c25a417cc537c67eb7aeb337f3b618309681316a77053c370dfd24ec0aa5f371add419fe036143142755151f9b1929d2276d5746dbc03a7f6b9bab8d922953ba81b43e10e85e767a71c68f001ce11812993cb687c3bf23914388021b8c510c413d0565b96a0686956702e1a9a18cbf523ba04f0736640c5264df6eddaf6464bc1f67d2c61d8eacf4a4aef2a9f2f80164acb6763c6af635ebefcfe8139914d997307deecc1e530f84ae5e5c41529f3408ccfab352a01cf25429565572acc0906fb5b3fcb63919542ee218f1f9c83299c48c9e85797816c4ff9137bf81abfaddd53a77ad92245c328974b134aebd5ad4fa3d12dd30c3fc186c0dd502f63fc749f8f31879e1a7fe42ad2b4006e9bc43c03db9c379644a0850f857f370bbab1232d49d8333751a2d13dc8ef567e9e246765501e083a3c0c3ac2f4c6ff6f3a315ef84b8195908cc3ced4f556ade1172e027cdf61e5a7dae4d6341886c8c7f9367cb23909c65a4ce43c25bbfa5ba4140af7bbd2e96aa566817b43e4b208ea7769a3cf568b31f30123d9185c78c7a6adf080218e2cf33cc7b169997b54d20933d4a488b7aa585748fa950061bf87b886b44cd2e83acfae8e1a4ea3a083aa42e495b7ccc1d3032ee0d70fda333675a2637175357968eaeae82633ececfb43dd1c5a16712ea50156e3341dd264d416d76eb0757f358aca9841f4f01e0caf4b2c7a0842c1a58c7c594fc9d16a7c6a6a336afeb01e9c1b78b4567ec2b437ad7a47d7718b4236378ef6f702c47be47d8b72396fd6752c0079a365e81fb8c38105acf8819a54b83b48c1eb920e16e34000d58e255d501e81170759e93b16727fff7cf94f477e02d2ad28ffa64ee11f350e333a318bc1356f76f652817fe5a7e6cfe568ab544c08e17815614658046291e321ac9c8550e456cdd38112c4020b30c8cc69a9f90e336685efd53e70e9ba56b334f3dedd9d01338800152ae9d886e4980d453ef5dc889e6513175eca436aeb9c5e2d2a4db8be369c675c03a287ce67441d8ea696a73252c3fc84030c1d2df016b2c8d41fa95672dc5c80eeaab2e0770ebe1c621cfdbd89e9a84fdc87312280544a538569ff03542b94c083798273158004838e040abac98abcb1ccd607a8966e290c7df9d3b2a759b95d52ab1fe52c8b09e188de62d41bb9e0a63c60ff2cd720d3c63f6f9bc8dadfe16d4c6cae510e9f80a1cde49569f9b65e1859571f1846389dd16a6626e3e054fa5c1ded5695b8b207955e9db4941a49ab9078ff846889dd7c7033e045ad72cf8677f4c011c18246f07d256bdd204605970a68c6d07fbbaae65e3a996bc4758302858ee7948c5026b631df26c657a1e31f4c575474247554c120a231b89a7b71783df1c66cc38355a03fd5f452b352851b4dfab35630d622f336e1e239dd109d7307a5b047303cd97f061ee28cc63913da9b334dc4cf82734c0f1efd827a58db43631609e7af6dbea7e9d2c4f832f12a72c05ea58900a4d53faff8b892a2ef2c62cc37b175b36c4c20c1c2409265d69e9255e01b64932e25ed12fbf7b90943ae504e2cdaa47e2a4bcc037ba2c0074f7064e68e39f5bf688d358fb76b1317878084b5dda21d230555d4a4f6db31ee7fd0de8970e0e9a193903a66c3823bbdb9e3785364ce8a21cc0e75f9300feb16b4572ab86d94db845e501f16a6b08c816bb267aa0f08cd21d7973229e3a32d03fb53f059cb1eb6dac6152837b8e5ce189dfae05135f4455f1d12a9a4abb9fe68694b13597c9ab0ef938c85c7374b09e664a1b023a85ded31315af1bb18fdf8e7ffc95e62b2c3405f315e487e35a9fea03161596683e7bf865bc5e55148ab4f9060c11a258d998bf951dd6e292f16cf4b7515b4a0ce29542c2f7752bbe5f8c9226989011b264aa5323e2124a6c7c634f33fde74db8eb073db4f603c98de4a63a9ce68bed85ddd8d2938d73c02f87c733dd9c69abe98898f445ab650b244d97f8db12e504badc6d7b822281c611d2f1b30912f19ed8fb000eaf04eafb05458d6d58a4880182d5e8eb119e423815d0ea200f57003e921b996325bd1c84eb5720b9ea2b4271d4a20bf63d93582bf804cfedc85fb05a1272781f75f86513f7eb14cc224a626d9f118cc6757ee8189dceb129b058ea42310227f9fc4781d3a92052bb3832e598ea27f20c4b227264500e2d6c6cf95fa151f7d2b18f8e33113e314ed83ce0937b22c4ef85e35567df2cf68499fc73fa88bc89c585bddf0ac495087383f0daee59ca3635a92efce7931719d40e2e8d11bc171978a7652e10d49de097e60964362078d6bdc5dac757aec0c6e3ff1ea0e95a4a62b9a4aac2c00bc95a8d7d5f1532bc9e3bc84b4af3890bec2c43f5b77c6d3562bf0d2536e3a81420750826155002999a6657ec4991e11d62e6e09a0c5d1c38c6a0d48adb671555d7686f8114b5d647ac49a38f4714bf28e1450a28387289b33320280a23c72bea34b8fddc98f2fe474a1e5123d36e0ff756058edcaf97b7a111b9c47fda0f3c4e85d48c4f4ab341aa0315e5fb1375c19be31d34ddad6ac4425624d667e0332f880c822d5a247d88d73a6d2b11d2caf9e495da705c097af6c3705f2c33febd3b064b07839eda09d120375ae7c22afe7400081e99341b91c26cc790fdfa1456e868e8ee68eb4993978d1b85e98db0dc80e1ab030817e8255dcacad7b240ec33c95192dbbf956a833246b32fb5d08151ff7fbd9fd1e724c8ded9f63b9bdc719fe45d84e2f15ea3c93f18a9f302c378bdaac838990ff1000caa37b63c854b1fb4907e38e418452600de3abbbf32ac0832c3f2ed7573444b21d3b33dce5f9510cb66b11dd818f9d7c9d9eaea0c3b412edd825dd576e5cc3c601f40f34515557c4b73e115def9c417f1736b2e00ddeb71b25bfd60a0c1a73aaeb1f489a09e0f0b1e495f6b0864aaa6febba474d9f3a4bec3748c09299686e0ab93d8ccf2c7a26b9d3145450b33b7327c32cb492a4241ff78ffc8b047d77e811d740e2ef020ff12948ed0f682cbee90b47c874de98327018628eaee38b8f96bdb1afa3fbb54225db21b645fdb4d8445b76a94c0d198217eab64f3f43c96ed97bd8ccc28de03c412cff4c5c430a4ae1b77f98d47d010a0258942b28d9afd3cf3669bedc522ca2ae3a914327d3f83d3cb72a0d2d5a600cc72fa5cf8ed7304ad1003ff4989a5feb51674c58e78996b430328313168cbf298b17dfe62a071a9e01cf4fb49448a6fa9c29ee4dc9c350b16234855c6ccb9cdce4ca1a9b57e0baf87b3e59b080bcb6a8b0af4ca6941be2b2b75389abb0c5af2e376483ae6d44e8385927df656982964a79c973f0c64bcbf6c4d51a1c28510dae66cae6676ad1a737042b39d21e0deced781cfd7e63b9932821e146d96fa8a8ce78e9121e48aaa357882e0be080748b3fc485a86136e7d496cc543641762f9d02f6cb2052d1c45d7d837753b007375afc5e0afdb22dafe55ff937dd0d7b657bc1812fdc84f68e8447d66eccef501f823b47a36578e75da6b38f05b58305ef7a3eda93c467657787c6fa7f4e9694ee936f387114c2cc765d9b446cfffb8eae421bb3b660fff2f4ce272af0a98b3c9768bb61df8253f23da27cff36fa03e8b0c2f0666aa8d4bcce2771ddcc6a12ed1091826f28edca08cfb48966fa6429a3550f1c6087390798a4c463c81d1ed559404f9ee84dd7e119a19171f2a4ca2358fd29936903e27146ed6aa855cdc6e6d70edb8516e2aae4812eea9c3294ffc0d954cda30da7cdb83540300b17fbdeca9edb8229e6cc0d502b75361cfa01190774a77692f524d3371e36389c1d5cd72aa52cd0e755d6255a65b582695461e9d701a4c59408f5e93d992fd4015a1736aa893298a44e2dfb3f6b1551f5be50c57bdd4c325b9ba21e0e10d9c4fc93695187a77aec514e85f9fc33fbb47a6dc16c8d65de3df96081cef27377dd72a08cbb2580f8ba5759e4f878489bba6ff93fbf9063a3f58b53971d67b0ca4b9ae143ddf3caed6f658ca1318a88287fc898a355bb3a8c1a3b6c06129e774d0b20675b9aeb69ef6cba2e5f7d6bde8a0d11b74ca45edcaa2f684c887cb37eeec17e371537c5552bc7436fc619a461b7f486982d561dce72e9745fb3fe90fdfb99d9a288c8a44798f147741953f9936bf3ee2a1b17c60df42cffad93a9c19d792885292b509565bdae5f01f388cab17607a9ef50913fac0e7d553deaa8620e563a4b2f51c34029546bd3889ae5d65c0b471a5cdcce93e01306f3d30551673fc73e0b75633ebca433fc1a15b63b2be4c2d72320f4e48b1fce614d5fa91d9d2067e244bef518bafdf68ac3c8af9428cd4cef47d15f97fd92829c72e29f7b2f4a725f02df451b2dd34ae7dc2a8cd74a19a852969a63bb0997d8a5ab02cac3d872dd068192f355b8c236094403052a2f48e61310c115e1d6b7547c838d76e575cf213f51e73c569a5cc789c6e7b870b52423e966d134cc70c24dfa8835d0a979e259a71d51919526d01641ab56e7dab522deff0dbf37e8e8f4cf9d476a3bb22172faf66f3e0824e77b442e5ac15e6083fbe7b534bc2eb78f34edc00a6257f56b5bb1fec84e0978e7af9189b70f320f9d8504a554c209df74985a80e0217dd4db2c4d4c8c390b377d3ed5d1d24933f1c25c55707074af777fd3b9812a68a72c449b6daec9cc0a2179218485edeb8b8989b1d23a54ea3f06138fe3258ab5eda62c756e605427e2d2ec795e4c19826f89c6c361344bcc509dc754ecc49b9c557c11d559adc666ea7cfa1fb7bbe67a1e5d834e538c7fa16b9fd94ad470a721074219e71a8dcb2811f864c0ab0059da573d8ff642439480f2d6a4f3649514d8167e4720c6afd9be9b4e32001ada6dd60bc7aa5b6e350bcbc8cc2b06b0081d8133405baedfb8464924659c3ec8640833271047406675e3d71bcdae024ce91db866a7e970b9c2891bccf27418b0de547ce496ceccf7809623dc3783a9250a25271b0fd907b68cd28b274fae952dc12d0d1bd90ae51015b9d022f6d97711d3455e2af23b4093d25dfba89fe3f6cb4aee7b2f248640d5f36b2f9ffba4cb7c3a7f45ca434a41f79a6451643fd3b7af663937dc6606caec214bcb5fe9f18f0c0a6b2ec9fc70ebb47a047777b3c472b13dfec0df1f1d90b6ffe4e55268fdba111a92dc28ce2a21c7f997d699bf6f759792f63b76e4440fa56a96af9a1b09af71bc56b338cddebc474819c43ade84ce558d2bc2e8708f3d186836c19f67aec7927d10b94de6cf785b73d3f282174c2bb7a56d8770c615c6dd5a2819c92099f6400dfbe459fc6cbf6109d124ff934e4e474a27931eb9c4b9f281f42cefb27fb67d90d54fa27ccbb898c28b3bf8154fd520c88fd7b5ba44196a80de7940c01379bb7805cfacb124a3352cad1d07cc7ceb0d096c8fb37789865fb68024192ab34720b6733dccf284f9ebcc2ebcd6e18bef72abbccc48eb9b46464c1990b62496e9900c21803a84e3c63d54a627c04e77441c898f98f5c0d2550c86b5f6c337b99b3e91664f11c202a0d58dfd9a2a5aa0d05bc3e3ade23d65120955be3b4019df89781d192d0e1d9ad1c7f3fc0b6da3c2b9f13474a71c29cef850efed0a81879e234955d99a051b4c234a8a3d68bf471de1ad4df37437fce78c74e90b0fbae157b791df6ad4b564ec385233f9f54c8828f0177450a1e19d5af1bdba8318b0d7cb206a2666a3a975b203f8574fbfc52b2f59c67f67ce09fceca6356fda48756db48266d817d18b03ea27fbada04da133457361684106cdf9382533cc15e3b451490849f0703938a570c731fb7c28f0a62250b71e993f06c01bb8037aad83e7c4f9e00443a60fd9a3fd7442ab88d038d4e74661ef3def076a8f31da54cdb1b65028a588b334990c9d9af5cc5cb5abea8671600b820085c80dbf313cd2010b54de935940d53ef2e590bd5bae96f6ca0c0f45385db4bc1109756dc3569249bfe90d84dc962f37a78bc14a51583772f3f223739fe16c59dcd9b3dd3d7b88a4ce3b00d00e76020aa048a071ac297fd93a56d2e10e6050c4f6e5cc38e1039eebe426b64871105c3c4e3c0d8aeca18a639c6e675dafa3dde45068f86d9535a99c00d7113024a528c3ad0fd28185ca4b815f067d353ae126601fa73e4aedeb1bca5be0760ddf07594919306620db60602f544187ece09889c7fa74e3c61e8ef48abcf10c042537e8ea379faadc7a4e3b6b63045fdb3ef88e5daf358e3ba6288829fc0cba8fa5077f8c933f9669137831625145d3ad295208917a0825936c73856a87f4957d3a61eeac80beaea5f5299cd3803e036282fd2ec053978eabf206d419aa8f1aaf9587cd228cde3fa32463568cfa36b02be359af1e6a42a683e5a69cf90b08f4377425ffe9bbfb35985c59423096c1aa8db63ec74ed555ec171e9aeac093fc33f6fad51dd01cf469dd24ff2dd451e199b72aa73d68498b3f300b54137e6399ff83a051208a0357a01164f95fbf4adecfdd8c8ab6438a01c9999a48bc4970732a983ec6e58973b0cc26d24f116f81d54c4ecc395a659a5d0183be29a19acdd05f086df75009546ba0ef7c58377acc894db2b834b3480ff5eb73ca5f50920e902fca6d8dd8ea5479ba235adbd05b1edaa9252459bf47b156842fd2c30972397992beeb3407d75e2b47e63cf2b7bb2d4328d125284b45ded4d22aa911ec9316e8ccda7e5cac98fc4a61d67eeacea23604a265681b8bddd4c0e5b1a5b7191e31d9f59d4ad6716474109b7dd78497018fc89cc6114d2a33e833b10a571425a299613ac9b4379dcaedfa290be8aa5ad0c8e62785f5c158b845d2cfd19bdbd149aea9cfd6a019a2a1b4eb3e6a39e48000b74e0e22b156070c2d05bbbbf86f2f2bdd8905909c8e098823a25f52c4f6bfe0f07473ffd53a1e608d27234e719960bccee3b3cad8d21785e288c8df5297b9f9ed1d8dc9c76babeb95c3e357315144dc17d9cbbb581bc872c1d51a61938124c7247550d715f4a91727a98aa0740789fcd65136c333e7d2bc3b25b43ba357988aa55fb9f54cf51cce1c5434f1769a9eb75e0cbf093d99bf0dc48857638ae5ce3c1ec555f05566a595c37663a558f496ba02353a293aa9a8ef0370154bcf9a8683786985c26cca8fed25eb5e338681d92c401926d9eec2da22aebc83a818d6c0f653f4cd647e8e7db7f43ec8a10c366955f1174e4cc6304f63abc669a74ae31c3455f5b6c66093e98767cfdc30c38cf5ddf744096621dfdef5c302fe5c60854f79eb6d18d8265709a5eb3ce7f95e403f64a63e93109d5d57029b01d0f04015e5a8a245643ee813318e5de05d8ff071f49c8b3af516798712e83061d81430346717fa4a8055a377c576d0ab1d9b2ec66ce82840fe2b75f5a4f0b1ba8c1a0c49d501d1548e0767e31e11c352874ef6b287300a3ee299af392dec98f57704bfaf12240fdb4f077f5e6bbc52701b1f328be92eadd1092d08afb1d633d9f4b493d2439feef943e84e4b29f7f99be727111900e3acf8f3d9235880b3ce6ae9ba9cd57a3fd79803b07b977fc3860a2c179a2322e0fbf6195f17d2b50f0ae91dda42a06c1307037727c05d2a669e11dda7d4c28304bf2adb010026afea4ad838d2e56d627385a20005df5da30128c4a9a157416779f3643e5fcfefdad289583b6b7a7da3a39ebcf69358b5359e44c2b7af4597b5e7ec711002af600815ed9acbd051a404e20b771781fc57147e17a6c0506dce1f8c1d041f89485cb25a125000c2166f369d7e3ed0a91291ef138c76047b02fe2e6a5d4a92cba2007368d9e59e12ce6039d81b9965cb395bf93ba7179feab32e418cfa2abdd686e42ea051","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
