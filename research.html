<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dfd8a5b5c594eaaf07806e5f0cfa5b4957b4bb10756823b930c810630385ea47127669f69a171a427b6bca60ca4d3b622119ac8789268539c7b018d20df920ae52fa12e8c682a7c616d0158cb1870ff04471e9ba75240f97cba8ce8c14ab3fb82aef601186fcddc64ada16900ff28a375a60302ea728d64d86ca1f21eec259b33979f09f29f2b413e24b1ade189a465b70c68293d3ba0386ce73073874e03525b799398bea411853c043ea635ac1c7e9a3116cb01f6f43b8d3fa8c084cf42453e17c9c372b2620c2b2ece0f3daa7aaf1cad6e8adb234e029062012dce74d9ed33590f6887c321f6ff61bcaa848f0c565bea2e6a0dd60ea7b672ee302728a954a5aaed07a760b473159b3274e032b58dd619a5b2b32194eb9664aadc0876d79d1f4a035b827f89ab75927b64f28e1b931cbf8ff14c339d3c971c116f2b4f2d4197bcb4de181433d9fff1a15e5679a948cfd293ad689febf9a1f4b8a20fa2effbebec6c0aead9887a48f9a6973818a33b564999e70b6c2b6f3b8822b8e15da5746a964ef3b2581eb8842ee0d37e90340b70b8da03cb86feb50ff914ba8d986107d3474ca83f0187114e63fa24a3259b529c19fb2fb5507c107961dbcb781652ddfd285051244435cddb3f15deb59f242333e9c1fdbe5381e87839f31f83067fd5b2d28c6542cb2b3fdfceea781c843afc477b5f93a726d3a3933249eff09231af37f0a0d444e54d6934ea522ed2f55dd9d9f3a841309f3d48ef4fcb3c076be4b0b5bbd7a4705ba55504ca76795ee5e9727a6274438fb438ff215414f8fc31df342a07bfa09574878787e733963b8130b57cd7c86020a6d71ec75cf50bbaa77e8bb6eb2f5de6394a8e94256209bf202494c0710b68915314be55f0bb178ad4913d74f6116fce3285b8dfe695c60c02e7c37b004e3db66c63c8a6a02d7c2f8152fea2e0c90353a1c8a2bd9e8a2704a6b587725071bb943d3ea1eee92e564052506d3ac5fcf8a462dc24928c2e85187a074bf5b4a0dbdba9c708779059b411f7b06951d4a9f3d4d28537846672c452fb03ba5d1a09667648a54f30570a4f4e90cde7bf650286cea04bfd1642f7be09f3bf16a0d9ce5b05c489b3d3526dbfacda299d738a465d4488894bc7b19fcd52dca27ae7c688bb0cc02e1d015ce7feb65bde1eabad50709b4a4669e12bfc17de8386ad2e2ecf89c27f3330761c231c816f66641cb230e3769cf34d1433f307c293600b230e1e3c3c985c3ca2b19a18bcbb3e03ddf4b1c00bf5c744518cb9ff979eaccd7ae6eae14b58ecf78a71ed5aff690601dad3303d84cf0457b77c03948899b93177a27554e490bc64a8b3269b55d3a20524d70e97ede640a9e7b1a8a4b0958c7a883f38b3b39c859ce2f3d3a4811fd388de76b10ee432ae125e171c7fe354b47440a5455a29cb9c7401993eb0941bf6729daac106a6df2b4cec0922a9c2c22c011dab7b264f1628ea573a64c39e0882af4c88f7c68dec1f1522d6c907b77b4473f537f364ddb459b3eae1633d66f9f0d1ab78fe65fcc0eee2930567a8b53b33ba60784d2998bd80032ff7d99d469624b25cd4be80c345e65622a318f69f5f32d4da2781916bae8573f74ee5655c1eae11900e17ffd07173c6f02539df1ec4f5c81393be7d5e9f05573a6f4de6edd755c044ecebf724dcfcf21dee2ed19b8e595f33b96f79a82387faa01bdd6e5f244b3f296f7fec94e0c3b9dca9caaa694fdb2adf147cbf648e45ac2d8df4153eb2097d8df05b6704b60a978b20fd2496d6b7d183158b8f950c0e9a9e1eee28cd011db7945351109e8d604aa9f74eee325f4e799f84a489366a78223ea38f44a515e34effedf2f0f351b0ca9a3a2e0f3cf77f1c5d1eeb2f2d62c58c1fdb383db5849dd61cdef8dde80de3cb484eefc996b1fa02df6a22a93e21c45fef732353e4481ddd5599d4743809b4a3830cb4ea6e2e99bc57df6afb55519fb8a346123274dd44fc1c88a0eabc15556fd28470c7d085f280a4fb2680a59c94664ddd8b5ccc1d30ad98df0233bbe8564e1b38c410de25d2a3b4c9efde6c4171f3665c2b4507fe03fe5c3b9a0aef85b9235d995fc19d322cf62bbd5f70bc638aa66df0777d9925b77a4e967246ff209899ed3c46d08aa31a6357c9f85d5d801cca176c5f6d1fe30d7b2d2a94f1987a589d450ed5ccdd5faef866b1950120f3408bd7ea19af4aee9805525594a86715db1de6d1a2f990a8d84d59d346715a01b0a5cfce594a5e940467691fe5b65129fd3501a3eaeeb646cb91e14fad7d98cfd12857655d8596ad5807cc25580fd3c95b235ce629fbf2a0f06e310157b1d1f60d1da3d54e595d4b51ac27f6044854864fdcb32abd37a5fac49d0654af4af74d99dda034e843ae992b5f0d3ddeadc57392fe0dc51966f251e5675891ca7e6c3571bdbb90a521f780d1e25d16de959a013c694ee17139e00049611a63f07d1a9b3ac8cc92e0e3e1c2eaa0c41b29343c4c6292f932dc9a145bf08e7610dc9ad1dbb9bded4295ef49a00f33f6773f7a65667a0110ac19aefe94ed5a6ccfff204dba9c2a2b3d5bacad2457ff59117020f4797f6b7ee49635ccc8cba9392e7d2954425a9b682106a784a191f3b84a2a9e7e195fcef3151d21f895c1b356062b5703c6c51d62eaf218e07d1fa97ab9fd034b1b4ba08008f2ba9b82e8b83a1ce01ad787c659a9617e2547132f1f463c07a566fb9d286b1e2c359956680dbaa0daaf02ca2a5f078538ea2067f0e42feb6447b3de5ef8a7e7677440b9338bec33e66db4655a23c704a5915b699c6066f81b66c67d26dbefa6a01e517e86abfeeafa2b8dbb02a93ac49de44fc1cd1fb9ca884322eebef39c8994762baee23c537d867dcce886a3a8de566942ade87233c8c448bb97900f6a17d74419e1e4e10302e9c9c4d5fc100ec9a252ce73c2d28627e6655bed56db1823eacd7bbbd56450a3f17931d1220d4d09b30acf81f1805969f40b5441e6791229ffab32db8d5e31fe7fc9edc599be537272de1f2a1d59cf2590b26b7d81af78218f994c65c2ffd1090162b7baef94dbc427b6979bb71b6ed8a5ef22d58c94350db59bd5e774b72750c5f89c86cce81011b2546addcdada23d2125bfc07757433848d020b130390158ec6c53157e188813cef7b550af252c2d4f2af42fb62084daf700458438f12d4dd28cf296fa13f1c2d9d0af7be2b4bceb57f765d33aa90c2b283fe6fd052373029f1c22f63112ce14e84ec02272203cd3674b5b36cf3c18cc9c7f796243eb01cab1e2658d0dee8caa0887bb4a763403171591bd7344408241707562a8fccd707557fd8bcc2bfe6205f17ac80f4e0caf5d8ede3f2cf891977a5f83c671e857749ef9642c1504903f706f83b3ee7a747f698bd90f9899fb03db815ad65aadaf2311dbd6cc5cce454c54410047a144fec480f1e6d2ae512a28058321fca4556d21cb4f4bce05b4f7963ab269f386762a2009f7eac11849a50f40d14713e073b71fd1f59ee95c17eb12b205a0ea34d7cbb0c87e436de20848bbed69a26f99898ac3c19c8e25e3dd35549cc04fd59e0229609efcc74bf32e99f492c652736a15ee70d5ca1b566225d9e07058ce215455796049990566ed37c276d430ac2aa8be76b3c97ca8da03f0a29a645d494374d7212925a89f1a93ae0937e21d56a4a309c4cbcbf111d64277d14dead59e564b7f5c4fde1ae0aec1e9ce67c98b7d74e1d6f342507ff193046d968d6878fd1b7ac52071d508575d68ada704dd751bd35a4abbfe930987c859a310ee2af7c2b535508198ecb9690a7650d149ea8bcd1cbe34fe783f173eea713c10e2dae4968aaf39ef83e067f7e699d4c0fd3bf613aee0e1238c6caa7ca338cbf43a07be0edfc991ae6ab6ff613a63da1163b4f0f9bf91198aad57eb849b5cb06de34eaa053cccddac2a575db2d8a53427310c9e88b8832e0d16f6e59e41558be98ab584bc6148cb6b68bc7142ebf07cc122e7cff0fd7c9a344641b5736aaed2668d93879ebfd416702eed03000eb78912af425449222ef8970d21cb3021bff4306ffab779934537d11998d6d97dd9cdcaed3bd2c70d24a9164e069fc292f7e6997394f5a5d24562059048a306582f7ab496fb3decf42e925acc7c833e1339a115c37e209e37306f263a381dd8d6c8381d608037618a2d8dcb40dfacf492cd5419eb412c147df40d5ed0ed6f0c0e35ba242f39f76e67f1b23ec60bae7c5077eb2f1c222560756dbebde13d3dfd241caad28264e15d6823d61c085901b46644adc27f65042cba510911ab4af50acd42ebe41c2f49cd2fa8b4e053f8a079c13bc0ddf1f4132083a40c08b7292dd04fdd298e56591f725d9653e414d3af6787ff0a2210bd8f3caee0160376efe776f101b3c14ad2a3a634bef6bd0a391d3400f758e205c5342be7cffca86d5da21c598b3f6d9ee2e5db0e36c1577667d23906559aa2078596135853441c23c013bd7ffd137c73b1d89dc0b70e110d2ca9197eaa5b635c2df3c60a6f3971e70dcd8143c9ac8631052bf99d1dca2a0b8c5780a7458ee24683672fb4f2e340e502c9a25e2beb5d1eea2a5bbdfb484095df6a9ca652b6bf65d02e1696af08bc16ec5d786e0443cf0bcb2bd845170d47f467f11f0a6d1fad656a81bd717c69d030bdbd6eba47121e484e0bfd687bfa089139cd3c12f77327db5f72fd986afda367acd39cc0b32e91365f2873c31247dbefc45ac70d9feffeb8c89b153a95ea78b565085d1f67964d5960471e0bac7ba813f6a965eb97b26f0023a931ce691a561a6d53695b02e2030ab977a075a6a71181c055ab60ca9e7c8b3c0726367eb33a736d4f736546c4051b607192d5dbcc6574d9854bafab34764e0441906ee63ed3bc3f568d8defb19e70e4d56f9586a91e92ff4ae516dc763495fd23cbc1d9364b894c1f0723d968533e04224c1809e95a12f6a00d96d58d65c41c0e43ce2b0c447ec1f7384fdb9463ab1c7bda2cfa65240abcfdbafbfda515cbb0b267dfaf79647e6f000e1dd70eeadc0722b79ead952e980110ee2f64955f29c5c7f5d13de192d6eb3a8b0cb026d2f054fab50cdfc001184ee1f9c3a21c475b8d94a83ba06b8a5086b6dc0e7cae266027ebdd8e23599410baba2c327330ea2931ae3add2bde3ac91fce1a957421ccd8da528dfc8ca7dc3a0754019b9ffc0b604268d3ae6c59004839aa50d8234642dc6cc243a130c2b3f1078988591962d52ddaa07c47f3e50cfaa3f33e0c92a2dc13fb2c4202494f162779932296dbdc2c808fa1e64498000d29b6b1a14bf289fdfda27f13fa1818a48bb58e0c1f15334cdc430c6a05b7847056d186b694d8c98a9d00f20ed4b1c5ee0924fcd7c65688e25f23a6314d7897589f3e73310be7ca65700ce59505067cc6f580fe3747afe69159b8b4cf755a025e1a95167767300522814acec4cd2c817aa8c386a237413c9c9a9ea7d45930f01d375adb095fe3910e61d84a994626a2d6de2b6396df28dd4e2d4002e574919201118d928403ce3d30fa05f6a73181340ce9b1e5be2f65e5297047487cf02c9c6eb8fcb448cd3bdaa8fd8c3b79c02986bbe04326572ab269be7b876613160808816103504c8b4ed04180451af24e07022129b7c56674bdaca2970ec23d67f546fbaffde747fa4ac03d975e1cd566e28ff1dfb4c650b14be943dbb99b1921b4cd858a6dd4fa77f95c75af08b9305a939780f33e9575946a8aa18b0da513c1fa914b319664864475d6623f038be22c8b78de1978d2f74b6e6756db34346549799d5a47e70c0e6af9c2f94370f83611f206fb6a136eaf4cfd73a139524531ed2564346995283c5818b3c7a51f0ee3430f13f630020ce4ca0e0ee5cedcc0a54a5e5524f87a2e7d9fcca103a8cf58da27a061898e9e375096b0a03f8a2695be0bfc80c8878c7a1721f1e580f07141c49cfdbd9142c12e5762c30ab12b07e4cb23b5e8e563e9cabdcaa6911bf73fa0a0e4493c6969202913afa8f6e340d733aaad948c944a9baa94776447b1db809314312cdd7f82caf26970e8781af22fae3618f0fb22e0747553f094a5ec98ed9d53cc30fbf79b70fe747e7c125fa05c92dcd1702127a04157f41e2830765c8099452bbb8e23c5d5354948cf30cdf985983dfb16327ee9ad09b5d2118a1cca3d85d52a9cb8a10fc82aa7178fd5a58813814b00f96c86fccc1b23832130fca1ffe7eb309b6bcb82613868c15d40d0626ebbe058d2a6e32480728d26c4fd241bc68e323d81ab92cb9e1ef386000e65c8aed8d81c1213df83e69051bcf27ff3886c1a5aa930550bec353d59a6e266620c2be5b5081dba1215c9dda715bbb75789526d26a21f81d7b925bb59ec70100c336aeac43d4b8f6ea648a7e1cf99b9cbe82e142b0d2d594662d8cffa10cb8f3ebafadd3c6c2c7ab1b1f09b4e098dbfce2654e3f1f8d63c8a8feba10f523b9f2b00b0f76ebe136d3b5a4112c042fb68f075317b56106d01fb848a73b4e4a97ff220018c6bebb3abf9ced1f6fce19c6ac393bbca808cc3eb870f22702a528242da5dad4e2319878ea79939822d7b1ac86ac050d7e5b2018f1059c9b4e0257bbce471823e9c628d8381d179a20f719ad33990a241dcc33d37c80ba0f242f6843c087b30e3d8edb5b6dc9d165aeca072dece0da6a32b481a85e7054ebaadd12c4a448f40a0452bc5d405bb67e0cfdd0eff31fd825525bb1b220b40d7b02c7ded2e0703dd0a5e0725a848ac30372b61e0c1c90b383d700bab25746e65b436315a45a178269cb943af7d717f95d94a846205f0dfe544a0545e8df28b1da2dc291bef8486aa2d2027531fd8b4536552e9d27bbc887a7f275844631c15479a97adc4bb12c0c12fa9b549bc55904b5d782af716639c93a979aada76f3e02fcf6b3bdf005bd940fd26c7570a2c71315f3c8c45c6440cfb35658676a67c0d31706da9f0d786367dc9b1201eaec409ad9f5c3ffb9bc1f2a2a46fd3f44f33d7d0c3afce0182ec6a6efd77ebe17c586bc4d9a5e10e7aebc47c0daca5bbcac0ae6be5a30ee537627ce57ef4065aea650e76fbcca1ae7de4cbe3edf29068ce9c14f7aac18570af58b08630bdf02382878343aa64b3d0051acc5e08996ece701ae9e6d59ff9ec39fcc1de253da685d61f41011194e9bfb28308ceef3f3bbe90e3a277913bbfa4b96949d023b047508560337bf2b1911b20e8aced72a2ede1ff6b37cfd1c2c7a02773a37bfd8e57f8e1c94b4ec655f227af39cedc2e47696ab430c83ed5d327eff2d895220d0a72b640e91d99f5d4882dc2d3f8bc49cbf572601989a29e3870b84bc6e3bd67547e09aa67fa8443cc4805d7083e6b2c0902fbbf8405fe2b4435d187fec0385d42fa4875a04a27cbe8d18db4d2f809d1058ee3257191334c876be0898f28f21cc719dc4ddc2201a00e1d2914c0d3a4584cc10cfbef9f2797b859f99476726167171a566b0e94c151393f5858e725ccf696c619907f73db7aedc0472d712091e42651233d7358318fd78bbc27349b01e0661e118e168a6149533a576cc70510afa124d042c257f47593c01e8b42b7bd6e68d9c0100b6082fce885d48d0073aaeecd5696c1cb95f561e7101f66e3fd87dc91b132753665e880fa7238a754bec800802933ad497ca6ab5c783c93dea8a393cf219d36fef3627b443dcd0a912fbbeae52480c3a3cb087dd5bbe8254e2a6e2028e90889dd99f4309ed216e3acea943e846066b1eea9c17e865f02acd18a1e98669e82cfd0fee486a04f90a483d1a7f556154db5df5169406097fe49b068a5eee5ad1ef2a380942c7fedacb5ae586b6f3627b47ab2c76f6b3a1d72a6821cc554ddf6c245f7773d2089772bdfd2bd24a06895422d83cb905d3e046f172c0602a5aabe8ae195a0478ed485bf2cd76253dc9c09e91c8f56ce8a4b754be2fcadeb5db4e1490bd5ac0160e0cdd0138e763fa9ae76e008c0a42a8ec05973dc0ba8c221397dc235e565ef1e8ae352f3f1d757db692d6d9bcb6a494ac182a87d73f160ae9e8eed105cc467c8c977de38e4e70e9ba90064ba0f261033a06ce83ef5ea12067b30471bee66a48c681805138b39b0074c57d0f8734ac1fd7fa6fce77f94907a565de33491313b85bbc5a5511c9483b5c379dc7f8fc193bd3b6149da6951b915f7dc3b3d128231a03c6782044d213ca2fde7abee10d7a7e251fa75b14e515dac22f762146bbedc42f27958f7c98007e331c9b6b7fc1bf432b7a03a0ce222eb27ff68f1af45901c952d2a2971afb76ae61e8fd58d081c71fbfd5eaf99936779433aa0746263619bf9892816a81f2ff4feee9a150eb5a0ddc9be474539ff621c19deb28a4eadacbdc5e4de88935db8bd296f283fe6791037813ae35c3f30fa259783a85e098fcb3e8bf9a89d482966d5ff7d13d3d55a59a2266c43baad41f52e250412f86e2433a983cbbf41abba1e9a093ce3f6fbbad4a0b355b0a3337caccba08b53ed191dc0e5f18d96b49e29db6137cbd5d6daeb4863dc35730b97c2be8cc7f5697c27d3232d62b7cd7f95c9755f49e5a9758b0bd6c102ba760e9613b14eecb2d0b7f3bec7ff5d0b60694d43d870672f592a03fde3a0437c395dc957ca7c5d668574f729b3b8201800402f9c9222b38ac60e3f0dd1d35848946779550e8bad375d0972077e2d2de2b754698afbf42ec57db2afd735e5d3b54a0f1c2afa16b52d07e53b25b7e33f5ac7c13d7592b0a9271c68294adc6e30d2e57af76f1696c1177cef5f1a4a244c5299338e6400d0fa40a8c19ae5d7dba906f335ca2536befe3fdfebfde796d1bdd88c9086da6fa928520b3f2963214aaaea8524a9ba027e302df4f897b7bd2dd5b68603320029365116cba9f71b43e384ba638ad5409bb783a3b605a6981c9c1c235f0e9bb04da08690e1cbae9df1d5bd9570e1e114ab27005a8d7bcd61b853f6d94a2fc3383ba2618613c4e41df1f3096e2e73d670408e36bcd7bd24b40643fe326e4caec02b6916c8f329d817664996c1cf037d59cc23eb606e8aa07809177bdee3d127c4288aad17f57f52b0b8db9ee461a7e34f8be5ad5dc42b5de5f7f3945e6abc104bbf55bbbe18f13519fe77813586d418bca065204b4646b4992545b1803940eb4f4763ba3da89102f2ed633752c9473c4a54333a45a7fc45d74a4f4632c6a0bd2958a4ad05f8eb2755c678937d4e8da67ca89aec5bf57f6290a305c920639c1e04f257947b57be3e2f759d03f642786ef673d37634c2adb74c81f350ff0de690bc1ed1e7d3148b2cb39f67d4c30cf966abca0cab3e0dbb13d9b0f5ce4b216e6d7a1d9cd3fc99a5d974544fe43abdf70bce9c14edf9e471e93cae18e256ee061222a13dc5f200db5c828b8c1a0bbfc3783ab57b726fe978a9846162981ea67cfb141cd7b85eef77cac373f15f6d4751adcde50b60debcaa10b87a0597efd1fb90f0c6b9304c2335c947dcbb7b4c476ad9e9c6412ac6ab518b4ebbb2b34a3b6c0aafced918040c4b8ccf75d861126bd3fba243e33692d058952625e7232dfc55b970228041c4ad1ec300f13617e700c333af054b93c5c31b88b5f77cd9a73e7ea85425308269f1d60b7f4b6d0a6dbfad6279ebd66c37cf7d634de8a51649eaab308bcb6828a8bd8f69dbc2fb2975ce601361f18bd911e9c4eaa1aecc3a00c667e6627b3eec1e40508009b37a7a7548c0bd6ae6845dca47384f9e6f9f844c462fab14a3da94e5584ecaf87822f692b7f9a57d9f24d817cfb7a8f55bd0d77be0abdb89559a184458b24433f5c55187429582dba85396d69d87772cbd2abb5aa550cc5cc9beea5da922b6192b0b6bc8630d9b7abd2e0583680a9dc76abb0e175540bdf74ecf9c4b6c5f124e7f9c355f48d80988402d56fc86ea5a232fb7066a304b11b1994e55845adf11f9af479429a45306546b089b6cecb585b8a34043025f47bc50e720279dcefa85a1aea37ba34eaa243be1b768034ec4041d41acf5bca6bdb6436534f59a0d9b3766b94616d441ee37def027c6616b9c5281e48b187398fb1566f917533a4a8d616c067feecac39223f3b657b341952014619fb50bbcc41e6fc6fb6b7031dabdaafc95224bd56230d8ad5d562a8fb245b478497785c934073dba69b2ba35132312b1d3b1b0b00d1af9098d640929239e9b49d65ea964a72db3ce5926723f80921329e77e657a10cad6c9abbe74fa45241bdf1fb8b3a93941d46813bbddcfe95d32b905842ea67ad4f5a8986b659147d72a6b2054554f31c889820a5bbca7654f985b874d15fd24f9d4b6969777f70a5e3db99256b9530d5efce1698c3dbb332c366570846d29f061c6142366474acc76e1c8ed8a2ab31ac7a390b1d8f5711009eea61973f73b2007742df12aca90cb54d38d9708d801d4a34fd41232c784b1188d8a722cdf0c7f144e0a29ce112967ffb71426b70bb0790e99c874831a93b6c6c1f1a06fba4ce9b75b594c6ae639089658391511d4accc033b8019e3958b44fecff094d18ca728012a39f562497cf01d48ff2e517ba4af7c00a147170901ccfc5af3d3c467de3ddefdaea22737a1265f560ad24499cf2101f1edb09c5c11f447b600f1583cdac3df592ff369bb2ce5616f0f4d7e8c14a0db0bda3d4cdfc21161308c78756810ef6ff4053da8eff32ad291cabd097f2677c486cc217cadbd7001585cfd4d1433ce248f039ef1ec2d0f146efbea5c13f8ec4e1c287059cbf2ea8862004f8a7b8b043290ca51e1c96c5826b931a96260938441b47dfcdd74ee3d473e90ee3eb680b477a1570e353f1b2783889a7dca0a11048342b4ad9abbe8dafb72bf9812d4c57318c2b9c2ad92b81773d8fe3c285f6647d029d20120e3667ba4a06426520805a262d7a933800ef55751efcdb055a46b5c0d3a973b117dfaba764cb9b159c1619fb74fd5a1652a6d7d4f663dd5bd9532a5722b9dd27b0427139e6fe9a0fb76a0a432693d1e7ea5a743d6d3a416a5394311b032d93516d15e0b0cb96fd03c4963fab2dc5d5fa53c34dc6dc15a706b4fa6a9b55edbc4ea9ab6d29769cf05d4b573eeabb60332b34aed5544d71e7c9ef58de069fc602863034c221d525ab1069a5c3093851514ea731716a0b88df743450f7db5b3b7c29b2294d1a809995dd0c1883c5dc9c7f78a370f2622f3a2d9f329dd4d837c81600598267be29e95a8f67b38dbc9cd3e219ca524fb0193d7ea1b9f6b6043e96e64fc887451347a778e2002100deea957b1e38ff1d62f2129b651abca0ff3cb9c88d5a1438779d30356887f766847cb48f7b271f1408ceac715678b7348732ae2829a2ddf26c313c3d5f9e03cb01ed1f1c0a35ee4e0e686788aa2b13c62d34989c0acb2921934a64287310e5f6127960d8f4d2d0a96647abe91f98c45eb384336c8a0d958a774de9194e59316ca6a26b899c5e85cd589f1a6be640039bfae6ab1eff37f1e17d008b7bf10e384626eeec15b08b5d6f699fc1a5730d97e6702d47b3728f66ad0bff46674efd342a29cdf9ba5c5b769cd9f22d058ccb193679ec9fd9821d6abafdd9fcbc8c882bd78ad38577f93c73e1893c9bd563bdf8328be7ac42bd2686af94792828b237a24c4ede2a927e75fc323a5016383bc5a74054a950be56a31bf17de34c0e9340e7622d6a1054b94053a522b3408ea40becd042e564bfd8857f2cf059e0ae780cb9fa5e8005d6657817cc7755ce7c0f11a781906f8f9e0f88e1cf8c58dae868829bfdd3634a1c5238a812da9aa1acccb6c16431e6a246d5c7da963e89645b0b7cd822905e4cc12d122d0fab22beebbcbc085dac01050ad9bb72b8c4d751ef05ca27cb1a2c0b06bca2e570c0c3a4a7f2d92ee670041f28a1564267bfd37e25fdeb6a592b47e5cff0e3c900dc58f36353c2591f921b5658ede2b190632549ad8360b2032dfea48dd948e898318ad37f737b805bf450b5ad54120bdabeffb1af81ef7b60c3650a4227834db8aa491738439483242b261c6d84608782689a9796af6fdbb07591b68b5fdc49dd8a6800613b09324efc935660f9ce022c0f2fae2ab0a44c46a3086b3385976691ea5e85c685be58b01ada801e82aae26044c6e4743b378e67cf3aef3eee355dc7ab3512d6a48ad5cae0bf576988b4fa390eb69bfaf9572bbf85459f70683c86fbd8b08328f5fee245353b3bb97f36def173b43d2ae3f9ac1aaa7c500dda9bcae014358e646aac73a4939477469d043eb000aababe2f94e43285cb7536a6e454ee2d8f3e091f7710b6bc9dcc8cd5e85b0cf833b7cf6a3e2c2ffef0a956bee8ea0e44ed246955850b2e79221502dcf9cc3882ce0968e50e7125bfe6a5a1b786f1315e7a06a1da95a26cc95ae48c8a5575d4a7577f2a64e5b63e552e8d718e25214ed2bf87d75dffba11d9f88e6d0e283b490f9c4d1f2920c15a68bf8d954a4f22aa6262b43b8c97a691aad43e48561c1f074d4c80d53265f9a0af9614914c0e2771236625f14a3c18e56d2329c881001694ef586e3850d087ab32eb49eae6bfc069887cbd5d842c68d663a2eb60b769c2f596b59151d021d4b6472bd240184ffda1909719cf0f0569a195843f22008302a6d230883d5e8eb378b3d41c44bbe0df2285244710c534de5489355e071489edd0efb34d2fcd58b5d674c9bba49c038f6b0c64c834cd50d39b978b5ae167e050150084543d88b6f1cb61707abfd1dc7ffe26de37815239a6104b980ba0a876e43f3458f15250410e0188e8d4f8e57eec84864598eac1fa17c17d045deb732f6ff2966ee2dbc40cabcee37a29705247d974bc40df39e8a8a1fac0a0bfa4a08c2bf3764b6936a0c53511a0bc8c5a24f97317bdec8c745a9f2656732b28c24e5e9794ec0fb648687bcd0436c28ca34c940fdce191e64ffdf699b00f22122bf5b84fe2d9b1252e4b2784125c08dbda7f5d1bb9dd51bfe5e054488cceda9f0a1a938f428a640df5c4281e54a8f6e98e0b3836b9f9c6acea9ab2935d16bfb4b8164fc69259ad1b7fb1ca329d8fd2c1c90bfdee0bd1c9953054bfffc25863389f45e71dcbafb9461d6c61e97a776c55c1fc5c9082d7f10afb9046013cd8634d7b96f8dee4168f1aeb21805ce9c8a58959af4e1866ace9c5dde3efd024cdd856343b0fef5911d436d55f54f1ef2b8f5f3c9b127fb89eb1136847ee95eaeaedc2921abe7b7afe96d3bb3929f088ce406bd645ea00d27f18e9d3fd0ddcea107c7991654b532acbd88c610c7524f765d7c78826333fe3490d7c9275d5b91ce374525196fcace4180392f1d45067c852145dc01d9673dece32ff94380f1eca966526f4ee4503dbf418c44ed1f366c9c6a291cbfbc3259be8ade1c0724d0eba59583eec233396b3a948bb11ddd87e9f5be62e6655cedfbcb107b755a19f31c290453ae80257e54c5472acab71f73bde7e0ffcde4b354af61a8fefdb645a52f3fdc8651b29be1da8839563eae33db8b9799875e03fae37f5d929e8c7d2d7c842577a9ee47cba21b8fdab3235cecd72bc0ed17eebb8b6339f25b1dc2014548e0846b2319e58d01f27aa568bc35b0ae0bb75db19bc239377dca438262ff514681527def1548834b4594dd0da4a4099239db3400341ce7202903b100f6ae7c0ec6bd43f7cb9b903da15bc7320169789dc6a1b6a5ef44bfc564d74a359e475facd174a2846b0753c1395461e55be61b4074879d12803fccbaa5727a58f7e84274e5b5bc9dbcc341ce66e8597781af70e412b4ac63131f7fdcfae5553739ea7dc369bcb9278c556c4c33849a9579bcd31a48e35c6a8a0cbb9450e75f97f7568c87f4484ba4d0a6ccb006fba9a00ed3c93442f3145ce1a8c895d98f30ddab7cc74ba7be8327337e425cba9efb8444bb30dad4aed3cff87c22030e48d365774ead8d796941ad3acc1f17704d964463ae824275be4243910b4b01c3c6cad1f527baf11c9d3db977ca1a13a9b6c935d741ec6025573115551651645ca3b1c421b0f888b9a1d4cf36bad8bb73fe3515af80b7168cfdd627293046263404dd48271931bf9719c31642a4ca211ba0d97d5b36f4cf1bb90a9f778fe0c8f8239d36a1bdbb39afc1d00bb4137c37912456a96e89c92ecb68f936dd75a166187ea93bc93f647c61697f13e0f63d81788446b9383167a89edb65783d32a485e8a2671213daf0e359a303af84dcee7008c68641be09c2132900c957c697f362497509aefec5f1053f9b5bcef92def1d99350d18469948569821d3e2634a172caaeb3aaf62a49d34024ea978e12cbae7f85c09a9f32f63a655c2239d2b12a69f4b0fb5f3dcda59b22cca8ba4d272be76fca01ee0316cdaa072e0e191ad889a891ec8689cc3f2bf22007629b944cf9d30c959309b3edb0c5a4cddc36ca93e1da831e06fd7211a4a22462a8904b1ddf2515c28fd6083f4bdc51977f8268635e25956925cae2321f55fe2ef0ffe8090971b123e70ec5529f9f1d9870d01c3b4ab40af1be4b9b075cf2d092e70787ffde4bac7f98aa3a8da24e7322eb140e15fb47369a5b97e340cd1dbcebf134e9bc01f6a1c9400279b004fce70407e17e377e85866ca28ed8a65525626686001c4eefea8dbfb088075f21fa408b225e750bc755f13d36d1ef7f4eda907119b46e449fa7342677783690c130336950b1abe6be00910d9ef57b3e43fa0c9cd3beb7608c27cae0986fcd3220ec476688455fd0d2d9fdec747b6fd6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
