<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c975150db88f699ecba9755cfbfb05019bba2fa4b651e82755c67d790bff1a146abafe16bc1cd0459f4951a78b77cc1e3e18b0e22bc3486bfc09647f7ce1455056daaa8ed7762b84cc0ebe72c714ae009765e1e496a1b3aa328d12c58e1af1ec29676faf35796d1d9de5d005e17481bfb15c03047da609669e93564bcb609fa291c803931a3e5c7d769c4718eb2d703af0e86fdfb53c3191d3a24202582d3e2f1227bcef23292caa0c3eea1dc4c1520fd1114e63720d932f59700c7e6343bd77feec1033ff1085c60f3e4d2d2e45250204801f92eea0ceeeb157251b4dd497e518bf0a7b97f5288341efdb0ae7f825600315baa266c18484c2f194673439f2c61d503ee57d85bc9ba1adc8578c95628feba9081e6d70f5489ce9ddf95a68823a65e695c0637d3ec991f9e24a3ebb65d02d4b6b778a22831d3c77f1da0fbfe1eb9d830bf3f67060d2e8cc27ccbde666d9863a02a4e6fc832c79734da5f3f1320f09a8c8572f718cc2c5669f6c41c3d662558d789b43752cbf1aaa2ec140814d077be04913d5f2d94af94c122017c740b92e39356c0754e7b0f1a00ebbbe7f8cc510629af497e3d9b2c22a64ef2c336dee06530fb65d03d71293640b3289a424ef21117fa2bd6a76ee51b9295150bbed528b5d01fcfefdfcd3ff4bbe0701a63457933e9cb7d3f6c11e48b07a094caea3640872beaaa0b902455a293a6b0476ca70abcd20b36783df6d0606413cec6fed33153392f507b27b70d667f61072a6488192b50b247f0e333478f10be74a048c12873588d9c091daee195d1f945a9bea13c16d2dbdfb8de29ebc01f891d03f990a5a262ba8ad281e69fdd9f53b191be90fae84fc31f0ddf617e71d3e6aeb50a056ec671a8ee28c24cba1371bfb856fad0be829745fdb567a21e619463c431bc7b98febcc3320baf96a95c428b9c789d3e974da318bff13c1edc0caf1bdabcc14a4b48d4c12c4c235d62a136f89ceb7896c7e19ee76edc9791c90a8b9ed79344ff18e28767c252569b1c92700d1d8c9d1ecb480ba02a43896bed0b7dda1a7fa0b2decb76af5b7813c918ba54be0bba4da1ce7f99c3c64eb0f590dced6b331c186983351cb5996b9f23115f599aef1502b38aafa9ce4d2f81d8595254c15e9ab78cd9d96b19ab42e4dbd89ae8bfdbb8ae89ea5f13a04b266c6a8412d62c53be0497b27f4a87c60be76d1d38305cab451a99c46fe481bae8fd30421d37f65450bcb2b76dba23c6ee55e874974639346baba2c9faeeecf103ca07782e6bfb2c18de272d7c178e2aa44959c5c23661508eb7edfd6777b865b64ed671112c824edfd43793dcd6a6e5e39d4fe3b65f6c9c8cb3ff8af082ed3fa849e722c3be20e175cf834edd499ade656b741a7a71a044b4c07c224ea51d5b1ba0f8424f10d3ae796c29539b6b19a30be78aec21da0f3f92aae96d0581954cfafc48514dd4cd6fe33483251569b918ead3ba8ae8378ec5e34f70be56f4cf841a388b5a91487de7a48d94ad1c4849f14529fcc64ffad08686727e874621de4803c05eff00ef4c26faa9d7335b5bd6b59fe6ac05036e62b9380699785f1d79541d9cf324dc84da982812607bd48d2583fb844679ccdee26e038c8632876a58eed19324619ec7278a11cbbcef44b3abba0921742177587fd2e1d7db9b3942140a435ab5ee878c09e4222c0e12e90dd95c86c8ebe503f918cbc7c34e867d848c0af7eccbe9d9bb2c46048060c1c3ca16e4f834f80b67cbdfc11bf94eeceb4ede50b8104fec4479179096b6b66cfe1757a0fad0210757246263a4b18352e916b90c6d6094bfc5a23390961928fd66e4e8a4f128c5f327a088ba9574a3727fd388a4e627515eeba60f73efb7bfdcb1c7a67c7259c77e8d48d006049e8909486e718fbcce006e484114a5b1470c97fbb84f1d96dfd1a53115b7b79e2857d8eca9b9284164edc0eb56f9982858e23c8024e56731d9437887106ed65139cfcfed575bae4881da005339b9909d8ba01ed268bb879ffa0731005464d48b59a242831928792b1f9d79e9a87f817705b8958a52d4ae848c7fef0b941260bd62d45e4ee375f96a3d13a61301b6680fc0cdcead7dc2b920c9506b637848a4d9c7caa8b22bd138db8d20391f2647b502ab84ac30a538d8a47df1ef79dba2c2060ff83735bbf944f08cdc78bc395df42762e8e1819abc3f1d09b00cdfde6a056a80edaf6a55cc0b1ed20e79411b7ce6238dbb0be36f1bba863f0e8caa8971cc11bccd77c2cb91e5cb0a332207f38b3595f800e7d0ebb32f5f8be8582d826a4a4ca130046edd20ee0a309529b83d6d9b49cd250c505fe132967ab81bfe62c749e549976646ae6072f237c5374f33736e340565d1862b3ac449035d3f9934d91dfd7467ce3bc14bfc3afb7f77e95cf8554a6644be99de0d46d97b8decf3d3df9e21b6b2d7f6c4db50460ec3f9034a362f1c81115d795848e612129b0dbecfa57c75f78a9605d5df37dba92771ca186aef59b60a6782627e643806155ee7c3b62cb8feaf5e89bab6f11117b8c41cbd6cae1b994a734b0e53894d78f8c370002617570e256192fb5455870d2c8a46675b8a2bc7d6e5153e3ea78a13d5997c9891dda038b71f4623ab378152b0296bafd4fba730553c7aa0cbf1e45c7a7bb364de48f856d118e063071f3d970f5932e864273a2340b8bf3f24ec0af93a3a38d58671d3af47b58229f86937d2ead15f8829963de763b142e084c4fc28f3e7d70a9f9cd44f946a52ac481dc699624d468a556aea2c5b67975b6fe9692d23a174703b04125cc04084c84b41a97317d7f4dc5c9eba1ef91d3a0548314d4600f9740283f7d2c8efb96e2862c76894b18a20a837b488a3d66e2c7ae3227989c058dcc8b68e3b43cd1726e60d70dd4b06a6dcec3004af2683f7d74cb2cb375e8fbb0f892001dee7ebdff06ba7af7fde84df1b59e27c8950d821be0bee092bae3f353e42e460858cd20854a7d6f5d0289f817a1e085314685a58ec31944a61756e8f12697d10be24c460f82d175a190d7b70ab6b6fd45e511cee407776fb4e920c11c34069255a5dbf09216458edced491ed3909f6fe5404c9c18bdc4efc979874304c44c629ae7adc43b6b7318e078b15c413fe6273fe66041e23cd6f3b9ef2ae88df24e1fedbcf46f51dcfd849ac8774d60d9ccf928004b00b6f4b523af7e50e6e24a71770603a2e8aa7aed670f2b2283d30d2e9fe6fea8bd84a88ffbbfff09063b6c64bf23542587739b590b5790c6c3a23432681b229eb303d99f1062479a4063f6f1694b3ab20723db48beb08ebd068b4247495ed73fe3874e4f41638065883282f57f53df989d04227c1e9b7f842ddc1d426be196bbe06ea089d41dadadba05f7f61ac943fa7e35a4003c038486c2c9301ba44869ced7287e8e234e99e7e73ed10c7adf07ced2d8f8031c8464d0a3991bc0b82054a16e3bd8d8e7e111120de6fd74712288ca4dec47cf262861200a5547f4ac56d7daebe98facf39df78e7e78a396c1eed170d8b16080a56d163a2811c9c8710611183607ea24e763370be0d2b36db01182c923d837ba9022505ab976fbcceaeccf1f653b8034ae053421f5c567c61a77cf4fc3685851cff5dd8bb1d943d2a4cf3ff533ca4ad49aa319ccb3ad23fac14bac56ff8bf37a2c79d1d77c5a72a8caf6b579e0ad53cffd290ca6704c1388520e23ba9a64be0fc04f298a17db400d01cafd84eb52d1e048c7c72d4fe71cd1d0e12a276d1a3e9931e01a5cfc9e726781a08aefb654acc74f2214fde638ec6406320a4510600fb0258bbb2a013e10b7592cb233e90914713b51d57977ff540de30e57df356a85aa217383a4b2fe36d9c15b5bfa4045b6dc08388cd0564b4f87b803246245c251b7ed5a82e450d904208e183fe5d39e904f92310e7f81351e64574606fdbc979d6dc3f1c1475eb645876a0597e018ab34b298069dbeb6aba5fe5e7b983828d3217860506b848b55b5c6296077f338a62986a0dad4c6d9ab5bcbb7480f825ead74d9f12844cfa25b96d5f49550e6ad092e09d4735ed306bcc2a283c2e11f2e3491cd94dd8373a396da5b67097eaae00f9ac7bbcb24e9970b1893030a3984ba0b31e81b2a78e088ef3fa3b660202a9c75c18e57d329437ac11bd67fc66f2f5e5187d35dd3699c645f5f5b5ab57e8db82c7e85229262fa79e683bfb138071fef5b45dab47b0cbec2f61b7ab6b4bbaaaf823750788dd3cf5ec9c3150d7ab41e245c5dc3ce52fabdbcc0ca2575eab65a908f3a694849040a7dada99cb52472a9cb0e3662b11defabded4d6d1a4f88c8c4d1a7bfcb88a8cec30caf6561963998206b6c06d069ce9e9b12a4e70e529687ed57e14fb9423f601355ab4d7538da80aeb0304c7b5de3cd8c0864d4a2d737bbc51deb945953dc78e4a03c391ed073a9b55fcebf1dce40430fcd3b0f8c530329aa3e93b88aeb0bff180ea6e8c76565a75e743931125bb31ee59755a34b7b84738e52dd5c0060f88eb59d9298d313f2058312911ad2fd0a41ca6a560b5604c56f1811b37863fdbeedb561cc6f54b88a3980bf61d48cd6d058f403bcf9910d43b9deb6b6dbf0890fd839b08341ca3ebfd1ff43aef981ed7e520b260d96d5c8c1b742df930e5f5c014852ff59c46227cf558a7b53b964220892330d37d7e39526ea0aadbb03338122d4a9ac595eb52778d08341ef942543504de2ec59fa6fd49dbf6db6f5a04648bed1c3ef674f8319fdfe81cf669d4a949e8cb5f1699435693d31f5f5f4a0a63afa1d121454c46f590fdd7430115b89198fe9e399333f1c9195782e5f631a80ccc3e7ff634a866d3d0e4fcda6102f007866207622301067754d2d5dd034aac80585f9881d2e8cd06d82d91c9cbbfefcc6e0aa46703e07a7dea6676a09fb3538093d443dfe83fab7f9e5f6fa4c5fb189c64e1fb73678a3c04da1a2eba96455ddcc4cedd849c486155b3815d4d87f50956131b343675e6196cfccf2b1f3bcef9e5cb62ff180fa6f0c33fe0c69c930073c964fd6a721318ce881e8582afbd4b95174f52270a5cf9b775f59455ceee061f452164457190c5068dc511d66625693afd99af154debe24985f42e5d6dac7b8173ad55fde4c4c550271e1602c96c63fcea5e145e0312cf3e16b3791437477a0928c1a87e9572c30033d59b3f7eb2b133cd1bcaa565157b67a8efb6b66c7e654c677934ff38d8cb5de515216c4c92fb0095ae5f74b55c86d914459870624845e0db274010d346d427048ef3ed02649ce2d5cf83a26085e941b192158541975fbf034b5111500a3fa6067236be1cd75c5db7dcf7f0442d7147fb02f1da9dd69b7ead3f790e14552f5464f2472d72cdbaa54ea9b85d4b490a817e134adbbc0b13775bf3232525722a8fcd43a183efb6f7037b72d4bdb3be843242a7c80fde6780ec6c26534f1f71121ff9be669651ae94d7936980eb560bb1f9038fb6c973f07b4db36b5124e1d93a832ea42c83385932cc211b55e35566b46adbe0a4587a42dc2b3bedb95ff3ae9ae8c6f85f570b118e33f3c74117baa4d5d7638d69ca493ff1cc8bd7845295d45616769c9da6b2a4c1bf9f22aa706aa8acc4c438a35bc5862a5e884a099986401c9d3d801b7f6106ad821b0141059bb1c489f6f82af77dcee6fac9495e3b80fd44814fb1815219a26e191fdf0a1fbba48768fb06564567e74562374352a4b22e168f6669f11bd04804c1cb88079247e7f355dc1eb0b85c2512672a6cd111d63e49aa9d7aa7d42317725c9445af1a6c364af0f43d2d88d66f1f39d1d460e76136085a39ffa4b1a8ba4ca15decaf78b4f02d84faafe4e27e32d60bb1b5306bd069671386150e416f913641c08f7eb0633fe0287eb9c93fcce110fa88c645d44f6a7363cc0fe156464244553124ab77fca1adb15e8498694ce121a51cf9d87539276782630d531c11ad4e2afc1d35bb13ae199056d00296b507a0c00660a74883cfc1cacd746fcb9e1ef8fa54817cd46a656803fb82a0a1bee58dca37fe1a3c7367c3e1edd0e97273198bfba779582ecbcf722715cda67ed9c3dcf82413da113c184be3d6395acbcebe2e3685b2efc09030ba07b79c1f994412374c90f97f5875c104d1dad9e4a173ec6548fed4e64d0d9ac01ee42c461f4733c451a8c662e670eac035b6e2de44cc610b331595686122bb55df2ffd5ad99f5dc1339c487055fe5570c23a9c05c86ec73f0302df076300313efa24644bcf71f1aba3c9c219e6243e71dc1c7862a6ca5829ae3b496136ce99d6027a32d5215916a2193e5f85f60c091fd88cd02e882f59a3ceaa69fc8fe8762132f0fadfd6c887e36bfcb4220d3e6e19bc6b93d910be450e30f41d3aa668c0bd4037bdb2d4d6e0c86f123d481f1a56bde139432dca3542ef87da301716df63bc2791a126b48cc3ddbb507614c93a3e5b60b04778c92aeca058f8abd0fdb2c0e4b6ac8dbff5445f920bf9af9ad41d6d7f654fd6dae86572daf80a417d55962b9d5aea798f30ae59a1ad444b1fe0e98f300c121d7590c5bdb1e6f3b56b03277cd649812d45fe82025bfeeca468ba50efaeca883604c4e616449c249559d78753db531d70492dcfe5ecdf5ef4784c1ae7eba891c9f615adb490285ae2773204ab42c72e0d7fad22f30a65a707fc8ed9347128912f18a61245bb164883ac7c5d58061ae6bef97385d040855d8ea58c51e632330d46ea405179df2fc292a27c35954bc80db716de81c2982d11a8dd76f04e5894177508fe728eba01c0982842b447a571d52b05c81e9eeb1a4efa35f07172ac416f223898ded733979adc1a4de1fa35ae23147242c4f3cc198834af9a4db883d6a9c19a75ec353950e76c81ce6116cd10b44d65b86c9b206dc353a8935b141ca4a5d20326cc90ba734194299b0790209e5325a035297e1f639941c22f2187036f4497a75c75ccbf9f60ea2af91f2cc458e37bcec6126782b66536b2398954afbde09bc02ea3ec289a00ee113c03542de3add0894231ab67748a878cb16388ad7911bf35b02ac6739b84976584d14f4d04296e06a6abe2788c262f3fda36ed9c98c2b270864577e05480245383197ab34aaa53d6546141d1f6c8b269969aae9f930c3d2179835a68d288403a3e8af49ea82fd5e0944640da63e6fd4ab766b3405cfea571083dc2eebea21fa6cd935f2742d5074be383bafc715cde9cef371dd9f8c6e8d53d6cc8c5a759632f51f6aa2bb3962ad5684d31561b6f783ea863c7b45cfad7585c0433fd5872abec7ddc694bc4116286fffc32a67c7f364a1744339134ababc01d1804d477dcb9c0ed4d0087f51f09a7052536591fe872434123a3fca1fa7f7755514f12a99cd47f83707c4fcc31f12080c4cb263be4ea288dcc9b6a581e8257f1e4588c8c601967a28167cc67e4f79f93ea841ae08bc1ca8d1b0647a4a36e9df922802cade7eb2185384a8e83b224ff9c3e83ae8701b446da9ca5197fdfa96e50f2a1a21ae6b74588a3d5428a06927e333a151a560095105f2412f67a7950cc2cf003526c1923a4417d29e909d907c11f616652b2f734711553eeeb2ae5b55928b08b0e9daa8572f760303e380c37cba0f027890af49b9e171076e6bbc07fc8252a9ff86965f0d801c9d73319fd0f8d80ae4b32cbdf44634c41efd7e6ded115c0672164a359922cbcc5e66bf6568212c747c9d78e649f50d0ec49f692fd3e4ee4d2d10677defd3727d23036937f9a717f590af15e96274df45d49a01767bfd073d9a5ce7ca814732a6628168e0a4366725858db8991ad0dbeef65cd864ab29cf4d0d7424519deba11794e5dc84ade4e78a930cd5e93db409c0bc6b006dcd7da0098e503fcb40290a57b1ac7f3703447495241d2f28b3defb55d3f1d86dbcdc364065663c8727c4986faa09347fb6412692658ea16445109e0550653a9dba0d96d8053dfca6d057ea34827d32845a8ff61cd393e7332dc49c82e16fb24b6856cfc553d81d26d235066b9ea7b5de684d4588f21453c65e57fa60a1606ac345b9e56550a3f40a50895846ea823bccf955664200385e7725a9f4dbf1e59a90acef41b91b4fe6193c1fa8ecac887bdd5903223635965849badc4c7961735f5ce2351e6fe7e06c9bad6ed5cc60c33d703cad37583076973aa7a091159c9576c6254bf330c241be9ed9518eb5ff45ee5e425f2e9a756cfb840471dfbbffecb46932ecb684ddd0a8711c608dc7b02496ebaefcd7295483b0e0b0a3cd0c4190c71488b84b267a2a84908072a6363d30c539a3fe4d0a02e46278ab8ef6249b4f5d5f60157a35cb86f9aebc96eadc65df766442c7dfbbd08546c6317e9486434854339533a85fa8de6649245b95d9d15b9a46fb30c2b381651300330952ed7c43fd0af0e295c315fa489c6f3fb5842dc271d9ecaf6b19c657222eec2e0ba0fc4d99c980ed5b18437096c8acc2ca268b35702fb3e6cc8a9e06935eb39182805e3f7d0169fa076e11e2b4f63c634e9e5a8abf517ffa2e3ff8ab30f636c3d7e21c9cc22ceec03183251a225f5034bcc46e3d9a02182a61ea178658a764acf4f210baff1b70808ef6b76add8e44cad33f2db85ba121dcb9bc242d748e9397f3a7b0394a0ae08f37e293fad92e2b0fca07590f8de3f2b8f8f56c4026b5cfe49d36117d0d7905eef986d512882c0de22b5deb6da0df1806aa334dc7d49990239940ff72476ed7e8b48430a4e01afda24bb8551f1d3770b93a9e298f21a9599e1e205d22027eb7b2d23d41256f2ed828ab865236849dedf2fc28565f5df4762643f061aee088d09e6c3ccb19022d6de27ed9ee403dd29114aaa9067ec49a1c792929c7d6a8cc1041a2af9561f24c162822e61a34da0fc7de678e54c71934bba1cdfb4701148f456db4709c73d15c670787591643c235e2a574a0f5b5d5daeaaeae7c8d2a314524ee4457d2e7a6495e1581eec866ef3a45ff2a30bccc90e80369237eb474cdf0ce31333df227308a21bcd81c0d3b40070940ade96cd0fa2aba2504432c06092a411ce93e288271350d2e2e8194a04c14ba1714b0caa76914d4ce8b197d61a610d8d52ccae667696acf6a94f32f76ffce55b847a242c9ccc280c3f9a0ea9db0adedf281633d5c917d3727b15ea6438aa11cdb30203fa08ec540a06b5d8ed6a525a18d658c9620edde6714b63305ed8427c6112a2f32a2b41f75baa992390c8e460e721ed5144a1605833c8d473e0750e1d5f782f42c9814a497b6134cbd3ba78dd7c7f6e1ed865b3174f093df8d125bf2bd9eeaaf8c4d603e177b35f72acd21cb078eaf7daab6fd357cffe8658aa21bf8ca06839411a880ff5726cef3ca11e6bb19394313e5c4cd4db512317f7f7b12185afa24e99a6c61528d6d5fa3dfaa68de8e64b63770979e8673158dafd06ffd5723176ce91d1041c0c6beb6deb6d0dc612d736c182356fe7ec78495b8bbdb7ce252dd5bc6fbed1450b99d61a51afaa73c0c617caa27eb95cf688c279fadeb7b8610ccedc7fbfef050fd1bd5fb46d02a16df20bd5df07a31062e296914d5ed2eb12eadd897afa9c5d447ac4ebf6b849c43bd1305a24c706a9a694d5653fd4fe409f19784921ea90c14f99f69798a0cc679cdff0a2add1f7cc983208d303f497043ce7d936d28096c5941636988804fd6f84ecb8bf31d315f663e252227576725142e7a898a057aca81f24564476b499c3018f8b8f9012fa6fd8c768869fa68355e5b8b64cb7bb5e2db5afeabc4d90d9f218ef538c4f1c3a585626c54d26b78ddd0a8ff442c06dac13b6ec2076dc09fc814680a9443f0caf32166f732770fa654a5161752d4fa10b644523343e175ee1b8605fac3aac521142691fd52c2102eccf9a1082025e09cb1caad5bfa12b3f68784a488d70808d07db9434c231c20dd23ca72623c4bab4dd6e5a18870593bef803f630901ebca09e23f878f95e6e5ee0f4eabbffbad6803d8f04650f3a4c493477abadca97a34d53fe3b1b9138f0004c7144f9594fa665779b6a233d6f7077b41fb477419f1adb89e594e6a745fd399adc5c74df42f6192cf16412d1b651a6437480e17e28fa2f3e6017f55e2eb1aebd53e8e30678822d7471788724e1c37e6f6ea470813212844256833b9367a4d34cb203d29d217a66fe893dfd9e88fe4e2b10c6fc66e43d7fbb4a540599de06fc64e4c1d787599840f71308b853f6019e7f9374cc1a76c262533c1a6eac3e36ed8cde95d8cf74d3df4186c8ef1499c7cfa5bd9340944a8feb7062363a46d81437f2f9b0363da3f0009300cf438712aa2a1dfbea0b5f94ad41bf05ffef5bf8532211d89fe197c8b6ff92f233b9f197564369f6d8451b4dab13eaedeadb5219ca76d90cbc6a9cf45a30a7cec214254d7bab16d675500c192d83ac73142a8f31c5282ea275293907f4c778da1c9989e35a7749a2515ef499f59669f55a4d334b36d0c628add3f5de447dd288e21dae8ddebb4ed89cc3915eba7f58f13a09856daa35a14f10a0e800e7c92437d79628fccad08a4ab471d456141ee169aa59a0d48095ad02fbbece9bd9b43258bd8fef02e4b75a721eeec7f3260055105136b2321dac58a45c3646624f0b19824999a315ac5905681e35766ce49f4e8dc4e4f5a1a1b22611124d3abfc4ac2b907be774674790ea83ae756cb19a4f77509c55776c26fd774bdac2820bd2b3624bf8f162ac05b6bea3e86517f54e63224fbdfecc6c3fea085e61a116533826c709738507e1b167433080728e8a931501a1fa6f51124f9a17d44d14e1cbc0809795df2a8989a1a0993600ff2a64e3dfe9e19a23c7678b9b26127645b64ece11f9190d8e12be8f34efe0858b581c7bc8cf0bab02c16cf5ea16af76d8735ef32e16d6e9d24098b26b031e6a9c2f4ab70caac48fac1f1d5a3669a81543e33ba67600e2b3bf53ca71d4814d6cbfabbfb1f7b3678969718578eff622fc584f63e441457d496cdf8b8164efa35dda350279a9eca0e24bb347d69a56c75fb412a91fb4ea2327561e194f32c36f08a40b1fc5923bb2dc3652455f10d7b6bf34afe61eca14af6d9bac8164b50ec78488629b5668e45602af85ba558e78046363929d64db88581e307f63be9508eee7a96b39cbb71244779537c1a6605a438ecabc695bcac4bf659a41675b9b222fbf74c68d85ed9ad7d5f5ccb36978fb2298ce94a84c627fc783fa9174a2648639c2dabb1a676c945c6ba721e7f58352c834785e70f41781f2e3fbf1a6e5809e5842d750c00d436e38038706d8fbae01afda69331954874b2a124266e9e6ac412d66b768ae76ea6bd43f602064a84411463e0145048063ac343632e7bf00514ba00497e93356b8bedeba0bfe5caa1bf5587dafdf3ca7587322a5168fb9dfe3cdc18bf5b7ac78a70248b52d7f021a4897525a7f1f693048ca26dcb0dafaaacec9c6332277be0e5e15942b5520a99e509f5da56575d6e27f68b5114a03e7da13f8cb914931a0cdae56018e8cc1fa897fb966984592bf67dac1f391380cbc1af15b4211c5f1cfd6765b8bcf64ad96614edd30deeba099feacdc2ea4a910b77195aaba5f964ba2052554535709ac506253749602aee7abfc4435a0311662f83d215c2393ff1554a3ea17101a00c60afa9923f79c30b93916f44126e9ce691c543ea1c72ac45f2e95ad93b2846fc28efacb59bd58a1d7dddc2c5622b0f4661e4af0905d58418333fd2a3b9fb0d9f52e1b4cf5de952376f52a11ee1215a12c8d831cd785f39fab9e2892ba9937c00a04982281a64a8e81921e74018e5f88463956f6d40a914cb50fe9cf2a5197e7e31d3b85a792840863422bd60fdbd53f1191f19cbaaa05b07980de0c4f2be10caca4f459bd12017c6aded8f59878e8ee3cf4c99206de4ebc922ac619efede899c0686787e5be0f28923d8fc63c0c7ddd463086e08ebbaa0b0434e7750dea6b5710ef54e55ac3f7796ae98af38f7457cf494da1ce512ddea9aacd2d2ab380dd0d72599e2d2b3155f207e7ca1231924f1028b6a8a03f0487d66f6edad1c29104b6fe97b458cbc4a4a13e5bd26069192d68558b04026d218aedecfebc1881f808eac7fb2747bdf34278602504ae4472e7443963ae4612c14ccc879dc771fe7914d69376484471a0daf5f87b53b8eabb73fe0d309e1d1c1a151d775fb9c2fc87b0aa7a9beacd9057cee3c78e1e786f2ebb3a3dc9b9d241dfdcd3b842baef4e962ae16b154ce57681e00169bec461b34b7d01f91ac02e303b9f9bed60bf84a55ca2cef681192ea48c74495cea884af10083c9bfed81e2d63e093c7431f050fd99ad3d1ff189616a407666ee28a63cc4bdb6916f59907f887ee0bdd7b281bb6de86dc35bd3059a5e95b95670d2c09b5d5e1258f1786c8a6dd0dbcdbed2d40dcc16fc5b8138e5d7586f7543087130df65b458b092fd5fe692f981512e6999f87a55f5388bc9911d41dd1a6f0980aaf27fffe4c7ae2de1d663ae45c153feb79c3dc1bc9d0c2b1376bdc69ccac73343452a40348533ce340c33b3b9efc507b9bd736097bf71c7f756eb4f89ac577413b19a453235903153e4dd524b814a88df617b4b80e2654f11560b2afc5e2baee1c2c50a4f7a562789453c5b5ddfaf712407b2e15f46c713da56748d07208421ede0218d3a3bda0cd8b73133162f981aeb6a5c71a966afba2e8f7427eb1e6b3edf74c7e3c83cf035b52c8ef255e303e6c8b6dc31c6328ba153db6d48d4f4473092b51dde4dea07229fc856578483ccad891027eaeac642bdd41e1ae5e0deb308b19f1c863430e125f8592314e36be68a6f8bb161f9fd5745f7529ddba55bfa14061415f595c85f349b78af44a89efa21f31a929f655ae921f903fefd6825900b8d8510b6f0614dabc02f02c512282621d3767189d61ef232b50f529df62c717e216a73e4faafc1c2b809989fa10bd3e614900a30bb7d2fd04dc1df344f81946fcc9dfdaa38be43efdd7a55d53bab7455b2e6919c21806befda6650baf7feb9e89ee78c9e0e3baa4dd066973b3ab43dd951ee62ae3377de7e3fc79e50e9ef95e71bfd2523d1e6e7bf115d7a3c6f9648621291ef19d2a0a755f8dcffbb541e894b2c1c981deff73abd56ea8dc3282ed65b50e652692e85c5f8e58dc7d051c681c932cbf40fcd5fb9f4d38ef87dd323480054a7de755157acf476b0d8f42fce28b84f5200f6cf56ca6fa22970737b3fd125bd8d40a303206d122e6918406e882c8b53e51ce50b9531fa764af3069e1da6a59f1f0488b23c639807d346593c58645ff80fb86d752fd85381d0371230978d3395e0442c2258ec69cb0722122640d369ee138e7ecdd08cb2d5bc995fe8eaaa572c23995da01bdf3794c34cf023ea413db9d0ec3ede65e9d35cf959569be5a254aa67ee7370c814a5edf71bd7f5b3db7ad8cd09d99b37b8d791078bed6e89cd5978bb68db115cc9babf70beae5ed1293cc0c7a73e6a4648b9f6fa7a00a238709bc17e7fafea07bd3edf79dfcbe0fbf48c3dcffa93a9c9851c6c2f0a7fc2c9663e1228466760158030e9619648c03834b1cf14756f959d657d037bef3fff03e1c22cb0802e71e2b7c803486093bd4801d5c24384a2766713320893ce830c9dee1d1e6883385fa23bb8396527267c80e6393627a5469607c1dcda4e97b6c41827c23ac080bc695cd15da503ba3b1d964c1acabea96a72e81dd4a7f9a044760646b6fff1c9742bc7a6e4ac1b200a25778ae1776aca7288e33e9efbf12cd676351da1251e7eb12f4482d545c5fe1794a423679e84e3ea8c4a431a82eb7f58296473dbb187bf0c40f14882f29e843ec695836eb0cf5c7f1e03bb4863128d01e23239d8cf7c26d9c79378dac89cb5da13f1f20709767b3e4ee573e457d0858187b3c5949b9f76d6fbedc6c6371285863b2f2817bbb0af86761a01574b2d6da8ffa32aa2ffc46b9498e6a382fba140958891b78952e94cc9a3ede8debbb165f767a09117ad2e6a1b355932429c1e0c6234642d56619381819e7898e54da7383617063c0507acca9987bcf8a078ed06943e2cb3f701fb36e807dce9a68dd0c9addb82532189443efcb83cc16ce5d73ed173e8ce553d590f1e931842351f1e9b5c8cca3c227303f1309329e452a7b0e548b4dcf350adf7df3b6a5f90764b4481a320af0a190ba6960703d6966304414778f23037e97eda6696429044c341d649d53bec7326f07e13f108f8d727781d997b325597ec1eb4e8f30fbe58e9895069539444408e3b212c73fc4df435dc0a0a2ced202d75b128b9aef86413f27d9235a7e13928e20467bc948fe455c5f891a015527aa0bed57f7da55e08fb858aa976705ee257e386ef5bb5d1e1368d6ffaa3293ed502d0807d2cdafd62496e8d264523a2c4ff98d329ecb47bd524f8edc8d1b19389eb6e052db716bf1c6222bb4473f66d33de485bed1ec1b61c916865465e9c9652762556efc4e11176c0f979075dd84e018faf194435a7026d8383d34e4096ed08dff3747fec0cd4c8bf2ffabd891041dd955853d2cc3b4a8e906a54e1ee3d758240e161b12b12d9be90acc7e0f162e1d4ed114868a9a3e079f7302159cbe5a4222a73cab4901db68456c0aa82cce42dc07f6d331ba5b7e1da7796a3145e6fef26ad14822091bf70d362d6201c7aace8f2c37cdfe22569f1782fe2ce24e89f70ffa73e2eded495e95771728039ccb6f615bd56b49f14df4a7acdb7f3fcef79216e81398956cceaefbeb00c519a0c553d1b341241a5bc387895d433a9ef91ef22cb75c7c44db3c14d67e7e5083df3e77207d02f0d3346d31a9639c0967ab5507813f3ec96a9ad293d3ca745672596dc91f88c374d4546fd5e35f779b063bdb7abb72ae488aee61c2407977c1863e5f6fd89c8f1bffb814cdd311ad8ec4e8543442017d18f09ec7ee6db9ca8ec422da10b7cf744e41f5bd189d671a9a929dfea6324f6c9be1523abc58e726a127eb7d0a45944cf9b8dfd5bd575453cbd88f72330a9f87d1a61f6cb77f1382f084f93d7c241a41257d7d190ffebcf4fb349adf4238fbc809a47f598f35944d7e71ae72991ab0f5bf1c7837971cd1275f71a81867c6d7e1a1696d51c9a13b5eb577a9763e6887b9e53dd572e2bf9948351e81c4df4f97d1a8dd08f3141de30274eb6250985867ad550b0679bcdac99c915ba7101a7f5402ddc6e751673354725ca4212eed05d462d24c95477c19cad72c9f779600c26d9eaee3de6eb09974ec84ed38f036a47c40bb6b767bb990bea9add37d7d87a11bdbd45a8cd80b4926a00a495a99198b63dc1606969d2ff13ada53595ce7457a134390b555b6cf589e12162601d5b7b62761ff4a6f36988b56b24cf4f64cfd2365480e6a2537b94272bcd3cd5a9e952109ed03b88f8c96bf54ef100a661474d00a67f7880b2888f5c7e4728f204ebbb3abfde5b0358d0f16d208052fe0896e483a9d65600e8036c473d4baa587b8b7a1f098287eaa0594ae48986b46020aed958bd9fa9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
