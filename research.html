<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"399b25f89eb1a0baa60b2b192c60ef53b0beeb6cc2b7c2f8c2ecd3f736c5e0c069541930b1d2e923837b36e2dbaad5f0cd396c25942eaaa2fea02d84722cff68e3913bd0ec9b89dea888d07944fc5716c229357cddb638e634cb0ec210c443c97b56fa80260bd42fe98de25d5fea6d73e90944c99ea5f74eacd7e095e7d5f9e855782839b52071855be3769a272f318a9efebda8bf8814ead28aaef1c4cbab5cc481ddca497e2773361a6ac4ec8dd08c2b4d18eebae6a439c601b9bf4be7aa25eda58caa4fdffd4625712985808d94222f6795b72bc1255fa85f156637c4df74bf9391f9bf2c9667dbbdaf26668db843484c59933f7058d6facb5c11cee193f4d8a9e1619fd77a73efc3b3ab7d51e55c81041f887b0fa720397cc3d33c20c93aa7214717481d18cffe53c528430c94545b72929028d66ba5bdbe66d6842f9a8907b278bafae588f0d3b11be4c0d066c6a64df8e900f1486855a6ea841bd2e09282847e2ba34fbfc27170603b9bd72ac1ac5dc55816d76ac1719c4a2221cf978586003089817916a9accb0983344e21a75e24867dfef3380fa518344ddc1beadecfbddc2a7dc9f1ae44783953317773f7ff8b58f59e2f64661a1b568f32d84a9649ac1be40b5ff8cc4a35e3b0eb4e62a0e8423d1c4e90efd0c577c3ca592c7cfb53da74aad8659bd77a7a1d9282a8ec3704b67d52b7c89d440a9ea5911da339b60f9ed5d20d9aa8b772714c8e3ede6a7d7f761beff11c60a1aa58dd65d1fb90aa33d7701162762247cf057487bc99bd3a19a18dd2400232a51d173d5ae8a59f02d0bc4da291ee2636235e4793bf6766af8657fa584ba978d20486683db4a03ec83102e5ecd4bded7ddf5916f13471e6231a368e2be94553e06a47d1f941a66e98ae73894449a6ed28df23f9b50db66d51a622124ca6474370a2ffce17acfe4672a61f683dac4ea3c353165e1503f16d925e40fe0ac494a9b868a4de4b6524ae34994dc33fdda92e0aff4563e4c6b2088d34961bfe56b9965931cdfba6979fe0d689ff9e5d1537a74f5147e4ee865912f7e6b889397b88eef1a04790f75ca7ff71f3ac29bf5b6a616ad9d7ed5149bbb36a337749eee953c72bec40a16fe8e147bc584cfd3c34b8729f05372669302fab38fadd0296b710ac549807c1e221a0e9f664fcd97e698f3e5ae5785846fbfe757ec8a78c8c4cb8c6dc718faf99568ee420e8fd0d650d5ed3edfaf5d863c40adaa92eff5cb177e14f6a75928a0cdd4b5a414e74f2085cb26c04be6b3479a0c62913a4ecee5620598a5dc51091287fce508b08bdf74545f6f0f965b2962ed403c0939d1f5bcb0f1bee8c8a037159395a5f1c30fab358fa2d6daf2432247e7caf9d37137b4e0b4d5249efd079c40ee4804b2ba9f3d5aba139d5fd5d3f587c5998c7f5d0d25b264ba938874b1d2d2563200d4fa71f57ebb3821dfcde61f254685366f1332cb79cd530fa008c1b80bce953d6b5fc6d8c3c557e428b9a94a6afff53f3265170ef0be9f6ebef1e2d4dc4cac28bc244efdaca06967d3fb72de1138b663f57e1e4f1a82fd63276cc462638ca1a06aba6cc9767378b4d77344dbc8cd9503d60425854aab8cb3e1a1e60b4960917b0b161ebd3192f98782d6187b773be7a14f8bd467df0e6299398832b8e926326210f2d5253c3d42c6e125f4657221b5ad47f14cff9b3af7d3c192ec89f89f25529507596fd7dc61b23c4f4afe1ad46e9b1cea0709c48b152fd2b1c4f85210c53dc7bfb330f64eb0c5cb92de50181a8361ae07f922ca13b323d4a640ef762375d14337e2b7f65468250cacd14a86008abaa6f81c85752307bd54fd0c8529bb6005a502c7b865a92ebeb0daf0af1e5a5c278e87d2ba0ade1761201750e644031a51f40c5843cd64b75e7b017c9c3b8a5ba7664012f2a4999f735b002088683cda49379e6ec29e0a73243a7c2e90cda2f381c60bc052d49e8a3c9cbdc63ff68d29f4c727de84889f290911d5dca371c0b88ca34ea685156b03b6f1dd02abb60e3d8bbced6127f36a438b687b92df68a224082df0f0e2418b1cc1ecad9a6d85fc2759286a025f2bdba79c1cd70b90bf1ba1ad93bc7fc5c8227e361bf7601cd73c6e860a2da3e28827ee1deba19076bde2ff39d383fab39e50dcc8bbb8e1a09a7071d49f4f9bc30f2e518af52fd7132819b81833fc517a2a341dfa2dcfc57abb079843430b6b6ba6a30ed4a55a4e4804b78318916c6876ac438a77fe0141af6f1e7a7cf5af48741cb4076592a698aeeabe6a4c92152ed080e944e3e661375aea9e88e5054f42409e8fab19e9f7eeb5228ec1fede0c7b4bc3e529e0f5d97ec5573cded3c1ede287a51bd774cc158a19d02c9efee2c427884e99154e244c40c413a9b3e03eaa300aef71520d3ca9c7ff680b0785b3e5495e6213a6329b648ef59340fd27a9b62d5927f6c05cb30d7e69bee941024baa21b6958d7bbec93b81df9e4837beedc28cb04e78f5e71b2cacf27a5b8f2cdad5f5bf172e99c2c51ece0f82d324dd5a9149df3cfd2d6e3751142e7d6507176302efafb18c26246a79f1fe411a0b7262f269b40f8d5f4df507c0066ebbfa4b254d71d906004a49aa1a69b42c0b72421a966200b8aa20aff555d9c6b20d055d0aed2258f5ad7a46dac434a1161a6657b39faa1b5192823f4f576b4f6a81f1ab7859b050ba4e26ff9345538042d1522d373e6a80edaac78e6bd725f0b723753f5028975c8c3f77056b2a71b412279c4a80a97a839467ec10bb9908a48ee2887500961ea09345fa56fab7dcc8455f3df2b4ee77ebda9f8e35af513ba67aa1a552fde04fef4fc9d04c89d0f5a0c8b5474b33eb0a373c1f788c5f9198936edf8fa93d3ef3c7210c42f409702275ce845eeaa8bb1d079ece08bde26604c5b0e47306475178a787c00db76af121958b79b3c80684afbcf3bbfb362ca52302bc9818466e905e323344a6ee283bbf7d45233dbe671b394884bec05de07c5656dbb11e33db4493a0a6cf658a194b14176a2895f668cb8e60b9c45ee31b11eae43a53f1999eeca73ab8adea225d9d8ccc2073d4eedd258756eb632f92c387f1af39780c2e34289231a23ee977b18b8f1829f994b0118f66498f252911cac205308c5a5fab80fffebd6f6f7bad160f1282620aee4326a68ffe490a78634f8ae2ccd5be744441aad9bdeaa0eb266b012486dcfea1f78a38f6701d0ffbc0b8883c79c492f6d918e429bbffe40e924fd3524a848c140ead69b53c977b7a94f56536e318f1743a54047e7246505b145c3f7e8991dda868e3ebcda9c1fc2b34872a59fcb5c8bb30ecf390be4fe61595894846bbcfcd0595c229db7effc25cf00606c9d878dc849f778206809225d24c2c95170a0a0481dfa6988b01ac5a4a18244e30140529f8de9d996a583476e718861a82d44f23738959499d0b8ebae68cddc5434611516f9c594da801931e4135e4e136245f18102a9c860ab72535c079afe28ed0440d286b560e631c5d69c58aeb8681cbf88290be7ca037908ddde07a1d9da64d87ad60f1ac32cffaf7061a6853904fa0cb9da792588002c2205dc54cf5f76f3f1c0ba5953cef234243e7164fa780ae428032927a84e7868c079558ea7984d153090801618264e4d2b8f8aa6e2b5ec2122b19e3ebc71fc50d93a404ee37d6c9925f6376c94ca3c771e2cd7fb74933f28e27465d3939237a754a9a922019218f06da3fd534671faf9ea6cbf18b011fc29d4f25eb5633857b2aa4ce909073c5282a9e7fc26d59d6294316c2bdaf80b48703d2cd4f104d18031175ddf25c45e4efa4d510f24eb0f0c1ee57139adae503297f1e20d859873b526cf96ee8a12f1b08eacaff46a5493506a9e170bdfee6f8f9f147967b7335168832e2dbf9f2549a53ff5089c822d967676f9b9b97dad28938f604417b2c9fac50695b9a96082ec1d2ee2a7ead57a10517eba31e21013867e4e90d0a4f37bd7b038c8f51707cb6dacb4962bf4b2ed1d0d62acb832a9ddb67d9eaa0359388aca99ad1cecf374e5943ee5d7d47f6a897fdb534b7a8867c06e522841b9dfa3ffd7ff386754f6673a0366c304de0d8c5dd5f23262d52613d36d7e2170e91222b8ac28efd2c84ff5e9bb744aedf25fd6ed464a6b020f73da9b67fb63f15b36b1118377ad0f61ab8ba76843388b88098c71b8edf628fe2e47d0195e68bca5a354e2086eea02848969f7b5d01fa60ad286d1319a0544cffb496b9a9e9a5e5be8d0985d8d0a99ce19ec209f33f3e9eafe49697b75e42b935e0a8d088e55067267d9029baed9eeb650d6d4535dfb3b9aaee5bbc1bdb5e184760e1a05903d38d88de4b5204d89d1ec1b108b42b4bc98df63f75b5de155401d96b467af7dd7394c810c69dfb1336a9e8522abe66e9f577d48a06223422e7d597bed98f788aca303ba38633f0caf6079026433fe42e126d19bd3d550f55369e984680254b868e4e9aeecfab3d122dbdd13659fa59d8a0947b3cd2ac94498bfdb68fa30ea932ebfa9571e7c33c18485aacd346224a98c4132f22c8faaf09b2fabce788b95e83940f4d4a57496c81db75b7b15e946b799a278c59f1aa013fa01cf3f598ba3dd4b5ada7f43f4e4921a64d3d40dfad58db275e60d58b2a66b0abf505c235bd306f8417125e7da610bed6b125a5e3377eaa221624d9e0aa83fb6d1cd19ed9467aff1c6cdf8a93fcb44abe5fd43f746f1ca477cd7e0b2bc8310d45547dd737ef9d96974c1c5cf504f80a787e86690a4157224f580b3782d42b0a697d7319de34aa6416ad8e13142d330476f87a983079a78a68d578f382555d87df859cf8fab8acb4d48633930e233465fe007221b57994b8ecd1ba9dfe5c198e932f940ca295e82b185baa5beb8f51bfd4547175bd6f1ff9007d5a4f28fbc45533819c91ca0b694ee47929ec78f846ca7ec9582db87e448c2efc6868de26c2246fcbfb43a7a4e0a52f92236786e40b3443cc21a9f54f899aede9037d4ef8542601ff16c3ca72ee982b0eaece29bf95a5c85fb0c955dedaf335c251931159d4d7e6d9c227915c7013aae60dfbe460eda7cab5fe587cd8234dd261611c8171327a5aa4e9db461fbc645983fde8d8ddde01651cb5bf73d8b78970d61bf1fc56c6c48534c4f81ab322880109498285d43e4c555e32f18a2b770028e5d23109a93b2b9e93e6e5061dd5a879af61597d5d95f27d68584cb8d628173370ade39d878435d6536ba0d5ec09a5ad94f3b6d19110ab3646fce2597bad648e1796dd2b517ed303d14da3a79a318006e0902da1169c10d371cf009850258ea4da0fe8d43c7c7fd3439640f0e2882a4b68de8676eaf3ee41bf3245871cfac4f6d9ea3e2e8fbb65794ae559fc1f5e6b94f6e9bb227fb5deb8bf03afa675a4a80b07db666fe1b35f4221a03e96f39af110569dbeb7c2bc6576361cac20a5246cfc815a6f194e0795797e29cab460c8b02513f93386877e5c967522ae903163fe869c0d94b2709982de65feef3c282871e13c3876fc22954afe3a8b4bd249930647f5c91f0beec313e4104b963561b68bf362e878f5719926ef3ef77efdcad21d9d28fe460b7b872ac5044c8c736468981506916c7c2042aa8e0f61c2c9b950d74518bba20c906e971aaf0cec01741f0f27b620da78894dbf5ed5d931e1dce2ee600e5f23ddc8ca886ff35f144ad4be8aea50e9ba20591df27ecf469b5515afe3708d7dd0a4807e47336fd8b00872c8c168f4dbd138e88336ed6cab697f36c99940a842e927ac0083d5a00a80a4997993b687dc1cf2bf6446895d2b8217f3eb32533afbe1f5e180d987fd833b50e56920d0aadd718a6c8f2f6d2a497321c51f5afad560dd02a8e9e21a5922f964958bf27d6652905ac2e02964d20157083d02660fad14ec1913b892af0d021e6a6186aa8f99c53ccfb28b2191e14fd8401ff1977c8a061631dc9e5f3e8b9c9a0495bc1e32ff01f965f345b07cfc27a8df859af75d6d6d879e714a307f4c468a3efea2bf67c60712d33ec8f903cb81535c4f39039206426c8a3d6b5c556f6346e6c66fd9dfc96ec21a663e7680d515c5e3ee741cbd99e6062b2e6fd4053ee885f777dea4bc6e09d0c699d7219a0b917d1b391a5a027b06070a56e24909d9c9210fc84c1f814fdaad3191ba382177f860ef8bb596c36253649a914c312f8b0d23a5a3d266af5665b5b8a75e0742eb072c5f5c9d3d824d1d77655fdad39d5f1c6634419afa9330cbd213457bdb8dbd93326952a82d2bbcfea6ee8a081d196904201d5757fe6820274d721b28502a7facb210b87bfdba05d181fd3e5ff2bbf0fed53eb0c67e6d63762d31a7ae2402a7b17824724547c31addb02c3b78a9ae1dbbdc333efa507a190ade5bf6d415a960046ac4f715155063f512aabfe5f4324b4e629c618ed1016ccb7311e976e5c64fbd46d9ccac8640ac50c07c67d81a2bd4a5943fb3f23cd0036fd2b9547523c5237c337d3b63ef2dde021844ebbeca1431969d4eaa84b1ef2b6313b4c1da9db91f9fda872c8d5ae534da895434dc03f4a5da7afa3e0958cd51735cf6b82cc51c45b7ea3823c8a3c566a0aa632985518b47794b69c688a00dc2998f92239288bde7df8fbd7e65870faf14b26ac8c5b1539f893ea8a8bb0390cf4126a5a39e3ac997d13f13d1da903aa0f7c2790524dfd50da20feb15ca9cbda0c9f6b65664c9919d7153a19b511101950697e5022e44fd909d2a4e2a0ab280d53a38fc7f4fe2b966abd8fb4bfb3c08385a8c1ede31d16c613babb0e2c577fee7d73451ccd33a7e7b40edbb6c296db5316f7fe902510c8a73e1ff474d767fbf1e12d3b256983bdad1b51a0881a0f44e2658b08be00e2605b36d15c01d77ad499baf7706278a519fd6434c64314c78dcf6f34885e7389cafd90e589e5975c5cd11dfcb93789668f5862e44bcea0511f8b1ea946be47261f62b94b0479338e46be35f30222e9ab92ba20fa906fc1f14c988f8c87515ea7d03cae67159416584fd7acd725963c6a5a8d2de382c6a72d58fc3c8287ceb42db72352b9fdd59f81490a0dd06f3812ff643ce917203d1d3c9548ea5ff7934fa6efc4bc1570b8e0b23027a15c009fcbacf916ab4c28707668ae2c0805989ff3c38d3bea739f86903e740a2a75fd0d1e2a4a697a43f8f671a93cff2e01afa91a7227aa2e476a0f46114ac4d1d74dcb84906d0d626d3b5b5c9655829394da85de2f9bebda9e14d0c92e195b472da57934e636fdab205b6d288622d2dbc61795375affed6246ba09bf94bf5beb6cf3992d16c1dadc595ea363fa1ceb0e2ba743d1f54c8ee531f5049804b041dfc36d3e5d09305619b8de4634f297905e55c052c322e8b5ca086a1ecb464b6ae0ed4e03ec436298a707fe81f1a0d2266f7e6caa25ebfe6ea72e54cf8abb8ede2de6a2bec33a389c5f85f477a3e935e2c30428a3fe24518a0d3d750135ed5b48f4adc8b4987df61df7078b0c1a07ff2c507731217496d830adf914a389ef2fa9dc1e16a305fec6bd6c9b0eb4849dff8c22764f32609f50191ad405d32920a35ddd7f623cc87d96ffa876270feb076eefeba70ba73ac3ecd3087d70cfdbe2865697885dac45192715a6d6310bf819a04de91013a5040f48a9adb1281e0a2a90b1940550dc31518e613cd4b2db0f54189c507119d3301d3396a41698c13176ce4f40d384c8fc9d5fdab9c0284144b22c89b9723b1b3c8a1540c2c6f71ea01ec464e2c94ba1175c48e43eb2622a7522ca8d6883e389bbed9012a30cc5e3da0f03a0a0d1fad954df2f821b94dd7d1779753fa00384e6bf4d61a19cd597a31ac0c6c1cc4968acd4b158382d528a443764a38efb486ed5a0e4b8419f3e7e33033923729000a8050e345321e61456be0e87868c015cafd7f44fc5ec58365c6c745b56bdc44e790fb54cdc3ea497134e6df7f7e4e3f37250a8759409690df6d483161655dfcaf169ade5dd0a58328ffda8ddd7a471293e25ad513061be3d4d593fe72bef480c166ef8d357cfca0a31823b59588caa285db0a4ea98703706b37071d389225da1b63f997c48f4d2b08a31987f7f70df961c20c6e50e7ae260296cb4a4c49b2256cce3cbdc9a4540f94faba3c4fb80ed5b3916b9741be505f920f5713b3033930ce9ff7b07074f9ca133e390ad775da89a0d2c881540adb4baf66433097a4a92343c9472f7298a4881b9dbe4a17e86fa1647ea278f0fd0cd51db9cc34a5c5fc7f2c4220a0597cf222372ff1a614f4a9eab5695862e9451e6ff3d46ba010fba121913c223034c2e7a012651f98e88def445e0664453ea32a525fce696976bbf029d95f8c8a85a186e0fce0223a878200958c71490d49a987846e4940c417f4dd27791a187c5e71755ac6118499796df5e2b598bec23240440d7924e7aa8a4b2cd049b375cefeb9b594ce1956b04098373f63239ffccf1e0c2d5f219e9fe5cbc3b15decc49f27d77d3b68d53f0eba711e3e60ece6524b883e6866c3e7aecf106700d311cc2f58d8f84cb88160184c9d2945be1a68873b68d616492fee751eb06e1613bd3fcf3a65f3a57ead4531f34c22d116e6751367e892e7086647cd86043cb7906f6e15251d0ae9eb3b1fcdc7bbb2f7734d509035a977d68d199d01c74069348e3f73a5368512444243860d43cc89693547dabd7fa547e20a8ce70b219f96bbd391f94d4d30ca1da074739d3b9e8f7fb1f283d0cd0410143435276c3798894f719ef8849cec718d28754793b751386d59deef1726cd0a436346af52b3bbb2fedbdd06e349be061298fb53d8c37ac5f5fde155c60fdb334d901579043fea26335f349fa78c9c31ff17c8fa5d2692fc97a7e857424fa19333550fad3d47b8d4f2bb56ebf9eacf5428a5f715f4748ececee4ed79b6461b41c8f1128792030fc1455a9fd5e7e6c98c348ca8bfbd2826f2728a173b97e79957e8614d8dd894e4d5545d84a4c6f3dc197b29814badfed13ff6b235361e2b4e34198004d53a1f1b7b6345479cc2e140404616066ebd5cb2251826218558188688ff750a44c1fa32b30fbc5f1c47c3d824ea26999513890c077fabc2acfc6ff0e0dca0724bfb8a2264343617142f7f902954407418984c6f74da18428cb18e159ddbdb306d5692866fc62a70c3178dc7ecc1235012b0f8cb1da43db8b575efed648d5f0888dcb7c2addf46b05c059aa620252ed1302d584fc0604e469aef23d2e4ad836f7f42861a5595c4c22558edd16a513fb312c4f6af368508714753857c0281f0cc794404e8363d758f222ded1a51af532b3d7bf51bbc1d35da117c2221d1f48429ad11ffbb57f6fa1c54c3aeb57b5ab9fbd6f731276b31d20604f5ed3312cdf118aa8667a2d7a46de6dabbf1dceda0bba3110ed57fd74933bf574cd369c912c8b736402f5d4dda60b46a02722e1ba28f22c894a2a5fb427efadf12e335d9d4947798e16e656d17b70cbdd91b66b48616c0da937eb0188d544dc1b35c58f44bb2981c83314a0bdb6b1562dbe0832a8eb51c29da1fb7520d63b9f9bbe56d59cef9f3f6028d066b1befbabe6b34f9c825be89904d4e3cc7c95782f5d7b10c69609ebca24acd62806f9bf67000d9b04422ace3bb37b9c4fad23aebcbdee7ab6b250d9c3a43e92c30baeaa6020ab02e4532568b1bbb8875fcd075664c24b12f89fbd5d5eedfd1fb9034f4e975c849b7d1dd476d9652e3a44e45f320ad6730e4a6c57c1a6ac47e3f350802889b5b44977006fc874a5b823b74d6f72673cafb6a770480afa902ba1150f4b8e6f516c8097adca0be961014f81efdd5660aab4c29ff2a85e1c648c76a79227cc429a60189f46a281ff3c57ee2ba2dfd9d34672b4bf7305b20301f34ab5f2a6db176343448b411dafe5e6ddcfd0e7eb2a534d5d5a55175d0c33a2d412fd99630a54572c2c748001968ff4e4219f29a51be99c7e62913478e48c931fd81b5d67dd9c6ac02384a49027ff1d811d2e4879080e1f56e926390d7f667093ee973461d9c93e4304ac19b3452796860009c19f55cfbfadd56c80192175a0e1e87d64d3e790ebc9c5524497def3513132aa5f0ede394597518c7f79c10f89c5ffd78e708edbfc0f807921ce4781d2797a7f3a2a1ccecd83d0f026e0f2d963c753f203ed77b41c034df64d27d631a15cec687b2604bc4f321c5841ea7e1704f21a21a5cefc366c8054f115bc6226b54bc3dcdbf6d4ba6c0e6ad617176909bfecb7f6191a2575d05113aec63764a39e6f32bb81fad3a7dc98856e5d60b67d541914ff092bc88db6eefaee7baeb5c49e62ee495c2f2a014177b207b8df3465030ef5cc8d62ef10766326ecebea9a639069698a8dd733efd5bbbd9a3f30dd9d7f595aabd516f414de6639819e44d539e4800d6191a2de30dd7f863a8deae17efab8c878f9de923d83cbb4cb52ccb7eaac4ea896213819d48a579821f86a77ae6c818b283265952232e9a6c5548a292549f1687c107eb6aa7eb4299e5e1af532f5eddf70bb59315a9939071d0319796a24da1f1bc5d3986f5d7a66ffbb05be1a40889ac96be48ede31e53fc7b4606a507393026080614c24802206bdcf11558b65130764f3fa6d4d8c08abb09a7a755f9d9db7bc6da606e6315c395c22421b51937ed623cf21cd029e93a00aff306c0ef647652d89a4adcc9b8188280d6be154728d77203df2fc63ed268df779197efff2741ca38b2a357182b32f88316642eceffbb3a03dea275f51d5815143e826eac0129f1d36934c57f838052d005488510726904af19427a0248c9c401ee643a984af9d396c34cffbaf3777d768e836f367621597b46cf314ba946bc949b1a2809893c179e72da7102289093039c19735aab46016f1acb7ce8112d39fc2099575b23dc1bb15b9e3a9d77aa37500cafabb10ed5705b30f6a4b191b4f9e247e4b531ee919980abad5b7268509d014ced464650330f2a8543394a85b5a090df56e06e38c46ffc5db0db357b3d0a4aaa933b1b110569d964412ca0579e98b80c291e19faa12a0a2c4a549b431ee41b142adc7ec63f8fe1ed8388fd922621de22ddbab5f3e225a2b8c12f2e00223b55c47da50a44662eeb4b64e78314f64bb03f1442f038ce388eb58538ae3335e578bf62047404db24dcef9e376e7cabdde217c9c7053f9c999afbbc2b02651f3e6ba1cc99f2ea51081e5e55003701a85f7bcd3d3c5b92fe1ae79f0f00b74e1522bdfe9f943de3936f2c606db9facf3b436789db496531667d2e3284f5fc2325f98fa73f8632ea7277058d2a15a19bc53435f18c6e1d6f37bfce6cc145eb38c2d5224e934fb0d4470c3739f2722c662f672b6ebb6cafa488e727428632bcc95047b3785f50f4e6b6d01607815bf7fe9b79f54b858a23f54c39946d5994be31de95bd2a18a6d9a9ef3cdb3fdc5dea8b16d2081f83bb368ad587b143c257175f7837c473215f01d5a3c9f6196a2ecebfadbd0e2aef4e74134204f3bcda724c57e92ede0b290eceeaa0cb8f4184cbdd349e6504e26df67a59fc7d1bb15f0bdf4cda6eb91f0933e70d123c7825194d644ea362a39c1a75011f44a62a0585da3da64928ae8fbb147656eccb965b39cbfce8499ce81c1df66cc04df221baaee66a63069a7160f751d5db5c1946a903b701053d41955d5b79a6400be75e51fb6b980c690bb7ce5a0b913409fe6779fb52ebc0f4c84ea6376d5233f70b5979d1a97daa795e4fa6e53ea5feee6e92132d17b0566b1413b8ddd31e7f330584a4c593adba72581f09dc1b0b1300432b92ef586d49372fd2677232a181cc21d46f9ecc66f400bf7c913b69fe894a982c08c10790e15db44db6b37be530312e34d0547d4109b044aa6cc1a660a3c7f740afc27bdd066211d42c20fb0708adf7f7a198ec08175a787f318f69ff5ffe723a42d57e00f6779a66fea7a00e020f21417c650680405cc15889f26463cb42bf8435153432a1da401c4f9ab0be8351a0ab481db2b305b82ff22a2a1be687eb5c96a9e0aed915a355e1da105c19347f5b269bba2ffb479bdd4e1b28fbef94d15b10abb6d17c56da0372366c9efd4a43298533401bdbfdb0b7105c4105cb9f7882ad6f07e0a27ccaaad3213a6fb4f94a7b120cf8a80f3fea28e79f8f92aad42804112983465e52380ae43f846d53d7d3ee18c104543d4f3b69b08ebd34b2c2edb13482784127f83e4f2d426b1dfbf014c2ffea1485bf4027d34826842b3f5336c040fcf4ac5165a491ebfb195397475f83c0ed077d3a13e32a6e95855c4a107e89c056b0621b9a39a9a3baa2efc1ec3a44c72c314de9d9d456f445552d4e911217ea13a56020bd755a241f1c4dbda71f0e1d1c437c40932b3c5b61da05bc3abcb2dbbd4b0d7be4211b53e5d7b2b794dd4e313db1b8ecbda0fdc5461bc9c796c82e6d90bb95f845abf7282c59ea307ee845d9c9df5bbbfa79525659b7f442d007b6d08c980d1c1342a64c937680f3044ca9090b0c5fb53523782ea70ad50cc49519f4138504250355d8a7de170502661af5e960da17a291ab86f86a98def5c128b7098665f6e2fc0b9276a244ebd6ff5d8e27c04d241d556f211dce9ed7fb2a5788404f7ab2f89e3eb19987a893a8b3d4c395bf0b0fe4ed94c5ca465cdb908f719a00756b6b55442b2884c3f91d89071c1b061cdea57d938e697cb6d1d9eb1f8b354dadc997814e72f1e163358f1a936d39dd4cb3d477ae4447d5c34006e3ae2c2f44436055c805a8d0d8fa3993c6a301cc0d0700471da54a17b63ea2824bb0d71213c102e9134d596a6d6cb6dc529c63c467f129e75470a6f27706ff200c86984ba71e3ed69cac0605c9fa2d652c6b7483d99b598976bde58949b9ea75ac18fb527b082a012b0c2dfa1adf24f79c7cc179c0fcd7ca0df202fbe96141bd50e419b1a6c1400731121a4e168bf3a016d213c1a84ef322595218fb6f2f5c4f661ac5a4ca5080b2b1c861e2554a16d2901addd6fb14dbe46df0551bcc1b38318c2a29e4d0c715b66b08eed2b170e3ae469784d48b946e4455ddba504f1e0b625788bed2e9e63d77c2f2b833da52acf2a9942643a492c9881673d1415cd4eb6d35a0ca78763d866298787aac4256ac2e5d81d31635b0e3e568d090a1cb630bb166242009f2167df83f00c5a1262baca952e2887bb70797b07be1df471527776fcfff70221104222cf124761e4c24547f1820e9c1d459b66c259b7b23b77b1fac5ff3711dbe4dc417f4e0ca08bcf8d61254c851db3b704f8a84d7bdab8c6437b70f4d0b2d43cd36e8b5fa4319ae0cd740179a7327bfc1ab6e08350bc6e787f91d93e43b9636ffd4462fc146a48c1ff9f2598df7d179571003ac816efa71d8353f3e7a0130769c809f9987c804f284fac960defe1c95717aaa4d86d3bace4c37058b5442878a2efbcca37811b2ed8001248e609d84e07ef90995f209e0658b4640952c22f7b6ca9cc302a8c9019b214153affd1f1f42b42cccfbb4360e98e9fe8e00e45bf82faef9644d61728f064e394d212afdf9ef0ef4766718e27ed628318b0ce084c667751ed86de2f4d077ed6f9187d30a8b89d2724fb27c395a4ed49e868d7e3017130b85a3424a35fe81f1290c9c01d57acd7f513eba16a4249121e170e35f355a64dbbc20fcc8b60bc8a9e8adaeb2fb467699ee35b28b21c42e7ddda2c084c0054ba9d8b250519199a70eb5f65ad2135f340b6bc909b644b3f509549f7898da662433292be66a75df8e5dee83834ad75279629e248c6c5e269f3e932ea37624579845426b45f706abedc341cf67e8110ace900dc8b480251b1f04f8843688694c5f1f065d17b8187667a0c26642993576f950864d9086ab8824f191aafa601022d37fab3e7d3e8030d6ea42ca9d1d490fbe9fec642be83e2b344c78055c12431323166730c97557b8fb0c868b374369dea8b44bb020796acba18894167a89dd2e4fd6256ffe64496aa1cbed921cc1aea4fb3c2d3cffc3cb24220d1f5ea55736f6f93006595612371062460b655e3233849554d4481c2b3a83e6543ecd1ee22cc8f81b68edf3297158cce78a8d8d7dd232450bc5a2fdb06df29364a5c08b14494bb4885cdc641bdd0f9f5dd246b301192648f439564d0aa499a265b6253e4eadbeebf2ea331118fdb6d00d1d141bb4fe3c54f167d2279f4471222b1e273995d7ff0974a35f4d63df08a5a7b0ee4d3cbc4cdf4f4fd0dc11e3659d7f0b34f4cbe0ad1a1e1176495f6603b7c48167fa7109b8d538cdba476e8f302b5709843666a168ad5547e03c3cc6c472391b235d3a5f8a412c7c2691ea360daf363763ee472767a526db9690524118c069b0b036567b3c853617dbfaa8015d5c4480e133631921d8eedf0c3c06550c34e53fe2cbb3b68e3fa65692065d14619162d11ec3476602284a28b12e74bbbb0fefbfc0a4fcffe3cabeca5dfaade58e48ce54c7ed29b335970e00c0b3acfb694e42dec2b6323eb8a6b4eac95500a4c7e5acea71ab3c3acf2d52267ea724ca11fc7ba3a7f7208606a89b17b7c822a6c7f4bd5ba379534b142664643e19c26e76ca9d496f4ea249ac7a93f5de7d99c31e0898d19cb57cccf0a9586ed251e7f897955b03adb1d564a01c8c09e4ca293248758547aae44a93d0f9fd9cb59f6aaa426170ab879b2a693a01db42f162877cd3d6207fb36becd55e7c4506d42318ddd99b9354654291dbf687c79ee2dea2905acc6e5be54c299abc7ec5985c148cede6e10472e13301245b7a9c774d930630830dd9e07cb244f047d51d9cd35634ba714fe706efb11a3cecd9f5fc4da36bacc821bc1a8545117bdf7ea95d8dbde11807bb54eaa3224980949ace053d8bcdc919b7ea19dff1bae595213a3b93888b51488e481ac92ba44905a939c9b1389d762b1f155c734b44715a0c271bb70455e71626b28b7af400539b007c0f6acf3f5e19ac0c05d57b8fdeae8687b3177a74c38039dfc80479175f9d817e26561de18e318dd0f445e493b2a97fddaf67545e1582e1694eb770884b8d72372039f5bafb5f6a7b2cd8a341155da4ef9cc9fc89fa2cd61e187906163a58a2e043df41188024022c4d0e905a84c1c5791c8c54d402b81155442965c93a4ad3d99612652c3611d8f0de3a88310e53e0b1385e78c691d8e4db7fda6aaa0954cfebb5842621569b8b08644bf7b6f0514290d235749e77b61662b9b698a3c26080550f9a5d3819a782a9cdbeccd61c7f7f6697d47e7166983e0e008875ee26448e91883278fee6a2eb9433414219220c0f950ad466625feba8c374f18913f367fc9211eeb2ada41ecc1ad651500f21b521a6f7f27be303452c6c503c75194cf42faf80d7eff79e5083d3fe167ee4e13801584701def5cb84ba41dd98942e53a1bf88dd4ad0b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
