<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ef0ac85fbd0f6271c6b65663cf7872fe4d379175c51a80f32d1fe5f3164906e64431ce5788f9cacc7960511935515547c3a3f86fcb2233fa1df28206ae5f4575f91e317f3c07658e26f6d034dc8f3952a8e4bd8198a24203f8d715d5e7a8491007ecfaf0fa42ac162f95ef4960d6fa8dee0d1c29faca994e06210257f1db296ed8a7e38d8b387d2d2e1a0452226d8f62be672c753ed9977e9f86482d753e87f45eeac45fda67b320a7a28f87a9ce6fef09d7b7890e893a378b89b3b7ea14fd806f7743e47c0872a0fad479492e571f0a40884b3fbda2202a7387cb9b51c2f0568e3326823870464e2b8db06fa38fff7b919125735cca0b14ca859a66501f4abdecd5f13ff2930a9ab63fada11d24ff4d4cd7cbdc5a755aef3b700e7bc699139e7ac700c872d83d3710a92533f1988d088b865267ffcd39117c2634833bca2c593304a9d9ca7c3716fbe0d4cdfd56c7c5d05291420ff99ca42713ae52d2e6f6840c31d5a455c4fc0272d6d23c6ee6965feca2779e062c21e0af0fb9550852b4b006bc0d460b340aa075eb423d229ce9a1d148040b53ebf9dc0a1d5321fad47154130c448623ee604d56a50abd00a2f0ab50a85a6dcd85b4abe1dd3fdee5f276f5a556dc6b7697c1b10942452a21b321da8dc1a4747704936f2d7e8a5bf94416a36d5429196d1d3370d71a6324abfc1e53b0aa44de72ef9c51fdc6c4b4820b86866daf5e8e7394f9a685b4ccc1aad3521b85c8ebc6199b0c776c84ddbc592b7a71cdf8bc476a7f36bf8d88e06f0db118d21e67af4c04163433441a9ff406c92f5dfa7cedc22362fed270d02c4e49e0046cc163dc8955ebdf3658a0b795bbb5fa18a6711cd742c101f3bed8c67089d204ec93ef93360a34d2fdb18b246ee0eb38a91506887b96986d7e3f3618f1ba10d512ad63dccc9ee1d630bebf8e68d112360df9c336f1278d5c347cc13a2f8db2c7c8a49ca800ae729b7ac27b152a5de90b4edb02f93cae6b24b3f0cf168e1687d70d1adb37fb6646787ffcef6730539617447505ff46545b55be6ca1dbf6408a22a540edf65055a5354cc00c83d9ce72ddb421f603a530e642773e2f9ba8e981d68644775645747c8bf07759fd320ab8d6b438d80d94d87f2e952c2106902c7f0a0f433317e27792f44174399ccdc94c1d0f1b314e8882f2989df46830df98646e9e713fd2c69e6c269b361267553f705cdd721b0aa19db998a33abc96b74bfad36ae086391271703029c774c95ab0fc2ac069809527fa808a40fb6be8466e7c1f325c528ed9df2ed72c6067ab8a805721eece9a73ace06a1e31bb2994dd57d898afe6f2970c86ff0db7f9a4c7032e10f4de2d2642e9935f1eb9b1f7a8507722189eaa736247c1fe9ef5434e07636806b6b22990d7b65265570981bbf3a54d9695b2390960bf2df4bd04ce570ba9165ef68aa0f51376595e19a339975052e043399be46e7652204a8dad0c6db522a1950ad73e43655141ab232483e3333742759fbf08ce9334c4a5dc968a54732b2edf388a1a5f093ce30fceff7f60d41a8908c57e33aa6c861d2457d554075a8a2e8cfc887e7fac411ce347806d2a484f2987c59348818d375269776900264d513eba44d5c2c657b87e2ec161e5fb4526c04bafeb04b87227eac90cfac7834b1868880e95092ddbf6052a2174ed94ce70ada5082be6f679e19473c545e28103c0b15e7d6c5d14ab72470f4a93131d36d09d51fa14dc6dc9e2ed5ac6df3bc15676349179d1e826d10bf87ab67930a52a6b349645b5d49f9b8b4d2ad96832af14be07b61a56c0c2a861570a84ac7bbde0b06b1f6ef2209595881a9cffcd14957c039073d979de12779605aaf748a11530df1d1662f3ce1198785374b2256ac486626600b98df8666d3fac4447786f2dd31d68bfa1fa26c35b206f77fc55313cbe09acfac7930047c10dab48afb266899821e3f247e198309bcd1100f959b72f2cd3da84e4f7a98d02f2f0c0620c7ad8c7e4009ecf298eb767b68241a86c3e3fa52293dee9e56db50043111c85c661a65db7ab4af514dfa446d90e95235453fcbbf4ce7468cf5d65fb71cc2285f7d1b1d6ed176143aef3d2dca6b7a47d76b88c1dd62f7e56261290e23f9c51d8997fa26325974846e24f08dfd6159429f5b8b7305fb6d19df5981568a09444e6f4676fbe412f8ee4333b336e83f829db66a2266030c5a7a35f28f377e6949a2591965e81607b1e625b50127de8038db09914fa1110eb543f7f788f56cddb08a99c3038a0a4acb702eb483f2bc5d64a86ab666c5d9b8ef055fe318e2516343ee9786e54917c5eb74f3b52be1a4699b8a86c7a38ef76e465e6b420cc90737ff5ab91868f7d1595be4a806c40a7162a386c707984c6f0f6c4bd4230abf65cce93f7faf1cc8a3d1fb78dd5a31fe8a75b5612ad8d4dcbc8514e9b9e3d73b6381edb018e774eafc855c040eaf86e37d12f55e34ffdd4ec35c800ac7f12cb81d8b81971c327494bbb2ac02ec154cb887bc8a33f142b55208280ff1a6ae9501850354d24bcafd65cb39892329435352dd80c83c7931ea15acd21c4cdd974746dc7ffb107328331515cd61549f96acc560fd6e2c279889111cbe4600e2e87a8917a49b1adbedeff4b738aa4e48a2c36dd198e5fa5d59b61125bdb418bb551401a8709384158023801e8ed439e733ae769541775dfed184c778925624cd57430d5332eef9e88b7554b13abb1554df493df7aa09d50fcf07d53e9b7c60ac88b14fbd1c339f64839fc94af4683eff8523692aef30b3491ba9d8b7db430769f948ddc8650b193423899ceac7d7159b4f77f403b49029fb527af62aea1a27104a7a7d2fe70a574226885bbe91ff267d673a80519e8ea21db0c6c51c2534e379e78858bb64c57b1614f432453279d3a5b540c3dae593a838e299cfd606266211230b83bdd2872c3ec2df636e56d6bedc7d1b7ded1b3390af1f25fa6a8f863fe55f7d2f436f862a297361631a558f7480096be50d1157f8a51c582b9cd5a388b02972bb731f3673a314ee74988f2e90fd1e0b3f72019f04b3f754bf9c7030df74c81573d59ab3e465be515b4662bbbe7fb952ebbc381ee1903f8307aee7078e42047fe684fe0f188f410f7c17415548188aaa1aa16ae900c8b2a50105564bf753b77a334e48d2cd85316cf116a9e581ac24c46c99b137fce5ea5c96babecfeede98a6f6cc13ab2f036fabeae24fc8f976b301a24b191aa4a8f8db446f8edd682e4df7876311cd48ee6bee3cdd62e207f367df9426f674d7b37c309d653c14670d634b58c51a956aca733115c748728e340637064571bfeb546bbff3f306f1975102258824acbd66e7827f9fe5e61eb2a5269c93b72fc82258e9f87fdb0f16b7060ee19531929d779f98c10fd81d7dccaa73952687732db0ae0509b878cc90279f72a2240c7baaeadc8cd5918b458f67e5398673cb909fe898b947f359f558dab942cc43b112081e1363f2713bfdee42e43763ae0caae84fc2f983be118b4962da80306ffc00df8fed858828d65ee30ee36a212d1134356911e3cccfacb91cc36d8c5d4fe407808d558e902cec99c993dce9b7cde3fa537bbdbeabf2770404ecbece6cb14d57bb97b6b9c9d6d2bc137ba391cd2b119fc7f93d7a634e1cd103e60b2a5bc1f2fc81109f5dd31923d38900024188be3029cb147918fb558743939b71e9630638dba0eb837dc6e18a9d9f02461b7266d316fb85716c71b7de4c2fb82adf72d2c2eea11c644e52f418643d263abb22e9c363b3f6f73ac37a207a4d09dae6c03c6383fef02d6f94fbccb7301ced81b09d241ed0b78ecde99b1cf8b7bcf09018a70e96b4702e37ad974936c1d7da606f53c1f047c9fe89ece1ed07aed419d1524f506a5c26b55f70d5d23abf4ea3121c1701a64a417452ac3d0b62f9db1ea585987d948380feeac3f978d321b5874f108abe96176895d840e01bef772d5cbd429190fd5b30a2c1ec4e2fbf3089e184008db2f796a4b7034bc6e8008e2ea8e7513bc8fe1dae1b264736555ef68c7169aeea68b586973e17a4d300c254e9c9e6ac8e8bce70ad57e009d760b79a2e05318eec347184171398a246ff3f3f9677659297530d8d1ed43758b2f7ab1239fb4e60551b4818accaf42e335917736d03b954be856012c74d46c42733a3ba560a969e29e10f6a6491d61d722ea86b34b01f8ae3eb3a35b9588daaa3d7e4995e20a4656d91bd48e97720a776d8d008f5c04d4c83b57d5d8e0f0d013f54a68685244ffb1524132279e07a53ea99c6a2c9734d8c742bc159825c590554a282d3cf8a359e8fe7e0c912081948fc4b95ab7eed57211503ff01eb05d027d63f6e3177f62e9ad1558cda40382c505312c0d6716e7a4e85d202d2d715e9211adb4da29f3992910956790fae95b417dd41627629e168c0ad1aefad4814687ee6098b80d910fee80537328cb9604ecd33bdebb347d326f298608bbf8be331bef975f6038d7126dabd75e8b974cf42b3267463726056084cea8593818a38deae73899975da80f06bb7460e8845aee8238341da58e1b8c9a284133d4218f0c7483d08d71bc79fd793cbbe7c946ce5c3b63c44c32578bc6ee6a3d8a6faee073e2c84b10f9a3a92ad6feb5d5c586f6ac9e647f690092acdc0ecb93a9436db350541ddcf8440e2d169fba135b8240cd466df163de4ba3bcc2a2042e914e5fd5addd44aad33ffa4317fc67bc6a06c02023bbdf105ddfc3e6659a5bd0b4ed7427c038d42287d225cb1282d6080cca60a66a41a20b7731fae275cdd8c5dc9d2fec9df4c749dcaeb9ef3464689f37e71ed136065fec99ce836b5382e804cbafdada661eef2fa541d00bad0839d4e7ec4fd15e5a7ae9a11da45458e3336653bb0b78e61df1d9841f832f3f398b086ce33176eff8d0e9873597a03b04ba4441c7da12b0aa006830497d9df651fdb8be442094e3b7b8128e0cc6bc196e6946b9878ab69e40a81a2775afde4771dba029b1065cd73ef4d0bf05c34b0da88837a3b03dfe5bb845e0b0a660290a09d9e9990578437e13e691c5fd55c6172d6f9653f5474fa28103527b066ce7d120ab83931cb36dd0447fbea93913462ab96b0ddebfa6b8d00d4d05e4a84d6aefb3ad96c7344829c15ce52b83f6e76577679ece6d9b2906691eb3fbef3be3ded0163348d7b95d57e6747de37bde9451bafe0bf6b7dafd5f416e6fb0a3aa359b8340890f6dc3cec52cae6784a1e14147b6a71d627f6f2f36e377fa7211d99eb938bdf66d49a17f546a8e34eccb3cc5cb94473f43b967f66b12b869f3227824c5da193f7ed2056fabc6ab9a16ad8c8ce00aad13d944a870ba647409dc24009b3aa4f8d830bf65e011481c54d7475c66f429ac4b652367654822934003fcd4a95a677fb6a8d7b9c2e5937f5b1a0c7a9e6b1059c367545c8db52743116b8d1489acb9b7dd38c5f643be13eb332243684d4a59aad0a5214438aa87307ddd8133cd70758e92d2ab860109a0dd1258d375313e5fb7a2eca1a20b74a355ed6799e12535ec22d36c3d9b4a62e21d8990eaaf1f2e03cb522b35e3b2b37d16e75af0bf8a56e4a2042a38229099ae8e92868f2bd6b348e55dd694367336a1b9c536f87eb93dcab5694c0fe709a66cb6432b2e3a684ed600fe01377fd38e1a7dbfcbfc1f3bcaf27e5cabf94ca81b34c68a6f1f38148a0b3b7c42ee9b2a4c0355453b08fd5a5ef632a54ad4c615afc5de6c31e162b31c2dbb294f71f8cbc3ab25cdcfee969ecb45136c812551e9ed7503a34922a08015609130d78cb80360c26fdd4f4cdd1d564095214fb53430a2cf294e3e8aac344de8679653713f95631d838151f4c5b74ec56b38e3c4de7a333c150ebe46c392deba1a150a87f4b72d66c05e7884d77c15de58e28fc8985d02ece991f90fe87083b5de7996f731e9c9309d42093639c5b0ae72596d6fa53362ece3cfac3f80ca7ea09cb193697feb7f6fb1c2fbddf20b952a984c47a22d5f02941d607dbfd404df6a223d11d39f72d2d48226827326af328386f3d18935197de788f86bfe5548e87224ed3f312c64fb829b659ba0d6044f2b28a85ef38e0907eadd2f40373adddcd43315defcc9e9f6e0a896febb6d526a63c46079d561dc632dcda81aeba721c39e87fa8975dbfb9f71bc017b4bced2257c3c1370512997eb3561598835d19967e2bf52b368f2a2b4a357c1c050ad60ab52beedd1618a7b570c8e4991bb5037d651b1111cfe6a09034dddbd9aa5117f8e646e40d971b00aa2cff66976af2754b9eec9f1ee7dbd91b0ccefb39352ad29ec06e1bdce95361e9e85cd48b30f67a6383f3c1c7d5d09c245f8b1408e8adbab778f60ac4d854dddd33ed81cddddb4f9feb00dbbed16ec78b17cdf2d7557cced943f1ce3cef48bbb6f7dacbf68415c8c9c0dba16d70ab4f6e2c27190a0dbfae6deeea10c3c857a003a21532f020fb40a3fd23a612def7367f79d81ff32086a6b4b5622e97fd736777ed8994da5ce97e36b094de7f9eac084e8c5a38e3a4ce695e650fccbde55027e6b5882759951c6a72edd8886614cad298e87530546bf2aecce3c8bdcf805f3d45d0e2fed70739111eedab23cdd75e05f8c6914d9f5ebcbf4523f4aa6c71cf83e958695e81ef6ca0b8f45dcd9e8cf82643a23886a798a53b62716100c8f42eae8af6d0b5efd79d9fe8df433bf0ec795b31e14e2519d890bbbda4cab2ff3ab0e354780aee42d92bf0f451353809f9740fff5e110b901016d80062ce3b70a79321cecca50f6e3d5691030acb3a858a015fb711df7d172d0aee1b33ef8929ab4775ea0897f6e64c105edeb5bdd4784691afcba98ac4b2fac00e86c06f2ce24ed38cf19521e8da7c40a9d63af87dd85112d84c8d8f5bf29a702421dd0e1593fb66d3577a62385820064907c90e30f072b8a7bd18750008464f13e77e54c8fc59c85a725c100692c4c03606c8d1c9173d23336961c8c6aa4e8b3ca040f99410044dc6dbba87c8e55862e0c5850b44ca6d489796c4f03a2b97dbe3e5f05db5bac39dd307839d956af85b7147608f4d99ed9ffdaf29be83427419320f5a27b75583cb1879f6e46a6882fd2cc8a19c09993455381e4921c39009ef0b394f287795737880002530040de411e41842f2e144680250e285ae905861fd965405608b7aeb8f1a203074bcee29d88bd2426c195bc2be18ad129ec28a07eeb5675c15624a3bbfc13031341279f7668981c550dab7144e12026afbd90fb436288b1db90aa49353bff48f9dabe30d2b214b84fa522b63e9e77d570281246318ca9c7af38ba9d63ef1096d5fffab3cb11ea3446907cba68f8f263eacb56a74abcec3c9ca96c934e4a600ef650d82fb8338506dc039368610651cd8408c16ab9c8b4ca2ccfab5f7647f755c186d09bc5894fd84cfef236033d834d8daddec7f9aa759940f7be818f085592fcdb1f03395ca087d3b89ae1ceec82fd2a6559a578a4f1c5197fc592d16bb8420c760f14e92fa5e08d4152929d6651742fa0db8a4d0db9d4a8765d7c5900fcd5e728dd8a41aac596968b56f57e55466b9845b8b96901177a4696f602e5b576677e5808c2cfa6275bd53834560fa73a83ca29e33571bc73563a7f0cfbbeff66a8de28d654926bd11c5ae006936cb447fdaa457e76b3a4e5d75911ff00b29ca690d29b7ad002bc8799129b1d508536a2cb6a487656ddc415541dc99adacb07fef581d3e9b80d836d2b2bd63c425f649f8975c42b4b45ce2d1f5e02702fd3825e88e86603ab236d614f4ca53f8023689a739b6cd1642ed29bee5693b8517b20c1a50ed5cf61e0549c4d29893c8156c3798e8febae849a0fbdecc01bfcaffb3217bfe345a1a0df5c6246d7af72f509e9cfec5a00d49f6e4412a518357b92326bec609a33b0952b57b3a240bfa8964f5c09ee74270ace707bdb9feac2db608441e2b2c95e6b3bb33b39ebfd55f20f0f2efab466ab7c37140918c8637585a8709e1949c314cf50f50eb811e36a0f7ed6d11bd2b44e78cd77beda6b4b6f2a67111e3567f1a7ad7deeae4b56cc8227ee08dfc915e725936b0aeccdb3a2bda65bca940023cda32aa04445cc5f01f4efdf741bb3f513ee8c183ebb54961d3031d9bd94d64007e7f8ca390096fc3ce17c8d404a241543f92aedc7e967ba12a871954e0934171945d87d4d667b3cb13111cb7cadeeb5e9a3584bca5f55866f5463e4897c039aa018a7ec5c6b54bbe7adc7a90a09e6886451dc1cf254fe7dc6c25aaa14e3a90bf0ea5e19b195c8f42e16dfcb9d55d6da2216f9fda0828d8d7abf816d6d95dc224e6a6b9448ee87a9907bfe7f19d688db81d3f54a64ad114dace30294b049c14101215411e9a992e1a7b5b2effdd05b765a68c708448d8bda8c535f84942614618167713fe1a7e38242d25d63e157d2881285a75897709f0d378534832833719c732f5f066902a805ce00c0560ea1aa59708e5d8fd19ed3ad3a20a9dc575b5455749283c58eca49742e471eaa1c66d620ee3249f5cf1ee3cca2f00d2833b7b8814e33a0d0ecdb02f3c379b55e7b51902a7c6948eb848adbb56cdf2708428053483c6ca68818efbde174c1cf7c7f401a5399129a48611c3372b1e5b2038d5ee5fc1b6806f809d94009e81e51166174589a735365e3deffe08292e8d85a9924836e231645337c15b41c9fdf9bec856bd4bc1567ca9bb62f182ea6c6418e93169fa97ef921b448a736430cd79b7107f0b10389f8150db0ad4f58b252866fd84d446acd10c4fc934358735f6fe3cc95f776a54d34bd1a4783c4d3441c95c322cfb962542bd616af3a9ab208ec2384f456bc6550e0ecc119433a6fa1576b5c4890845a0ffd64955060670a28c6be448d33210a138a503122045ab40b46ba66eadf77854896487cd360459655c58590e3a12338148243bafe7954a234f285763b79ee62fcb95b1e106f91f9f210caae4cc90d79c6e94f69d059af6e78e9e0947dca59d68e327d9fe6390d07c7de6ff69e2eec415a4e82dbb8010b3b1ee3d8b709b41e6baefc7834d48958756818532b8be59d6019b75a78da43629662ecbe87736bdc930ac62040fda414360d4a231056b35b4cfd67aa13f6b44a84e1ad6726c306d4955a0290fa2ad05f1195be7af2e4f4e4bd3f0743d8d170b58c4ad51b867e8c2be643df3d06fe20acf6225eab3986340ef3f32abb1237f8f6ab49273f5c5f837925c2534ec2ef3e217d747367d63af71043872bf3e68bca1ea6b4aaf49ef843ab3815a6cb3b5d478ca30da371cfaa93505490d14e0849c194a237b0c722ff08dfcf584dce7f7e7c5e02005b3d3aee8fee501465ba2994957d9401e210d493ade76ecd05166da61d0631a2ddb9432ec05b58f24b30b91b4a6306e5472fdedfe57c59179b226fce4a7afc229b39f532a39d77b3b39a49ab0b58ee8f1b0cc201da0a08fb27c0bcb7592c23ff39a614cd185de4eb514cc0cf196fedee9d1e5a7fc2939bf042aa06facbdbefda0020e43eb334cbab3e9df70957312286eec4a525d86169cd426ed7b1fec2f540d0f746af67729aee701afe4275311e9b8006c8c9193a2a659a1d763e2ba7a4d11efcde8fc7725db6587203c2ade9a64b514af1e434972f7fa44921db05cd33e60b5bfc067b865cda412d6b33593692e42590548d04193361329b56ff00407657aa006d7b264f6dec9864c7afef865a17c2f0c50c398f7a67d4a395986b17c14abbd012d630ea98193bb94f5fafa78ec304260b3b7eee0cf94d0d4881d1c50e359664695f0d3747cf1c271d0c2df62d393a3cfc60368c0cba8e9db33226c3e4321b0148c1f89a53865d78e506f2d407ae4aa7f4799173e7af8a8316e5c1a0ff7965196e5bebdc2053ce9fcc448b725e516b7937623b84777b9071d1cb7d75e27497baecc942034f2da1e94b6dd9f95340e29c63c1373d8f01a4f7f9c022a122187e590a4960436a1a0d70138125f0409bda833c729ee762b1d4ba916e57af97cece440ad0ceafb5ea4a2e963135814ce1ba9f657caa7bef12e54eaa73174cbba07d90980766420e35423e00689c5caeaa5796c098f6c7049820fe0437d08ae5ca5d3ad27aa21c5107daf32337921b32f34eff05466d0b5a92ec8ec08db5a81276a20fee525586e1502eb84b265bc17480991bd12b2fcb1fa672416808214843cefb3851e4c7149731f13f71c096b1a51e29140fa1af81251b2875722ed7fd9a32d4acb82ddf8273e85089b53e52d94dfa67ba2b3ece5d2ccb7a655e0bd61d3bde826d24e56083de6038d6cbb9a8655f1453e90d39a2681b5649f518514f2aed6a01eac34b3c66bbce15aa2eba929c1599bae210d51b23087d227a258f91613bfa079279f62683456d1d8a00a0cc2184f5a73919b72e83a2f7a71ce9e768918b8a3e915edcac9fee6ec79b2dd020a68739c1340214eaa704d25ba9fa8d705d4bfae9bdd5092c29f04d5a4bf0a28273f1478177a26428ead0b07b6b440c159bca99f3cfa5a9f98f1292e7e6e0101759b20ffbcefa4750dfa97508259347cce552a4c5aa0e272361ee5372737b72c9f627f57a0484a6082272f36f611f3a3d5a1d672781ff3a0a7405d25cb23fc04adf9cb7e8d62548047446d24f077f32301c1ef3b57c7e22ec2b808194eaefd6ee6a4ff5319ab8491f4d987edf589a4f485725d5c47eab320727d3c7e75679f0b5c92a8a6a4320c5d16188d0ba9c4ce2843bb01eba4740d65a9dd3648f0b6de0297511ef34e711d18d7796a585eefe3b472c545c74480eab73c9af5aa668646ecec68e501d2dc0663d7433cdc833868db6ddd379dcac50576daf159e76358c24f4530e4ca02d8eb361a89850b77cba44d15c2fe04ac8ca60d03c4d29a892c088ed57a9181788b29d2b6b9c81ddac67bb1ab0a2661c5d7dd92c62c84ecb00a5e81742a2c1fbf23db3bf414742ad490a1b526e35e21608d1c3e02074c8b21f902e20cb6696a5a9a5103d15f192e89e5103aa66e5ce91614c5e1ad3d5b403aff8147afe54fd492ca2421aed379141bf3239c0a0b065ae3985ae145ddd84a79f75aa911db842bfb461dedd96fd5e27633c3281a82419023fec9374013b636f2f4041715fb639c9aee2e9fe39105fbe480d745efe6f65dc91d2b7c9d6d4c0ce4d23ce215ae9142f25b0643cbef42ab620c3fb284ee523f609bc943d05e7a7459266d348a6ca3154cdcd92626482d7e8bcd6c769b643587a95cfa931d8ccb786d33a0ca653e107bf0b6803bc20db5a7dd759df2f4da6c710655c8075a9dfe09da8f56cb8b1674fd9562cf2d4b9f019c74fa0083b7a3c94f96c56940e7680486726be21312135387e37c8890acb201def275e126c9a62cd386db6bfbeb626d1b2aa597106954035d11684855bf3ab78f23ef31ad3a0f44d7dbbdfe336f48e222792fce817f46660201cc58225c1f14e59f83062c4e704d32c809a754cd40c48ab66a5d665879c82966f70b82f2802226762e2cbfc552742e10bff3262c5edcb2d1f2bf4c6d769f921a984a691e2dc1ebfa8c6e651daa779c6efe95d683165a1b5a6e9bccb7d300f75c3a60eb223733af753eaee072081fb4d015db51ea2308c762192e9411efc4fbf1cd621a61f712115a84d399068c529e9c14b7a4c649fc60f0fbc6f77ab8bb8b6d09b73f1ea75473b297a9d7b1e53055931617a3b7313400cb7af6edd27853995c320458b5357eba355b0615570d695a42363716b94d966967c7c82d53021111abb1800e59f85cec6c4c17a1093fff95e78ea731c751c0f04e62fc5952bd539753578ebe488f43c92e2e4d9dc424007449a1bffa8eb8d371ea8ccac20db529688f8f4b23a6c802eb98e57bc585549fb852b6be7cac0f301a35ce18720a310107479f841d30c906fb0a836bc51e8415863b721be4948c4856ecb06e45a452432406866ffeb0e91871d66f2e79b2a8c61738ad80c15f4f81ef6680577f4c19f6addf64014dd37e3a54ecabbcb88fea97780cb03853ce7c0fdda8841667dd30ece9f401ef590f9d51e298dba2170075cb19f7c1173e817f7459a6fbc8b169cd57e682dadbf26f16713d827e575b09bdd47f11564c2572e094d2c024ef8e81dbd986216d45590f1ca5d07cccb1773cb7e5d44feeb759795c7dfaad4983a66d009f08fb1efab4c34fe84d970c242c0288f4cb465da65ab361f1fbd589b2359fc5f98767366a7298e5731021a8124e8ee21f89ebccbb046ae39eca88316d1931dab1a827bbb76b6745766097ef160b90ee040fe374a5be9a86b70dfd65b99c765949b9e79aff278cb1098f2c884878c206062465661d6c25ca292377a2ad62c2bef3948596c19c1324a571889a5d492cd9ea8e3ea5cadcc90168d179efc9b98755f600c858dd1d996328a86b1860088078adae3e7fb2c90f70c443b9a9b93700d13fd456df6e9f2cd145e854ad7307fa7a14ebd3b771378b8ffb981d49c611e9722015e66dd4c62bdc2f388d892e5ee48be0355cce426deb6158dff2be31b3a8f8e1667eff8bcb0ac0d497d730a2475257fc8ec1053557e3cb607c40808ffd5a612d059758674d81561bfea88ce2dbc4fef41380b9954352bc092c5ca8cb60e8fa998b05317c9b2ddf387baa000a54f443f3061b50a133343914649098e92055e4fd63a69bfa68a419f29be403cdfb4b23963fc114a7f23f686ba42a949fb9813ce5f26d2f68850d810f21f29ccd6d88f86516ccf361778719ba659ed3ae630d2ac5c3713320eedcd9d34d96f338623e892f70af1340de2bbb567841344b166a3504b22dd4904e2a088b1598020a6fbd287d95c34d6113cdc1673fb0e29371caacf633c251a9eceb15bb5b0bfc2d51bd904e02bd1002d83883bc54667409434d5c24ebba4ae9588bf1a3076b0a3bb1e9ded5d6b62ddc535179fedd3b14e95ce75d6d5e5b87b718c7980a017fc4a58146c5b29b55f0b2dcdac148b5a989c2e722a1a62b9886244a589540d52b7c7bc4f76a0d03dfd8b9d42f30c32e379ed71bd988e8d64fa1928fa095dd447cc96bca4a4a79906822e1591794e0f6fcb111a33eff3fa2b96af2481dc07d1ab3391705eafb695ac192e6a43cd1caf7c113a862d0fe597c106b6234e8d87a408b1c42ffe857d8d014a4c471e5a5b005cf3c26c30806e5f79d8e952cc5be4a9ecffbbfb00cc827b44158328a8b3b69fd21ce080e223ed0a88ce5eca9ea1cd8663d46324717ddb79b020b039041aaddf85a9510a584284b39e3271425998489d3cc006d3d6a8d94d255c6cfca843fe775c5a619c6276a476d0fa224c58ec6888c10393126b8cbac82f2f7f52600aed7897c84a102ab3dcebc6f6a83829079aeee9bd52f7285a1d12bc58f70a0d507341fc8f146df881f291b31609f73a0020e393b47ba1d5c5ac3ec5c212cbf0c85dedf5275b5f5360f419ec7fb3eaed9ca12cf78c968d2dd7f413384fcdb78e342819df70c17c03c0e97689e222ea1b8d25a8bab6f4c51182b11732385ca3d31928c55f7b1e65b8848478b784e9ff64523dbcc16bd014cd3030fabc13b10cabd260465060d5a71279c6d887db474536ee187efa572bd7a55474ab3d6e455b37bc4d36c7d6b1b40b93917276414971c776b792bc14b350536fe2f3a60ea90411109d536fb279ee47871d8901d349e37ca321411beb702d4f7adeef5fc9704af30ddddca016ba0fb257282a321e373cd7527295574d714e5387a77358957752bd377090cef23f539ef6ccddf6f81f4c7a75cbb3951fe9dab9fb5fc51077d9a0878c53dc3fc72e2b7146fa787e639455e50edf2d0f67260bcffb1d58983f45b34b0dc56dae6fc5c78827aed169e41b20f7edaf4a4cae1bf375af887050def905731db842f2b1f156bbcac2c12afef5bb9365844478784adf5545771d91de84686176a58820afda9a13f40eaee49d3293796013fd3d51fdfeb578eebedfe3a2ff7fa7acafadd032ba0b4162210e0e450c26f352d858dbce6a121ab730e0733369b1b5d6dd10717a8012d950cd2a21b26a3d3ec28a93e2cc4bf9c4da8ec76f030f0cdc00cb7471d88e3d4ff8cec67ccbf4b97c2c666be0cbef8ac9e726b05c69f3b9f66309ec9923b8ecf1dc837015bb7d675e507860ccc07cdc7ccc2439a19c25caff754d17d1a1a5fdae5cb51e24b0398284db16bda0ebb62a750813805fe5e40ba57cd376931c1e0ea039b2889ee33f6aacf7ee1ec3806df86cbfb3808cc8990ae8408057eea280832e1c2e207e9c0de1362188500ec986080112b36d0af4a85e5e67bffd75664685531e9533ac07dd0f47273d31a9480191345a513d3b83fc49bc3f606ef72fa3f55f47591ac9f3d976db24c34b514addbf07ef4a00488268339d15637d8c9e904f14988f9e96a4288388a3ca8c92afb1964ef6627fc7ee554780159c7fe3ec8e915bb24455fe191a01f500a0ae82abbcae2249f54014c301df32780658da1a12a9b8b625836cda866affe686c8eff63522e5e626bad67ec4443c2a1a333c5f7d89696ccd38d7efec63ec559a19a54d1ed326206addb53b50cc465d5d68bd5e2f0897ba3d473bd56e00370ad6179a32bde182eb58759064484c3f0a60dd1f0e8f08077172949792b28716703d3172f1383340b71f5a2e424163912da1a0d690cd07aad0c689c16c056de7af3e1b1ef81de8ee08525e7300dade129e0238950d427fc9366b1c4031b6561f441d2d4117c438e0ca4472ef2b84ee9e64308824b922044cf2d0c89604458571d977a30dc641c29a9be426ce0acf7879e1b790aec45196fc87e355933fb5a1188cd19b86f206ef56c4722d57390332c780c4724b06c7917fb90430c6dee2c9e67298899310cb932cf01fb2fad5df4e14860ef7ab79dc13d439fa94f554c3fbc9798381679806b65b19c9cf2b8de4c6fb0d0a6c45a68a110ce31a1ec8a7297a07f3bf94d875dcd9d714f997813be5e1f9ea9c863b009a887fc1e621a42a3ac3b2ba213df8a8f769e25c252d12f46b3363386ac2b4b0e7092219e9f11e14f5d8b5d19a8bd03cea21d799f5a125f3125ba9637eef9ae606892e3b42f70150521a8331dd4a37e8add9c1014fb71d1ca6983de833abf43a9c18b9db0808db6e811ca428558c800305a1e86903bad38c50fb766fde79c6a0ee3a909fe716ceb5b7bc74bd84e954d87196e70f5448f611fde39af0ad3d6b48470bbf4edd2cac3c9adc06d4018a734199fd7df521f8b97623b0c32e02c7182b106c533c2cd121ea71a56d9ac0f7500148d561134b9a28b92f7f0800efcb390e1e1153da3b51745a7b5f68c0d05d3bb26889be77c9affe491f1a4431df18bede3e9348b71b7dd13cc766a0dff8d3444724bc21989","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
