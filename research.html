<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6695344891a80b7bf9824431ea5d40bccea1e9b730f074994978eb8ddf46ba3b74603fbe02b7e735028c982bb5839db8fb257fc1c24bd36cd7e8f8dd2da10676159f3c3dd4fde0f18b4261a08434e9b71e747489ec8371504168d5f28a564e74f79f6e3fdeecefeb64c826a0cf9ba6e9bf1340b774c5d83ec495946f71af1e607608735e5395c82b65e67984a94848bde58d734250de06480b2448f31a41de461c0c2e72f9ef59c24d636a2b6997dea0280d13ee3b5b5c407c3ed4a7f9da753ed6fbcdafe4f3f11e5c8a1910540d1fa10cc3d9b0210288bca8c7aac1a396fa27964e38204c202df6b3930de843758e6d2760b8e0fd637b31645f565514557c4496d2d01f78657d933f3355a5c516dbff5f09d1eba36efe8765329352f02224803f286e66cd732cbcc356ece08e273f503d082696e2e6b73a52c85579f1a2057d8b41dcd8d05e911416b81a8aa0eefcd21463ac93545c6665d5e273ce7946a11a1db2c1501de7d273316201c0082a0db09db3a744ddc60e7dfd000b9ba9b3a97a547c3ff51658a6da220a69a8234c1cc9d99abfa71c7c96dc2955a39fc06973f5699a76d3f5a8d2659f8413649bbe6f548e32f9c2e3a4015f3ec9ca00a696d960f1ed46a5c6b5f4f819b15c83c368e641c4637a767390923ea37fe9ea59037b15f8aba02bfddaf1622f91bd3312827b9243fdcfaedff9bd1b75f59d183f8b777da1485841469ed2e7319a08ba45cdd35e30a4486e458a2bdcc496e33746ef1a46242d67db86c26643335915eea40ef970bd0b86f5f9bcd379d3767c258ca2a07c4350c3ebac9822f669fe0f9e4e3fa0fe03ccb071f352dd66c6c0852f214e79d158115d1779f85d4e5f2e08415732f77e50f379450ba4247bbf70bd9eeda7b3132b5d1f98b528ea835933e2020fc38b4fa731cb0f8e65951ada1b1675a8007fa0fd730ed0e4090301f5118c70a7cc30b846834eeac98fef3464acd54a1313fffc112665252b2619d26283f0c7e10d3cd4400b9a5bca14b737224b65feb0bc97c963d838e2ed9b1e5c2cc88fb594edd826a94342f3787ebd21dc175612c9971e2f9112399ca505fb0b7d6e4060b901df384b82170d889642b6c6775b85dd92765ac26deb32fa39cc20b6b50ce3c5a4635b76669d722c636a0ac21449221a0942b76dc82d4e4e55a0a9ff197cc8a4bbec94b63be484db6a484358c420deb830679fe0a5818c3c082777dbeae9568513955d2d5c2ab6b68941f77e015f286c2068dd28a8a831ba1661baa1b9352f76c7e42f9e0cec75d0e5ae0cb5342056cdec471330f236e0ac508e2887a9706192215e2baf582dc1800bd051d3adc59b08847f606094bd8189417570b0fb033c6b0e172abda7be12d68de079fa92d111d079447e1c04a7c50aa0a0aea61b7b017042a9f8f03b4177fb7f592cf68cb2a2bf9f120d30204a92590f84a3c23f705a73fbde001c7a2a4b1503a7260a57d1ad708b79fa64051f28f33d63a25bd746b20bba08ae266db08bd8cdbff4a74fdcff9edc8225b12002d51f87b9b012ff7062f839c94e1fe27a4db8fc577b03a6a793f0b366abb3448a918b7b9219cb338614c3f3f66b1d655038d8d63e9c8f963bf340c820fbb4a59d6945cff3753424e3346e22ee03043b60604bef5325743bd57d2366a458ea44aaaa2aab78891f80b4c1c8f803d603b180911420b3dac48a84e1c7e3163b5ce945e7dd1dae839a7ff39941d3153345e16c384c2965ce41df4a817eca28b0777705d6c1cee1d95c0c14f0c0dfcde9d5f6ddb27ebaf37f4d730dfb660c1741c415b1427bdb98d967524d71d1cd2ac70484e6a5d4a49d6257b2ac71d845a6dd9b26b12b65cc4b112fbfa73624844a40b3d2930fbeb78cac00fa6a5d0940b205963d048fba37112f1d230c515a453071400fe9ec6915ac17f51ceb7771c80e21c0972208093baf835075d807843d7f11a6635e7704db3fa92a9caced9e82b4577e0015c1dcaf188dffe4c1a5ed39c952e3e11fa92730aa62c317ad7be2723bd58782602ae2484bc6ecceca5a407843c9cd930660004bc161ab8eedef62e1e7f97b74672874a90e172a53c215a1d72bb3351a96fc74f146973745b6a508935633470355d559293219af63f37e89235061237aff7a67a806cec696cab2ff5baf1ad55dd6c6023072f4301da3cdec603dd71d977e9edc071aa0d4b698a98296495183b9876ad17348d2be8d8eb14f8cd3f1c87d07af51d7eb38e963278ef64388e911bc17e7effb8084602906df0d8b685c99c16da0dd7218dabf9aee1815538bec7d08716ba1dcab5bb1144d9f97f52301d1139e21fb7a9506a1c939031b04730b8eccf001d0feef854f1b78fd3c886bf9cc80cb3564916ebb85d7b5d07411fc150bfe346b216541deb25a4f96aed13d028727127cf62e5b23a7fff46fc9fdd9542dfaf52305fc7547ae6f8884f617f66089ecf41889d885dbcb560ea62ce4ff0f8b10c0fd1c06b69d1b8d921aad1a6f23b2c936a4fd6a720f98ace0b2d399e4e3b365c8635e320499bfb2a76125a6cefc83b3b37057e50d0d4b2d7b22f11f2730d4c7e6e081f333cceff260586df7e46b5c01782c697e18f123703c7bd1299b4536d5e493c2bf0f2b9f44d87faee9e5e0ce054d55040e4313344d2ff2c1206b10b6fd9c479b27c9b0351e551d42d209100db03dff2403ebb4084e36f49bdf7ba2bda6526e954a41e41d903c514aa6f3283dde7a532bd332f519532e7140adf398fffa4a823a7d2eb4dcb38b37c92fc0de7a5109e4309eed1d8cfd01e7bbb8c179eeaaac247446a163e9dbc9ea224e1e4d993e531587f8e38a6055d9373b2ece734a9a7495335255283c488ee4a375a7ef4faf9357ffaaea5e8c6e774427a6d470786e53f1dcc2e891aa1da476ead0b1463f2da2ddacb4cba134c31327ae2db4eca4c916a7b80b22414e070d8db9f608f7a0d8d8fa37c2911d6eb43f98efa66dc86c50a9e02de3800ae03c70a698e27d2028f868b18d8edd45c6b5deacc9e7847aa09b3ec71a43a783567e9dd86b6788ae101fcb40572913db4b25649bac1e5098ede4c149d73d7665fda5dca048fffebf6ae45acad46b907b1265babe78d325462f66c77abdfe63545cecf68d15cee9e35361c1396c1f26cb725f96363125486230212673b1f880ef1a03e0d96d42b4ae08affd8c398ac30ece7c00a8095c2d5082cc773680ca7ba01b5191912b153b05abba3a6053f065841049011916a9cdfb8a2b61162f4cc533c6b67059be5ee82790379ce05d523bde98767ed888063c264293f13fec328b6de0ab0d7d0a3b363d71a208c1b5767fad9ae41b341ff7082a812469a8abae76744e81d394d01cb6fa691dee9d2fbceea76cd5b213a77007a05148ba05d6c5287c6d01b106efae031d5543155bf6550e6c781c8b65c54dc2f2515319afa8092b446573e5a1945ef02ef00b536c5935be56eabb254ad1163f62b536d6340069309efe5ec413cc6034e9ae79d2646eb1a716230a4b25a83e94b3d7e89ab6704fa4fb50f87cf43b3504f03ac4f2a9c3497eb3317612f55162f51dfb0bf5c02877674058e0c060bcae0fc84a3070c5af202af1d9334e289dac0f5ab285440a13d4c464e34d79fd0b0cee7b53807d1502f3bac5076918440e98023c9de9d6193c30cbae338d2c2116e98c771c59ea72e05015b8bf96c1cbd3b80e4d671c53de433fd88972554a0fea9fdc350a29fcaeaebfff1b2e248aad7f6bd1e8ae103cef58c8bca6e3ee5e30a35f1d7f134983c760e7299f09ee6daffe890841d262fbb44c8095326f49b081138b173bd237c3d689f3b73c4a118bdea18bbe5f1e670e0bd554789f4fbb179ca9550b2c78f81e60867c3e0e28c0d25a966b7c1dce3b34a8f6ad7de0bf33583054c35403da693d14709aea461b52ab7bcd92135ad2d9f06ffef85e04d09b049a419b3d5cdbb458913dcb38532d2082b7f0773c89bf9d6b20445e0f28805e13dcaba3c26c4daa73c0d3e81e571a9e20a7b5a39d1e41e36924588b3ae3d1c708ec74bc303cab1d89274bee9f06ad9757b54cb74456ef03720b3af9f48b53b385bcdee5a19103b0df4bce019b1523b402cc082ed4ea649f4fd719e0ff43e1dde8374fc92cfb9dbf6bd471ddc5a5609e997e2d77cb83950d46e4540bcd7e34dced2a03af8fee14e0ecf9b3b3b009a9d1e5bcde2c60d9213c69386aba8aa6f8393dd3bceaf492ec55a21e532ed16f44345953b017337528e6d36aebed4b03d49a9312ba6a5edf0fa77f2c0d633572c38c85462d0c62c04fd90e418ecf00f8abdb38c059f6ce890e02d241b1f8d7ce84775fe4c91ef9a9e982e62bfc420fcc5ab9e19f965f818660d71e78991213057779430aecf3e35174c04a8471848d4bbb577b135d7ba0dd35e7e84bc0ed05b22ec17a29a610f11411bc71e4a57c47c6e0ad1fd1264889b6f5f8f437c662db7fef7138a178db28a74923df89b6a12ce71d1f095004ee02c08625ea7622d067bd72a3004eaabc877b22de4310dc2ca81b43c883056f95e49e2ee2f81d5fc72f2c6be3800c594808406026f6440afdc499b141739c2cf8160f91c6577d3f49a03789159812564facd130c491983024d948062c3bf662574c15bb55f85833f1b955fbf4fdb7c7209e3a28b6bd6639470648f2da662696047d6ed30b0c58c81443414adf63fd5585a58ccf50558e83c3afe32f53252e2b168ca19555b4c89b3c6b23fac5978f9589df751580735fe9d68d2232625137b101acfae4e6fa9ddcb3c9d99d1cc2425b45d81bdc5bc9f8a87d26cd18ecf15ddf74fa8fbf2e843b5400b34d7dbf72543f3fc82c4e2804cfc138873e3e412812a38784412a3838774c66e79b7641d63be529e5344557ace788faa3c88ced2b396151c1f1254d78ee7df8195e38d4f939de3460976cb14d487d42e751ba69751384d3ba5d7f4460f1112fbe7ecd1565e1f211cba7ccadb1313ed47e8324ca4e5f61ac2c62239f8453c9271ab0f7b1286f7f018d8cef03f64b3cf405fdeaea4a33aa3c0940376638c1b7850e7cb25f3ebc5f523cacbcf25da7fb140fa9a4f337f7048a2877e3479edb57fbdfd3b72304c067c8e131e4caafa6df83c266edad5122b1b401ea67dc23ed67edb8b20a855d1133586dde1ff868c32d5bc72230c4fdd4e2dd130859c9f361affc4de7b7c3a6b5ef1595b639174d8a50621f1de1e45cab4c2f18e0f0290ace8e1acb36ada546d9841b3323375d0454c592dbd913b7fc6089fc537f3ca9424d9c1a8ecabd5087133ae5f69a19eea6a789b94ba01d92f0dea2ebb10679a1ba1ea72021e6258ade990216c6410aed4d2e2b5247731bec2fb99baad21d2579ab9a80a8332b56487d80fb22f28ef0cb1cb01e1b37077395d44f44ba14bc7f89155360d7a156a5050e3861387bea8f84e85062c0208436917df804016472fd06eccff28f46c5d2c1ff953a2e347631ddcf1139bd3fd7509f224340d326820d8c9bb4130e09a91322a2ca5a330b887267bf5d7c3eb237d4cb2f4e06faa3761f137156880982714bae53d37c87df4f1a88263eb5cfc649e1bef00375cd49b975f50f12a1bd0de0d5f064a1016fc33fda152a90b96213dbe6eaf27aad98abc02c8272fab2b40fa456d3eb3f30f0d09f3f66b42d76b9096efb6b0c8081dec5e6c344206be6d08d5dfd8c7aa3fb1a87039beb4b22f797ffb80ee6052799d8d2f564e33d412b6cb3e7d4c26758fd4576772caf7fe96399b0f275e08aa49b30b246af2b9d7277a04bee9bd57ac2a12d0550b790662d276e8e3a9a9eddd931d6b7327007d7f9e5f5c2f49544e9ba3c731ba9e8d8a185a10723587e0523141ca258dadae0790177d7103254d3be6ccf4c8043f53b155a288811f743fc1ec459344df6778117c6454ef99d1d1812d4c1f37720e1baba83018a35855aad5327fa908f5a975b053305d908f68976f8c3f39e407f0b204187da7940b827aa64ac1d8d9eb7b5c845f317185bf281daf5f8501f37d1373b45bd1ebc90fe43532c567399939ac90c3a79681a9b3243d85b73c072011dcc1280fe6c7503bad81d778ef901105c29c2c47f25452063a4a9bdfc37d242f53cb8a23f2bfc67d0f09f4d0127f6b4779e172ef04ec0e3d1f979adff884d5f74efa2d291b284d3328267865ceeb712ecc87195f146dd0e225c612e118b9b0a9006c4f9067befbd435c06d7dbfc6f37eabafdccef40c2febdd51af1f2306c4e0fc8725ea26febbcc7bddf0157433ae38c96cfa2db65f4170745ac2d7819f4714a2a4affa835229086757d2d42f5e1cc9723b8fb28bf5aaed8e02b2bb52b4def0c4c835c28baaa76fe71e491be4d675b4b75fb2b3d13b9c1abb60a1b52fcfe89f7f7d49db9547b9a06c62e5625c6d8e942f221576c8906e23947925dbb0e360ac17439d677ad8058eaef9eb71bfe045bcd1ccfd295c1cef9bfc09ac45f5b78bb6e940f822fae6eda0022fdc2f7e63f355a1281794909e8960c771cd46cf74ba9d3d82c3a6edbac0c79bd82ea13fe4427838b079c0a7435724bc98b9dab37322a40383abc546a6cafe15513436b4624ac5add4b8a9ed9da77ea1dcd583f7ea153786b7dcb29fe7d81053cb39f9c13f9a592e58f38ba7e9fdfe0d71c198835dd5039ed6a12371c904855660466489ee4d654bbd55b77ca7ad23f3fd34405ea0f31582692dd067f29736aae52bec2eb9fec4790d211a62f62e9200430c50fb2fe09b63566adcc3cda13d54ecaa81e156f9adebea802f9bec9e8e544e58b084a43201c82eff53f8dd2ecad26269893cf352a422e3a4e115da3648f45972633d48714976f900b58c2650599d6ec398d8ef6d7e2a263b407819ab9d7d293151a6849f8de588ebe9c80648c288248ea29f257b91c39cef061e84407e430c5ed604d5ba25748f906eed3d4e10c3a2e39f0b56219e46290544b0a22c145da50293737101c0cb67e65b9f882c006425a054ba320234da5bea09c80626f63d7661f2262eeb87c74b53b8de3e1c4f3a15e0f713b0758c4b2820fadc3dbc7bb9c690f0d223fc152c09ab3df3fc737703df8261d14ed725217a2c869050c20f88174596a986a081a5453d8a8759ec37a74ee8a545484e4f562244548a954c0d1d5ddbe83985dbbdc5b5a88821c98bb69cdac4f2165c9fde566e5285b82ecbdc1d5e5e9fcf9af9c192101f96672d2d1a29d851483937ba41b6d6d96eb1c7111820b2d5ea0e0d8c7cb6bcae747df0f2d6e2d76190b5a3bec2dbc3f040a26f70e496d853000d5fd844abcc28da225d7c249bb3fb329be5bf86c5e76f6dc05f994ef272e6891c186a89320d9ee52fa174996a59944cff9e6b0c9d55f4dd5388ee5ecedaee08b60e2e00213d760f82c727fa377788b55ddfe700ca404b7de910547a8528077f99b68e17ab5d2f4cf275d4591fe4b4696278304f5da440859ad2a483ba38a5faf991d11bc742f81650e08118fd39c0b2ff3f5d6de0aeb3f27dc5da7e81320fccf2ea9f86bdf99a09b1435bdec65d624a14502a625b1c04a16d7c13a5fa4a73bc6332aaf7f5ad4b10ca00adbeb62cd8d7ccb91652613779d59c13656652775800f97824d6cc584cca9dc4a2a5400af45a85c385684e63926e0aba06ac76489a33fc9ff97c7d2b5db1e7af24c3359f569e7f765453e0e66bb91c3509490132a013ac9b6b53a8912bcf4812daecee9c47361424b3ddd1d835e31d8ccd668616ca4cba3cf5454b4335105fb48cde1e7412af19bb167ba32edc5268fdaf4c24808716cb5d2e7095e7619a019be89814db1ef83a5c1c854716d1dcd47485bb4d2d69a71d28d385d5ff39f072cb2cb6c43addd8a5268c639d855c344ac7ca876e2976fcfd87423e0a237b28be94a0e8b4a12a7a1bd758d94dc72ae7fe9b73d096227485f9423687082aeeb944d5fb6db214ba6882df9fbbad08aea11e12887a9e8461000510ebe0dd001def1c1985bf132eee60258a9a02d2fe9753543fa75522c6250b4aa4ca407ec93cf9f5b5efa0290b27464571747eb9780236717142cdd69f52106f03aae5acbf71e4d8331e2ecf38f987c18e5857470354f4ef274278bbe01e06c073dfd219d2e74b4e5098cf3c3eba664eb73bca1d734699b1f71aab9e75d7a2f8ae863c24892220fb996efa6b08f869e720dcf69c47482aef82116b40dc5665dbdfe366c30398a2f3868256e7c70dbc2e48c72a27ad06d6785ecf82e5c6757ef588b943369eefa8e9f443546573240f40a30568568876a30003b0c527cc9d01af8b00d88738be099fb4e2f2c593634a6d75dc69f9dec5c837443311a8ded0c8803fdb7cbee2f7adb00c2fe725f90954ff8ae5bab11823a26dc2bd482fc2a787701230121edac919554aa0eb7f92002f58a31a467b27021516668d90241ed71168f6668c8ca440436af5f90b52eeff0b30a13a576586ba4c96f4c4aaa46e196b2589975dd2d9c1d7ca14b6e18ed7f0985e584415cb3183af0d626445b01df9d47194d378e87b2fc7f28ab0bbc5a0f34fe1c777960e43dbe9c7507564e6c4a85d88ad9315648193167b414eb1c1f720b93d34978023a891a4a9f508b54155417b2e0575ea7399f720f364754f0ec43b88e125ae1c72932a6ad88d394205b5291c3e38c2c7c86f2a255dbb4afdd544069fd7c9461f63f920c26f4fe8b7507185e1766a5308aea15d6f0f620236f8a204d872b5905cafa216b445ba732f37398fcab463e80d5f9bb582f9b08c1280aa7f815b94ddbf62541b06eb1f8ad4e90c28e8770cf729959cb9e95a1cb88efe24a786f91ae86a80f1b9d5fc53eaf18fe1f6e51eed13ce6e5ea7f744a72a279ef7164971d288e45b3a79c7ba5c6c71186e492d9174c8d8a6995fa5233568522e0ac2c1bf8f323cebb66de4c8050185e44b28118edd3ad782105667c86309e8954a9f471bdb8530f1fa6165110bedb35a4f4e209862e929cca2ef6fdab52300a26dae811abf185b8fef8a04f39939e09ec75a724ec6908dde6bef22e3801a2976e8b75f7a2fc99f0bb8d4aa1e3e5be4cdeec2fa6a31ef504bfbca66d977c9c1142f6dbe2afbf1bea5e1f7f388094a375a43581d6dd5747f658c9d6371ff80ee2e68146cb95900e6ef6109425ba63ffe37053790a3f9bb264b18b4a718a19f32421446098650fc951cd33fa3b08dc9e3682aeef9181b79249bc62e6e6355a08a6d4dc7dc6e720ef3130a9f4f6ff80e05fb12b407bbf5ce02f53eddf2bc4c7b00b55923abcfbc9dd4a8961888f6ec12d0576a239ea71e66297c0f83550d1458e31f6098635e7bb1a099914dfd07444dd336311a4b69845f83a48bd614427628baf15762442296f99c47536b909dc920f023d605b72807e9044b70d1ea4dc2c6c3fe9f8cf2eaefc77c0a311761048280edc09468eb7d5438580bf0a15231a425250b96c85f915bfd487a0399028341f1ab2d0e6895726b0dbdf4c0ace47680ca2940f151341d612616e44c516721e8b7343636abc11f571337b0dff6862625158f6ad3126d36d454b9eb74e4b5745e9075bf2060bbaa34dace68144197ffef2508b55cf8aa38296929d47419b3d95912724e492d8fd63b17c6fbf3d1521de56302e762aefc8e905a316bc553b82d167db3498a1bffc0954d1c400e021a6bb8cf738f56e0bd4983dce6829ae026ecf39806fee81659cfca56c6222d19c0b4fcaeb3a1b8f17a3213436882e14cfde5b75e3ffb0f030f2f2b7a48f71f66291bb1e26cb5a51c1b1cee482d25855b1904f47f699b2e7fdf7b2186ea7324d9e7ae54ea2e2f6fe0c8d6136c67644e89cd4dbd15bca8f66f5d0056ef6e04126ee9a22f772eb224efa8b898b35eae844e3a085bcc506ff9bdbc0c8fcf208ce17eac219658f3c13245b1f66761e70b9b6a1dccdfd32d765fd1c31d5e937d7ca0918f73e71429c204b9bd3fc4970f40dcb9a081bc1e9c1446a193658ce1ac585493e65b2e83f347aa6fd83760a125f1e89787567e82284aa4f016152d11533ad55af660c5e4c816925fbaf26a05a622dd1d8e354703cc20d6586ef52d2c994500c17c7ab373af7567b00f7fdd752644f55818854d25f2543b40c806705fcb23b7ae992b3570f7a68dc236cb9bc1b3b7c106058f5375b96d917794c953d195b14fa6f7c141b36759b15450528a3144ba39a6d6f80ee96b2432fa69d9fe307d40e5f9bb2223e33a7ddf84a50a010c592e1d701df24fe77264aff1f549a25d9fb1268f4abc69bd17ee42aa7a4ff47914af4b71082dc72715bb307ad42a1704d4537df54d90dfb70b12f54bd72fa2e45399fbb9fae099c65fbe0a8e3580f1a68ad2485fc062f97c93fade460697b90052537acbb3addd234d7fe76bc0715fa0e57193a2e8868bcf7bf7dfaa61b849430b47aa6d97b31067bb6a3ec3c7278c2ef89325957132c81c0297e618357ac3664eb31c7b8aa8e07dd878f98c795851f8112d876868eb765241bfd91cd97eba67659b07eb0eae7553587c58284b36da50d53db71e8379af3e0b71060b8393df71d71264c7319d19a09fb01688e83ac6816b54cfdd9f4453df0fa150485206bd11aa34f7cc77694af30acaa0fd80a82d49ed0880b7e6728d03173a558f8f67f8fcf99164f7af2b0aa8bf41f0f00e0a357f5205f3abcc86e0a6921a70747174ed30a0dc83e4d4a8cfda3fff51b61e1ada0314c07b19e45b782542f6318df844aac6fb314f1276644048d0b08f412f8863863b7df2a68e04f5b64fcb23cbf4f94487486487ae2ffdd118f3a5313523c6e7b0ae0e96f52d2bd2c22bd420aa27550ad2248dc394ebc23b0af37497c478da22a1ce18f1a12fc6f58147f7e02f5d351bb9a066599cb367d092c583c34dbcc8b0acc617d60665ae53e06de10708f0f5d6c0c16fb22a113e688648863b8694030d9eee41fce3311c20a576e11edec8ad5e7f133ccc6516633f1991e43537cf79b7ddc3bbfe109bc2ac33b836360a8c8e21ac9dee1fd541ffe8c5615e44616b0b54546f506a33b80ab6fbf6aed2cbd2ff50e6ab2c2cbc66834c9141faf56bb362bb981984081fe2632de4a5aaab506cd44a68540473d716826ee1bc2869c80c0ce7a437114ccd311fa0ee24d722a5087b26a2e0a68a5be732ba1c81eb5a79baf8fbfbe570f0e346ac4601bd0a2037b9160a67582dd45ca7e00ff18bf7a2c9dccbbad7f574d714300e97429ab1874c6b7fad44c05ddf65f8c8e8a3ee956d301da29b867eab7c830cbbc9701c57ec229ac8ca59922f0d7e57d945ab5f9cff262b04a701beb47d365b9497ee987a498ba2bbcdef048dacff38be77da670966482a5daa79fcc7e31544e39a5f547d1423c7e17e2f8ab88d47dfe1782cbfad821663201020e4962c87dc414aba7da82a72912264e3ee16de84aa13e3838ea6073a54ddda7c07dc90e914d25f3ff60c4dcb71689577b466be864f21e52e30c0ffffc04a2dd1e764077b31bcd1c0d373ff9ab283f717b69eb57e25b02087ce79ff8d914140fcf2a16d69c85a85e71b2b8a939590a0576fed393e12f67f6887ce06931b7d2278cdcae017e03a20ae1fc636f3b7875820c02a6b27557f2c78544839c1bd69c57422da946e44ca29d40a645ed6162766eef8cddda600511134b7f55d2123108ed7dac8ae14ab22df677d0a69091b5aa0fa10d1d26ec0f1612043254644b719431b9fc1ed427aaf53bd0ee24ee667271f32e5ea7951a6e3b84440eaeca5bcac3606cb4681dbc6b5c051a9a12199f131d78b057fb15213e38cb3f5ec273b763c77b91fce1d63947750d82a91e277c02f9f1c1c7a0a2bcf01f55b70ac1e356407a77732f1673800e3888061b96d2677563c24c8747f19682e679d263e51edc149dee16070848d3999f30a8bdb364934a3de1a47453ef7b2d86250fc5299e8953b6d5b3b5122004b2412a9b5ee9760e9e5fb0ef947526f9be4201bdfc6a0dd46e8ad88afe5818c399ac01fbe90feb67de5c45a708e92bf24d0983db80c6e4786caf4fb5f6bdefafd225ed2a63cc9b87ed170492816b64fe0ffd330d1be48edeffce5067835a867256b0aafa4533967ad33cb292308673c2e9e633611f85b3783ae0dcd153ab921b3f82bf7926c594f56b61ca23132e7229558f9f61d4569ab5e51ca2c0480728de572a153c1130d71259bc9835334fc04526839fe2a781e8dbfac1522a716be5eefb9bf17d39dede23301f70dbb372eff7d26ce03a0e968bbdf28daf8280738cac35bd0dab8dddcf64bdd98bd7be0d6a728077b781fe94455139b060a0a97f2cd54d2e9f4e59837f1b430664a412bdb861ec48dc1785cf7087d528782ea535d13a00efe030ca5ea08107bfc7973876923b6e39ab588ac50633f50e69253243916f64581ab5aa14723f3c635989741843f03d273dec4927e0968bea6461f457b94aad6349d6835dbdb8e4e4378e9eba5b8cadd63d96b288d2b923e514c0b7e73dcbe22134785984f6be92997490501c2a504a9a26ecd07a8f30fd10e284620cd7c2f1991694adb560f682e94d0c6675ad53868b15c117209b61558f9f80bdae1713ea2ffa029aef5327f843003a83494426e7f7cd807dcbba1751aa8484b9e86111e4d42fc5e90f5f4209972c79a793e8671d92ae268c0e964f55f176fa3bd8922cc05ea12ab6a0899eaa9f424052b88068eec6728881f4c79cb73336161126d682e221f28817175b78fd3a4b2d1b001c464978e4b1865c5e25ce4b9a90ca23bebbad0a5f5b56951790e0bb3f838e9bc296606b6fc72ed802853fe7cffd3799e1d14b67f752db507a0eb89749154ecdc16a223f4750be1b2676ae789ac1c26f1936ed8c18ca6f45be1b1890e7131ccdacae6714975c1e363910c871841ff025bb79c9770460405f2b81a481f793d4569d9889e4f1591cc51240aea5a1d35bb2bb13a8263070801edf037a645edc45957c137105bc80d96edf91b70e242a90ac00660732c921770127e1ecc1c913d53c811db2d1270f2a4cc960cd0f699afb130a98e4010b0c659b2b966a811d58e4b720648af8f7783cae801da082d2060c726b50d8ec3f199653d5d5f358cdc04d5c9957eefbbb541f491749119e4bd366a0f350837daad24cdd64a1bfaf2fbf42ca036b9d7f7222328584ae9f4fd4d6809258da1007fd31f5b6c86fc43178effe1cf1c6b55fb71d5d67c815cb382038379320caf1366539b92a3834150c7c01e2799a1ba428d340e6889ad95fb00f2ccbb2364590d26d5623f6aecc0ba5dd7899f2009b48a051e699e23f60ab5d03cb40e91b6e55dcb18c4fdca5fc67a846164708cdb07934d4e890b9c0e54bc1d66f174d6d8d59fc4899a05df393f1e45611cedf7a7f28d425e2f7ea1968e1a7d02b6983be0211414ce302634884c783e7ae69ff3dde0f15bc3b99c01e58875c757452380f134e29af3a9a03e6c861f600c372c361918696d7efd4af12268d7467536c03b96f99592b047a257d8ed1ae320961274b56a703f0c389ca4fc94ac233cca7255ec7e46600a7f33b41b3b0c2a3ff4fd7abff318ac14c3a41ad25d8e11987f7b6e5290dabac5d1c924209b6fba15502848ae3bc39bb3b835ea0f4ddb8abc01a272d9b8c160023fc2187279177fc005e0826a9f88dd9acb02dfb9b442c5cb1f3c31aee60da9e2b9c75f5b1734c3cc3e9837eebc5b375f3d2f1c6cda9dce29aefcf1e144e976b5ec7041e95fc18a6effa90fbbacffc814f58d86faa4c5976eb73108771bee33f0cb695fbbef2360471260b0022fc2a45a2a051e58774cf711cfeeea8882c26d81992d9ce9cfedb9d7a1e428b2283f26f778d9e913747d7954ceec6cba86456c5a8b68aafbfeb9426dce60fdb086ede4b7d514f45b1e4e7f422f8649723201f9a41c9f090aeb757d4cc8958e68f73dd7c2f9a1e91e4f25f9700aed69f20351598991c8987a019ef80f9dc5d79da51f38f9fecf1f70a46d85e5b90146d5251180f6746b80859db1461e4c5fb5fa6e17f6bb5510cb7111db3b97f4b4b8b814bffa37736b84c3b5bfc8f2fcac977660a753196a5bf4dff83f04cb0c0e93b418ffe3b28f13a12e57cb7fc3f6891af7b2489f537268cd834fc19996b617736404769c4ceb6527e5fe13640f05d70c5d478a03319aefc9776f4d76e713d606df6c060307e8375267ccdc1ed2ee85e344ae23583be953803bbeca425c90e85f259f20465e4258a316a60e13c909e4785994028ec21b58cea4eb16a7b295bbfa85a8dbc876aa5858ebb02230d415dec433904a95f854d78dcaec684a471268e37b02bdedf752377c9ca46c4c64e99e3239baa19cf3b71bad13edf6f589ff0279373b24126d2e3e119d8195f76c8f6ccc38b5ea56a61efbf86cbf7d0c991597b2c04a7515c76a3376219ead8c572023120c42f580964e21b701eaad6189cc75d97c73b8b284b8a506f8dd290cb569cc32665d28b514a91519d978dea6ecb08dc622f65a18a8becff9084ebe49b5998150454ff83c477414130ec89024755fde4cae3381b229b94c3c31257120c5da17e905c53e4a64f8826491eb40095985022d214a48666802397a4e24989d33c561fe7b706dd93db4d86a53e7198943e73d6be4460e3a29d887ca03ab0d466421a2a1a22a081980b91cd0c1b750141da069bdc454b6f20431845d2dac234786bcc2c79628d32c7309ae37f709b2db19c8976c698e42674b61c680c8e4a587f6bc217582abbe4d422ba85b593fbec2e46b8771682e857b168d92949388306aeed1e301ad3e2fa221e25c1f832fc5831b21f8586bb6b5bcb53a05ff79349d4f1f77c2d8758b2649eeec0ce4b11d05439cd063436eff4c308bcb303cfb4a95d3f0d0686aa4be17e8d2a1226e87ecaa02da05fa13892406b39aaae8ba40cca86e4fab15b61506e151bb65f9c2012e7c3f0db280ba5483902e78027fdea85cbf520bc6db31374f9524de6ea4a829ba655ac0543634af0a159a9a52273162ea455df726aa9bc15b528ec5f9229a64ae8d5187c35089c02624901d0a6dbc1d400f79e1753eccc9a35526a9caf2784bdbf8ad9dedd34538117039d855fd72267392b8b3c18169a61ec3c08fb97f401306f11b6f6e389cc1b1b7071ba8c5c80a3418513ecc2f468d37ce9340095229ebed510faa454adc4b9335658a19d8323e22a8496b9993305ec623552dabab643114b73d3834bb9a31acf7ee257fb1f9cd29fe5dc650f006a2af2d8c89591d1dcd6d2c1633391857b5001a742286ffb29da8ef67501d6c5935119e1aff1f85f4dd1e0f7ddb8e84b68317df6ba2ff2ec34e2b485f5080e295d8b0f9e03ab57edc74ad07cad268318cd9402b4a2bbe469fcd9c070fb7f06b7d24facf763a5e83842d73cf8ee84d77f9e3723385794a2ba533611e7a2f2e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
