<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec5b52943ae2d95432c371fa2e63ccf0fbad54d440a913db93b214cc5b1f828dab574966cfdef3d57343e52659c0465f2531ceea7c13d2c04d3edcfec8628684bc2d5cbf52bbdcbe7222c4b45e8d2839d05495fb30e95f709839aa47cecf2491f72a8657ff4405176db426ba099fb5bdfc7dfec6f8e1c377160abed1d27872d0ea76f37402a71c81120970edd48853ec087134d0f4f5c76bf4e2bac2ff56096671eec9e621dea2bc6a9ccc0c31ba0289755d8a3db77b1c552a626b904e1974be68a372dfab3351403bb0a99ed662116b8867f1f93e311b1c6fad8399155ebd926885e5aa6685f647797e0e2107e1d6b7a02b696666bf9e70f216fda0001df36fd8fd2cce23d71b84eda856732b8e577cfb7edb5c1476aced4ed75e6e987b280d713ac753cf97c39c89cf92b58752f902418f2b1dd29d25b007134d2406d74395e623c253e3e4f4e564f5d9c57086c01b18b59d7d32983742334558a8afb4ccc6064a8df8601a5d4a323a7b098be44e7a9f4232504e9218032d95577e99f388db8c41a9913e28f845a7230313e5ae923aeb8060c22f3865fd08b7ff0941c742ccfecd7b02e88065b7b186282b6b2cc97d55d542528da2dcb6caa1f7233f3de78d808555a3ac8dfbb8b9c37019625624bb3c46882551648b4a87f9b19f602e5fad995d329498516aa7074d96a137ce59694f09f235754d2548ac77bfc8c7edd42cb0c7de5f60c4c40ecd30cddaa2247395ced0a563a3ae7e755e66f53cde1a3a937f2da64fe2c427cfe2db7181d1bb680e4110fbc64d45673be36729741e1f56beb879381bac08e9ee3871237bab7014491b57e58c6a633178cc0ff1f88c2c09d072be861206074d831f1765eefb18a8eda755979130b62ee1568cf6a0ce0d5319088c18758359f601d48d55c0b880683724b4b1fdde5469717b9c7ca695a807491f2c9b6b9b930cb166d9e8ddf3e2cebb0c07ee5c388d9fd5fdce4041ac6b371d4835e5a2a9c65a0acdd1d89fb1e91a166ed57aa1048c51020c16d2bf043cc433dbd03b25c55817ac9bc53af3b473181604aaeeb0f33b60ebde1d3b12396f9f16b7372c40b1289150bd9ed17a3abcad4945a7cf8a3e1ac6bf134de40feabfad5bae841e03c617450cfa9f3727c35d284b19054e8a3951f917108a71ddb30cf2b48a1a215f6ff4fa14e7025745115b9dca0eaf84489cc53c16d9d9a4982936a7be0fcc1fa5f1e91a3089a20bf7d2eba1cb232b1934bb0e5d278e6189a380c795b10c0ae81f4473a047488d7c0d919df06ef3f541feab028619ec72c350966a884fd2b6886d52dd8c660013526b3d0c567cefbe5daaad5a72400425f893b69c74ed4f9d8a6556a1cefacdd806e33dd5fda5c6e3177ba9afc385096d67eae9d00e735982a7af1f201c942137c9816f8498ce54fd03cb013421760b606b601c9c108367eb2cec61d14e509417a22eac1dcef6f554edf45758c733697d409289f4e4dc90b4e10a87d8baf152648daf93b4317c715c5cee6713cda47c789e7d0ee2929f5f0f9e1e308c7adf992f8e442f3e92b9140fafe24ec6c7df687e9a249746eb567a2fcbc1b9eff41b57f2b99df611cf8755c04813468c3a4b9a25e81b36afa3434cce98bd85ad071d67c06d5146d9153a0fa69005d27857c5a29a352e062bb714066a1c85cc0e597b290482f0263789b0408016d1d0c4bf058a7a72397b5306c44689cbc2750a6c5c66ba2de09137cb7bf09398c65890821f134bf2d0ac4d63c9e0c9c138dfc26655ecffdbab8a3902c311e2463d50e8c940b401f19511f927e250f97746aed6c5cc15bbd7f7150b723268e310437a22d79fc6caddc3133baf6998bb7cb7430c67280ce1af213536deb9d3eca6b13fefd8671c49948c54e2a7df1b832ef71482d68c9ab8fadaee459336a170bdd32cdee4167ad1f40278b3d5b4e9e6ab332377b59e5754fa25e183cd5b56e8509a11c1b7a95de9f4a86e10e27b4f338039fb30a8f3d004357e4251aa48c248d64264b68f2fe58176ddb0979af6edfc8c59bdfba5baa4f3857982dab2114a4cb2b1a8e6b1faf5eeaf68fc5d7336a027bf0bec009834282d8b29814d3d3536b35c5c29467487681fd4aa5596f82dbff12970349d01790ef5387b60650da5081b6dbefdb4d0b1f945949288b122e48168ce2ee7d7aabbb9b18b3d8d5036e88d4fdc11fea40f560064a99a9eb01ba1e27429051426c9f7d6b4f17c24ecace83650981570ff556ed439fac5921ed72cb56daeb786e9d64d60c5afc85e3847737f19ff853a2c8f1116b426e7df08d34301a7d2978051fa805bf543255631e9e7ea160d062b5929b4274698b3cf0d6706c1f7fabbfd2eec1d1d829ae18549e0d1ae62a539fa3b978bfe32946e54126d948994b04d5da35e412c4092b4c8d8676c3c3f525aa4d13066d9bf3ef54e622b487000f0305cab022a377516a655b466dab395aeb14db318f11f8b82eac108bcc39290f3ba09e5b812d09010ad594d54dcb3d06f1df4238b2c8290d39e5b8350bdff5e0930b898734552751be4ad7f7be4fa9405e0d53011665aa155831f2e1bf505960facc6c95bedc909ca178260307f4a403420baf45966ed8017aae4ebcaa02871e612dc99d50bd9a6a83cbf3e8019981f85df5ffb639aa38522971c234c19cf459fadee5973a2bf096f4daeb410955e166a14fa54f06fbbb328984fba37814074901a3be5bfd46a712527c3003483a0d435479f671ff20b1208538d7f9c428c47fed45cb6ccbb8d984aabd5641b681e5c98395a061eb530b8162d9b8c950de91ec17c43dfbe590d35d14f6b351cf9afc55f973b65cdcf52436d17847270e0868559cd942ac6a157f184df0bb162198c5faad062f03095a64a1e272c3e79e40e300f9010ac6fdd4186570ec572dc9cc37d597af228ae3bdfee293175cb085b18b4f6fe4240b508c1984a819b4dc37301a2335ba34ba67fc1ab02cfd56188e4f5051860e22ce5c50d65f749466a74a7e0c44d296b4ffb572e6dcfce3ceb8a23f699acb14e30e2a6b9a3e51fc2ddb62a2be53bbe5cd8d6f6a494c240ffd69b7e02783a73193a6a00d2339845928b0fff89992b5e7c2c120a3bf9af56934d25c133756fefd835f12cf6393cf62acf986ad0eeb6daf97cff8081023731c477fd52cafcb50d9672f8abf21a268e763f7ef7c26e5f74e61213c5856f09f533f4fd7d8fee21062bf99fe0e9f37627bd5783c77ee2685d7ef666de6479ed2072dfdeae41abc93897fa9be4aa6764e2cd8520a12e31c2cbd0e3b3147a724695388de83ccc6beaa46db621a3e59756cdb6c8f59b0f3223a7b8a445bc0b63a372c66b34d08a6422990d103f75770c6565c4055c12b387f7aacdd90ee61234e402938d29b33efcfab1ace76b07bfcf06f30fac50ce9aad9432e8bec0c258e7315781216745e26d67ca01659b85296c9e8333ab4ddfe8ecf0370ef6171376b425c9b6a81b6f19b64aebf9b86ee3d0e9f459475338a228c08c98ee46e556725f5797444104df20c1360281f27e8bf09eea89207da21936d9afdd2d0ffe51f912b6fa551fc51d6f46632243bafc3865f0a4fde67518238b97c6ff437748f2b520523b8db2dccc850f56bed3fc7c0b2ec2b4ff0c2d3b45797c2985150440af05378523853b3643513b1c47c6c261a097bf2f0f1ae855e7dd7a336654e7a4cdcf01c27dbe8132e16cfba60145019d2d145150da5ef44319cc0eb9067330f894125d6a2e3c493fba698f7b4a551c4237992213d20020b9125f6e3c5a5c1e64bee152aab4302ef3624934f6434514996058f48bf6bdee7fc3c780fbc2cebae71317e049d2c8874078c8df14e464b7a4d4c479716930bde3de7f955225dea63648ce90389937c5c25e2482869c0ca7e8cfae6a03e3df9556482f276f9e6fab1e5feaf493315108fe49481855027907bec87996530e338d54779dee7079d9121b764573355b774f8a64235bd5c6f712be10e97fb2feb4a48299db156b12b4985ebb5437698c3c74047a4d703921b8671530bb405edc0835a0d4d63fa9981fc6849b6b9316e7e81a3abfa56fe5081c3d6963ef7f0a85acdcd99db4f661ab613796877dd09b5db88745714f057029dc3d4e181e0813b16ff318452fd4f0cef2435afafb7a4ec8cbf282ce2fbf6c57f81afab9b193fac190da49af9c668c21925b83e49c242d46dfcac8deae5362c9424ccb3e6f57d226f8b743cf070cc41c70a7e77180aa842ab30f0a2f3def31c7339f8ae332bc4e86f59b1b9033b87ec7e20f0a5997248987addfa0dea3a5e80bb51e4e86e75499ed36a1f268a69ec202837eb4e4aaf7d80f91895e90a712161439285086b2975e482c73b1f4d1276a67d5de2e499384e232252bfa9835279eb4c9612de851f2b6c4465a2bf5b91e4a684bc344baddbf31543ac8b012910fbd18764b67fa8087db93da262532756f7b9535e364018a29204fb0a45d5b318927ef8c952786e249e64fb426a785266e58a0247baa7599521840d1c2732b6e3a133dad349056348e0f5d5e2b0a00c521792384b082b3be0910910f755fbc5bf9901d01772fa95b13c0db49c905be94bc5a86766feb2a5bd4c0bc1d45cdc5a2a219c24a4ba6ad56ceb256e2a32b065769bb4c8c8ba56b200200bedf57c9427950b89a8fe0839c711c58b90da8602be0808e5722f355f058ade3367cbd61ed80414440a305baa11cd39d9b471060d287872d11fed40772fef00d194719259b210afab05938297d5247377050037cdee38203a113c5a96a381fc369ca7440521f6a0f3e33d3b265b35f53e24e109759b4151b0f02f87deb1b7426848e4e810e505932b63cff933b29ac27297e91a7334825bcd83208ae91ffdc5d66ed7190603c6c26ea44a4b70d36d3914ed52ea0564afec674bc93a299b9ef699835b999d052b727f89cd33f6cb8a2b143f1f09d625c747fc9ff68bdac81cfd9f8e79a110501871f301aec8e80cf8f3e038dbba6b578aaa4d877bf0c7e7f5904ba44e215d9d49552f41a134717bd41e74022b6c2309a1eb270de8e11c7f6d81a7c1da5dfbf61e001995ac57b56280ff95bcb643765196eacd7110178151c30995e104ad3fe69007a974a6082a6e1264b3eae6bd4a64b885ae1757dfcfef4282d87fb9390601a10e5ecb77c4a3b4a7162b672f5ec2b52d08f31e427b420ad26151f245a915ab53c4e70def0d4d35e2e339c05d9859df383bd4f6ce6c307eff6ec63e2897056a73f0f486237591e543dc11d1aeca080a35408a0eff95682671a1f79f2848660a45bdaaeb7203edbe7e5e7cf4e71491d4305c76c69491b92d4a6b967744ccb6fac057646c286cf4c0f3dfdde57e8bb8c454fade6e1cf545a288535a377d6987a4ec235961b27302bcaec13432f83c6e50727ac466eaf36f3e954488b8807ded5711a368fb3a4840027d325dd5404b552fcbf0ebb315cdcbf9bfe7c4c37741393eb3582cfb5417e239444e29006b68bf41d0cfb8b176b55e08de7d6031214dc3dbc65f5a98f883bab1c0131080233e89537b12017fe29b79af6e1268baccc3ff8f4ee82bef215ecb9aee7795f8f8c785e872f685527bb2a4505e136b8f12dc426ac8e0e5af992c944720bc69a4f7fa5cf26561e35c3fd3b95bef43f69391fcbaa16683f6a6a6b0ed22f40d6072ae88cb40da6a4d3ecbce19234a5047b6356ecad35861d49315f219ed33de6707b5ccff7ccdf65a19d4ab6adba3fa0f46824b96ab90aaca016feed93970e5f41eb9ca8568b896c52fc3d4914a415e36eba2341a891249dd8b79bfb84fec2970265a5f4fdda6904e94fd2978882d109f99832ccf5674258842493f977fae88e925e6e1d0f3cbbe2a491d4e52c530b0437998ef4461777117629f29a27b6d2504d454ab0ad54ee4b2832f3be47f03303a07bd24d072d8c5a5de90b7f45f8f8f427023cedae3b0ef40066091490448537e1eedc3413d8e80b7c45ff67d76a54b7060ce327562d2d51ce78bcc6f62ee894edd2c111c269da62a980bf74f26fa2f0e6122c1fd13cfeb0721ac89d10b7ff9832030095ad3277b2f7ef6e0fec6e1234deb199da7c4d0d87032ef8540cb4ca61179ce8d194f005e4d5f22039aa68f8789995901e5e920bc069cc50f753c461b4ddb7dfba7789970b1dfc5b3a29915f52b9c1a2b086a7f0277cc7628b23712ec65746535d3b7ddfc66a1d2e1e570f2aeac9e475115a0fb7bf364ad2c2efbbd7b3b49fd1746fbf1f8dc6c04a313348c08f87d213c3bcf6c3a9066dd349f781d9a6bc06ee5817719d4f186bfef5bd83ec5e77b4d6e3c0baaebf78fc367662c61b19c064ad0dd2624388d320428bc9dfa0dc7d923b8eb55aa6ed9f9a05fa4070323d8c28499c3280829e4d2212b983d23424f041765c2e746092284780c0e71738579a49d2ff013dca2d4ae562b352a672bc8722babecb281c9e24fe47c5d4103444ab479bac49e88680e086ef998fcba7593cbe412d03641f754a191cdbfc30fc8b6d44134ddca222c4ce8a90bf98827881761a48bcae9aad7be952c12dc0705a1b4a3a791715d95ddf69829d32348373477db219b8801860dd53d867f97db67d69e3199324224db51d2834f17a8151a0fbe6de187a708825330f3ac7892771bd5960767375634ce0b94caeabf6b729f6c23391545736b4050245d2c5f7e76d555fa6cd9d42347946c7ca138ef2a4fc7a21a2c5854d1a3ee21e0887ab309dba71efea0451e6089030bac55b0614680d6d42d9b41ec02a2bd984d17c0c9fcd27d4b25a05f3a0f5f813281e01174a52898bd8a65ee22ce2f8212c68bb56b9409c9a44279606add454e3b61fffa91b672013ef17daec40c404fc258ba6ad7b5353491d309ebdef82a751c0dc3940c350de72c4088ef93ad1bb13aa1c8ca9d6324c0c40c77d1068339ec842d42c0219bfa2ceee624dc69ffc15d9e1a2bcb332314b37f74aad6381414b4bb7ef5ffcea9f7038673e95fc83ae2c1c77a11718a98667eb23a25edfd3b1670350cb32560c6a5dd68f4cfcc93f1f34ff4b7c74bd4726504ea23c79dc83a123c168d0550b1a0ef8d579d38c9ebc7f3bb77157b551411a7f5bf7d34ef9f78c3a77f1db8182826d5c1d9214362ed84a1b8adddb58a283165b177e9e180e341bfa7ce4bef828e2fb0797c0d02b928c7a225aadef0eedbefadc618ac57d21dae0bcd90be2f6dc469b02ef80366a31b2bae7b4a02d313637019bf23e81e8749d28a4eaca33a08e8e30752efcc158015e14fdb2c4164471f8e84a17ccd4d772239055c9139d59a44d2bd68227e9770865fc9a7ed85097e2bc867bd15abc381bb8066b0ef98e5efa9989d15cbc5b895bfc528b1b0d54f30b05c4c42fa6b5310464975e4952550762fddf9a0d8a3f50a52cab5bd5caa90ffb7402a2a9ed66e9ab80cb56545f5deb52b573fe35476c564d3c975b7d2e71f735d0014fb1b2fededea9a2b4cf69d0bd2c520f759ea2a713c9b9a54e9cddbf40a92e280ae136b285fc1962af3e8f5131e27c7e7598822ee4f865f2bdcfa135422643a0967d3f3c839e087433fa925315c24690e10d635908f7d650635e247c4ea0d150b04ffa4d8b2130484b0702c06f5b11db263ef4eae8b49c0cd5ae9fe7216b9663fb5736937110fd7677fd783013bd29c8172ec7fd13ef6d00237eeface4eb8ee0af08accbc5531083ce4e69aa27d0a2696f3af8516c0eadaa15133e5a02835167ae48943289166435db51a98d6256d1dda53378fc6a2609a5c1d384fc407c4d98f7f395a428af325d807687a48bbaf4ea0f9e62194af3c997e015de1c59221d8776084e45e410677b3cae5958525f6e00ff0ed747a2517eddd506e1736d847793ecc1ffd5a7b374b518a92d261f94261aa0c758c6ce35105d7cabb5798503cd351fc54c2d63d9b11b2a543ce68e5e16c57d99cbd72ac50137c6a12720e55c2aece0ca06e01b4bd1ccf50c8639f7dc5bcee9317bedede0efcd323266d77d870cc9e948b2e5c975763ca979da32f9f673407df6994f3356fae06e9671d345ec4e777b9ac9c7718c2532d18800bffd47704d2516d8873603c4c3e11b46a6db392d3db09981aba0385149828a7e8554d875165f45c5e21a474a328a331a98f083ece7e8b8db842f1409515fb6170baba2ab3aff5b84286d91951f9d4fec25011a9f747ed084af431b269cf0647a495b9c443ad94c6ee344861d61bb6a7530f97d01e94ed12dafe8a614ac158629dcfd4c4c8cb99dd26a580a7a7b77f8694db4c53de7fe611c0411a6a35d1969770f60084f38c423fc2b55979b11c3c6b2dcfbf91a2e7f88c400ce36565cc59e42939444a9fb8f5d127b31f37d417383a585a99dce1a8555445c3a76a533e2ee57bfc8fee3b181790a5ecc926f4d1f688b3dba7b9a8fe01b532a3950c15d051c9edd2aa0b5fd1db77f56e39337030e0a5be5245c0c6831aa67ea0a6e5cc5753002e2fa6379667def5e01440fd96cc62044aafeab3968bc284f5d00f6e8b71fa5ebd31f35fdf6e8ed3d0d3c5dfc5060ae6e14ffba321174e5cdaf388fba6d95af2cd42074ee23b176c2aa35422adbdd6443a29b68167a52a549212e00acf7eddd378a927eaade061893bf55ae0efa6fd4bad25597e492aa4eb83c2e1406581b9f57264b8a3f5187db5ac111e5eca8b3cf8c8766567310bcdacfb05e1f4223a5e43a261b79dac8f5851c033688cdecfb7389fd3017372586414af4f2b93aa840829c8dd79e6b490a6e3ed9efcbde6cfc6ba65f75fe8a67d5e417f4f9f0978d357232ddd8a06c66bc29690c9f1e2a14fcad2efce0ea79c67782d77365895a72b69fcaf778ad3a120c8d60bbb5807c74b7df2777d1770380a8f6d60402f8006f5de49dd29831917554962b8b329c1688c5517ddb81f5663e856d6cd4721b29997516c904f66c6f9c6b0e67ff2172747ab59da5311e5d3473fc050029466b6a8fc8f85a7a95a9e3ea44b9649d958cde6ee0601437e52e970463c06fe92bac118eca99cae2b0cab841fb8f00bc392c02569f6144b0e27f9f07df4864b295e8a2dfb3b9a764c0ed76a147e42e8c775300bbc493b123b84bf8b0468f471c7cf40c1088a555a253010fc230e99670a958ffc40ab4a9f4c4de5d7cc9de5f137296fa7126ee0f7bbbc0fd7c76d4f6784950ed2f36b0adb494a59966b5a23ec5851f75fca911d4d97f50a813da868691e9a600f74bca467e497ffeb811d49f295aa27af8b80820d34f75e2f0c66221631a5ca9b1124a185b82464f48649b6724cf89dd88263359ab5c0c430da7a5bc3795a00204b344e54159366da3f8a9f6a2956ed0d5fd884ed8101a5337f463cbd17bd8ab1b992060fc328cca7c442890b9df33968d616ee0be82626d09445bfb5652d24b6312c8fe58967d62628dafde9a1639329c2fc77b9ee437df21c5f3f381602727d224ceaf24bdf8300d45d32f684d8e10e0b40c0f5aa280107f810675e5d0b411156e4acb150e154223b5b0a7ae6e697b94666a0fa8c292cbcce516b136cf79be03787d40d5f4077f90bf89ee272151e51e34375c935b1bd38e87ab1d5a3deabd26940fc7c3b7d99b6879ff0cd696b2a48b187f36752b4085732aee506b77c27f1ea3226bc57726ceb68ddbc8378b50b6f50565dc7e7d5e147e335d6d8f715ab212b1632f79b6294153416d168928e2a7173604a4f839069f819562128c4299c6849b7f0c8d80e7f5526ce4b7352e20bad58751b690d4c7b29a782150e639ca722a2054b5250b104780999a4c28e0816b6db669dafd918a16acce4113d23d4ca68cf80085b796842bb92f0cba2826b8f84f177f9765385dbb1559b2f628abd709e1ea6069e6aa0cb6ba5326eb7ebbc443e0c1939ff3fa2108ca54a04b2fb9aad637e2c3df832cc2eb3e285e907868d9c40c21dc8248b5fc278690d74203e4c4efaa29ff39f0478b3000c66a70b8459b0520f3940462627aba36685f6a2351d43120bd79de4127be629fb384adb31be034e333f798e1d7bb6b8c145ac48624e690ce8471d16e2623b3535d27b1e582a682fc78236f012c6ca2b4c734de2bfa42d6564aa7b7b2662c4f576a1bc0360f0c0ee6e039778dc8dfdd688c24e8e166ee3bf42a9c89657625780b6cda0caffd997c4959fdeaacf99190a3bfff3bb8b91067d4ff87c3a9ebb0f2a748dd9b2505bdb2a18b54445b35dbd122543b67fa5ba97f2e4b2b5687143022472413df0f3aeaddc41176164a026205158a188cbb1b671aab384510977cb591f6bdf91feed9ccaeb09ce9e69169fcc969f3e44eda3499fea0e8d6473d558bd5c6bc0d5fa76a88a4912b0409cdd573d8cec7ff904af4474dd135c99be3f258ef617585ba2f848c2c0cc26a42b27821b0a0c29c582ffe33d8af7f8acfd36cfdafaed2f5507cb83c03a95b1fa5716801e1ab246df6ed44cd225c2ffd6e51828590d8c7970300c650e680197eaee73a13201702d9508916e25d6289e070a7cfcd1ffd767dd3a407ccf7ca844457dcd81deae05f24741f21a86649433fa605f8c29c625d4d7538e3c6e2dbd5772295f176d7cfdedf34aedc49cabbac1559b39c38208d5ef6e0831730800fb8a90a8ae3e24604181db2f0e9a54f8acc9c617e2b36295cee294afa9f82400e939232bbd1c6b3ac3e44d1e0819fa7ae7640a6dba8d458b53df2d5bcd2897f40aa0924c5f85f8711fc6a535b144d98f9f194dd665576e8f9f4ee4351aa549121a63969335fe0153054cef5d5c256ae95447d727d8e5450924ef1d83517d34f7a7a67a6432417b74aad46d61e38e94cd43fe06c2f6f235b0002d0d3b8cb5ef053368097439883a0d9eacb7bed538f7d89edeb98cc5bf2d0c3da4b9d554d7f1b72ee1edb0aec2c117d708d782b16c5e9fadbc3b95cd9c93ff57530939c42ace21caa813f07a7d760bfe6b9a33e2cb84f82cce1626089b132f5c3ae59fefc1911a33a9f9ee7105abad1a3363fee348eb3f18b34562a0892a0e1aa2d7e90fb76f79ceed9b4450dec4e64eeaf860357e896294ecb47f16b65b0a358daa9cead2c582888e28259eead6eee0c24786083c55a8886f9fb0fc9b684b8160b330306d7b8cd47a4b3687adf8f1554b042e4ad4f1a9862215f3df08c096f239821769c055c7e0ef2a2225aa973d83ecb9014daa06580e17672b1de3477e8837fa3c875521944a07bbd7c06b4110d22313c3329d9945f548807b5dbfad901688773fd73fc8d182e80cd2c055a77b8c791e7cdf6e6ab703ed6cfcb572df4839d21caefb78adc560a9967ba3c83bd107801c3f64a73022df323a645cf7998109ed2b80276cdd76d58e0ebaeac7e9be4281c28fd363ad0a46cbb657fd8612c95a07fc50ce4cfcc0fb81474bd1b6f9cdec9acc7dcfe69b0f55e386c1798e2b2b9258e53ee1df933b7c5d0269d49d9b107f66f2ba01938cdf8e37af5a6b2c49d5e972b7d2275fdff0d2f73dd7f4f7e795a85e75ce583874183df830ea9a8836a9f9e7c30bf550c2873a2fb6dcd49f81cf91b3194f7f4b8cab7db47f928ed1f122b0a3240c27321d48a5ed553e278a57831664471a55e73b1cf01d15e7a03251efaf81d674ec6ef48f92a0ebec9243e3bef81e1468376980b2052b74fbdf89b56aaf435e032b845afd677f8481e6985bfd408814506473f44c58e4a13fba9f33245374dd18df834fc75330eaf7f89cd2f4048c2135ec6b12cc008503cf6eee3656113d0f7b645d9b00d91357ab65737690f610aca1ea041948e7a8091f2db0583d16c22c48ad4268858bf85d03ea67a46b8441176ffb248e3aae7ffdf3890919d0de02e376214d2fca5c0c8c9ab723065125f2c95c49da52aa9ac5fec8ed615be6bff47a2f8b8629d854aede806931e0ff0b05475ffbdb0358b8855b2be0ccdf1b7e7b29c1630a525915b5a2aca0afccf339c3b1be571c9c59d76335eba6b3d0ccddaff975d29e10eb3a9fa1b7293787d8df9e08f9ca9f0e2cac200448e10caadac474d071f41e7beda9aeb50627160c3ae5b00ea0c6015573b44fc81f52e91b4bfbee6db811e651d5f7db455a1900351ec781a99b7548442281b80c98181aa9023cea16fca7d407ff97b7bc530edcf7954dda9d79340d503d8306e5c795dc1486a1e659e1f1001f8a9621f4ef2606062068d257301811bfd4326a9f4594bcd5b0c6ffe3e841565e54d855f744a166bc4086ce3edd394ef83e8f9eb9e7a5589d0933be37214dcbd55f674f53291c861cc9f9a7e7e14e1e6897e5b1b7334f6d2913303b902ed41751abd0f267950dd96477f14152d1fc1c6063ef2da7678ccabacb40ccb0d1a6d5b86a5e462f78ffa9a2fb1e34294a61c172a5ab06e5010b4a20bfa191ec31a534e2e4008a0e7f547356c654ab3dbf55dd85b4daeb4e9a97a084259f407a3c58689aeb5bede5fe51783caad0dc3e481ed930c7bb69617f170cff3e7deb645f4f1117603e775d8e3301e11e088a1c6266fd133bb150369dcf0e744246570a9d6385ca73ea2f836f79bfc60020f16c69e717955ddb14220c6678bd9c503abbc254f53f461ca925a07e61fab68cb1721aa1020672cdff2b119e3f43b0d28fe7cd50efef94a1e709b90e45b9c6c4acd774587c349e27c5d4aafdd8276292ab77ab3a6ac6493adaad83e339438cd31d4f9c2adc9bebc21677d9c19b99ebbaf46c449ef09a97fb16ba48c2fade3a536a9d855856160d90ba0e9031cf388b68e3fe49d9aaf8743b09880823fc0091cddd0d64557c31ef2a01515d043e90f44e69e238d629c6310c26294aae761493e61b55747d67d9565ed8666b03deb8a3f7ddbdc1d124b328417ea9cb78c4aff16b67056e57ca7d6f67255d4bd650361656371ee5069a98a8b10fd36d6b5bb88c2e60a3be8afdea098ba9ccfadded754bad5176c839e65c6711f1c91e99249b73ba1e9b5f1140ba7b55004fe3c96bc271239bc973d5cf13b27e52f94e2cc134cb14ed2fef3f580accec9513529c12b6c2f517c1b3f4fc6e90f39c1f6386cb9ac02d21cf8672fe12a80015ecd71c7b56864f8ff99ff96b50bf13a7bb3d0dc5074b9da439fb1570d64332827a346a871d32519ecae8d683c367ac4de36ec8017c0dd436f26fb3eb32873998deef0bb40a012664eef24b45e8a5a08dce1524e989e14cc67c4f5639ef43e2083e21edd1a4004390fe29a70b73b5c09d6dc3715377da816cd48f2e38162552f12234cfa26b85adb48d5abdcf040ed67261946a8838ec683b173f6da182025e256296242797ee81b6f7ee24eca7b5ff656fc895fee621afa0b0997d4e9097deb869a6d95a4affed5b5a5ee71990dbb33888b4a90118bd99bd7d28314e645834533c35f3509112a48e2c087be2fc4c2db68b25f2847695045909688b873738e2261b107e671a5843c58d8879b305ee582873c59c580e612501049483118657016769e1b7feffab3b0fdd1eed7c9e7e7b69a4d638586810d50056d6845a5cd11c73de6fc30fc71f0882f229e2e561d44846aebbf0b21a14d5c68d19752dc4b77663a9a97767d1265a109c5994aaf07367cf1322f997bc311478149d2f44f52732d6505b16a4f54799b8c9e38ce9c2206db556ae0833d71b317ac13ac64e895c5729564cbd91260ffd227823efd864d33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
