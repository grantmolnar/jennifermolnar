<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30368298ba5351442bdfe0f7c2f2a1924ceb1fe0c46589e30cb59e8f9dd681db6696c69d247f2daf30e44741bcf2b52d6f4a033a34fa102b8bd6cd04516b57c7f63e5c71580fbc79f7619125f5858179bf7248aca767fb26b99478a3553738ee220faf32ee1b7a182faff2afc8b63bce6d89e6e60e71e8555f3933e11a5bc6fa94d882e014396d8c82116ba00121d7c4268b458e6f5b74767466c0a0954ee614b50b119e9eaaa374c4ea47e9e7ab47b0abe4c66be7687f23b68f006f0a8aaca80cbbb5e665f058ec1a8a7153b1484f3b5df1d6f63d348b3e8bd424d9ccffc96a1f55e66750591c603444d0d409f111d834d3226f88f88b6437e5c52d5cd601064143551e4553ecc8b7abf608b9e5dbb077fb27c5c951567766153ef64cca82774cd12133ff81764c4c969752e0d57c6527e6a474d14513c71ecda1cd3243d79bee2e3cbf36b770c43dc08dd2a5fe5edb5a64b3de0c2dd53196d3d8e4d911d785307d6792c6e9f798020a8bf835dbfce36f648b19612bf7440abc63b70060b8b5cb487a170e93aa528248b09dd72c991fe6a7b8e38539f105ee0fba41fb9dcb82ce569383165475c2a5cc44ba6678b8932956555d96c414cbf8bb0763cd5588c077e672fa751e903352e5a0266c35e98f7153e31756db87508d6faf610539adcb567d033d881b922bf99ee4ac6268333f7fc5eac00d24485c85eeccb8057f5d2eaaa084a5827aad075e263cb81f36386dea29483454ae0f98b0ef7f4ea9175df685b61b6fdc5f0174beaf8394d6d8222ac60508626a7c0c917ee610bf0ac905186389d5b3b3739e5736dfc0cab70aaf5f3a415eef71d2253f76f87ea11eec5a7eb013a9c1156daeebd5552dbcfa74cced9ad85db98aac194c6b8c754be21863f37538516df509efa04a43975662370057b5ce6fcc18343128c37caa0e2f545e24c0a257e3958393239544b5b523205f588f3d46a4c59ab6556cca4118baa18df48093953164dd306bd5b03018fd256cd66d154f523fa7f24dd90777b97a198543f91f2edfca2583f8b275caef7f295cea769af99edeccf2a5e32fcf559aa16f8a881610fc2d8d90446a4347dcf4e41a312dc574bba0778b1c02799273b4446a40d696405259a34360e5edfc983bc144f3919ef3be13e4932eec646683b31358acaf53261e789da760f1b986256faefafa0c0915f30a96c0a4a43d8d4051f94a9c1811bb7d1d9ca3f9699b7e952b3d02ef81fd5c5267ab3c01761aa89d0986fc3ab9c5a8a52fa41c3088e8ca0b182b0bc20902db6db4e56c5c21cc51d51dcfe604335b517108573216fa13c8364a4ad16a42e2d61b1d737b6fad1960788f97579ce57ca87fd9b6ce2e6d69a7358e9660ce36844ddc308a8d7dc0035a7e78e0ee4b1d5acad75c7f055107ecd4790d2b37a4dfead380a792ec020e1fcd8f59139b6bb49f949ff0e09c5cef7d20fd8996c878966e007a144bd896de8c2eee45107d15986bd235a915db4bf65f6fd0661995569159066060bcd55b9dc9140e460a8068cb251e004a95bf431b117fb5442976fba8bb0a25d691bd0acb9b034395d7f160430e6154c37f5d6f7a7fd08a933e8c7c4c9cb9dad11ccf50d313328098b7dec838650e0cb529beb35f08388efd4e05c0b757ad2d1005f6d22cca32a512722cf0296d72212d3982320817b454fab21ebe40a35b1ae7ed75a139643d711a2bbd9742b4e2f6b2ab9eaf8bd3d315f039f9ff63bffe646141018068f93a82963420aa5026639d50559572089a686b998efbf51caaf3462052233d3f9b9ddc0a0ffc612d80362593032ba7ef25e1d9937566666c94494113727d6fba1afd6e29ecd65c86d604f49809d077ccb99403273bf1ad2858ab0b2f7557eb4d1adbf1d9e4c625435b4192d2b245898ccff5c93d852e2149493337d2e3d655d307a314c3c9458b7e38af7a93e5d867669ce84b696338228dcc2765551085d38d1a5a94b842c4eb72fd6d8378d20569f970fad4d6d9f5283ad4a6d5fa68a8f94e95787ba315ba5a5b801ceb1bfff107836ba6cc6f6d6af2300308a392789e25d1e981214a20f7681d14342311055579e24b78bb3a52440eb55549194a2345bf713d6cb6a681341b45046c73d9cccdf100551419e9bd1a8d4859740c088e047367029d2d598602df4b6577f8bb6cfc6251099a29fbf4feb5e5447b454e2c19e3c7c6b1974409db446e175f06b07c7ba5e5931ec82d3aa868ecc5236bc8794451cdb8c79fab952be4e3141095428927420189f82eb7357ca848a2565817556f5e65c45bcbdcdb75037eac68c9c495d4f3ede0fb707bc0d8a716b8f9af8d5ca5a8159b199b290887efdbca8db1817bab2b8b7cf5734932a83f49bd0f70486ec450f7fcf07a5b49507d84ab0da6fc35db6b1edffb53e769e9dbd10aa63f7e873fd96c529e025d8aa2a18be984ca57e2c0b0587bc367bc252a49ad8f0a640a5616829d7f3277a0d286a4a97cedf7c5152626a4ac0b7c079895038f007c62f268984c00b4acfd04cd1af4fdb8d8e40917faa80814f739f7cb33499ff4acaf8d3232145ca6c43edf0f82a4d0ad0c20c52db531ba9c0ba2dda9aace20a5ff7d21c44250d1f8994404f741e43d8502d9d92b9805a2d3186c8191d6ef31fefeb762c34ed553603d36c871825c1de2d53da6a3445702e0100c5a1129599c3237a1642a7e673bf6389f34d84ffe8867542cfe0eaecaac14ce82989c67e8d3080f155132eb2be0ac8bfb0092698447f6b27594be6162ef754b4b01a335e074c023742778aea70692f556a9cddfc4751e438b722f5f69c24964dbde6a3065cdaa06966f34ac927d6147f9d2e3d16d7308c95e780b79dcf7609a8b624bde28eae10f005d593006183fb680376c93d22c497d0bf77cf3fd284f77c17d7e821963647db4a91ec388668508f80701b4764e0f1104c59fc28a46782d4cd174190c85f53f89b5dac0c923d57d6d7a35bf995d7efb4bf78731d44bae85ca948fd5ddd1c01e0fc5f009488b5679cec3938dcc9b64f6087baea21b0cd362fdd37033eee6a6b83218abff7a1f649ef827966a8f7b7cc0070ae12e96a1a4994cb396dcce28724cd2bf962b2c8b546b54fc85e6d9d9a986f115b4ef1329f60cf76b9f6d66bd3d168d68141a02e5802eec6d2007d0f06a5dc247a55ff8b08aee740dd3fdf4b6129ba6a32de899d8ac9931c6ab96cf8329df299f23d60c50ad0d35f13f8eef79f724c4491ed0a06884b715887209045bf1ab7b5dc80d528640ce9326c94847c873ecfdb9a4ed83f1a13474fdf5d6ef3d154d09609110d9a811ce022352522189c800b1158bb40d252d9ddc1ebc1750a72d12ac1daa6937a6f1db6b01c817f29cc9afa9d900e8ed00e23a9669c3b8baa6fd2de80dbab3ef0bd1515929e936799be4a175e49502e5dc9ae5474f4686feef4dc51c83cf37758ca3fcbd1b9c7306ef371457aa0c10c89e940c4b1681b628a2d179cecbdd44e9abd601751cbe3ce1ab670d3284f28818f9b1eb0f538ce29a835365dde71ca1cc328c49793fd52255757419cad08a15a81976d31ee0d1458dd1493bfb85736d527af7bd9d2c9376d347f83ea3131bea63da474baf44277095c64acd53216fda13b389411e336d072994f149d6d08622beb639bf4c9cf9feb3fe6fb57f747f2c2701aa312b3d4c5a4d2c8ffac4bae18689ed05bbfe7f1930144aade6601f25d7cdaf6dadaf1b39cee06b6ed301972e450dbdeca154dd2d838ad414d369355b4926ee908b911c6063efd9e47335e1ea25cf906feee913d4bdb896bc4f6c2fa8e2a3c108d8d3ad29ca93c510c167f70c23e40b6159b73b5fc4ec618daaaa21a6bf1486497caf56faa379a76f42db5066ff45cd8cc1911b5e7a8830aec12c27dbf6cc2f997350f61089517e04c1b47649241c5b247dd1de73e39bff3c10d5ab09d54913d289655e57780571302efab0dd9a35407a8c0155e546a1e90928596c19ade0e5eaf43e9d1485177c5f716af9fe5655d7ac63d1576ddc934ab3d5e3aab095a6d5efd9930fa12c7901df7cec28646b1bff483be992f522326278f231b11fcf99e03f330237a2492dba36b93d899ff545192bf3d9bc2ce4779583555dcdee2e7699415235559d2bdffdaf69b666d9ad14478459a3774127d118444762a1e941d828196a5339d2b911811e04f8a9acaafd7980483dfa7e720b0127ab27dbe536e27c03bf1a21b624ff5dbb900d63888de02f92b3211f534eaa60e8c1893c786b8d0b239e02ffcfd7552679c76c1aa9b8f8673a69dd055414802b8059f5de5572a2caf2d918ac3d7fddcf4bf49a675158e9f55747550de6f92e0383e0009c7074e5b4fe44767cc209ab23cba4d61df7a2530225fd383c58a1a2a185975a37b676c81f6a6d9c789ac2020c0f3e1a9194db099817d66e6858e597e43b3873291e0c1833bdd727eba7eb80d42d83dcf0122e802b6f76c5200b298880182f0f2b5dca0d74e4915c0bdcf524bc9bd67e308b7bb9ec76bc236295c8c3f6e345240ef57d100dece76a770a2a7446789f0c878bc08dc1f2b3962f5aae89a846788b5b10a6deee367633732d861b86d5523ba5a585faeac3a3fad8fa22c661b79821a7d2027f545812bef83d3f65053c728d709f313bc02a1522ca2e56c9b76392b7f250a2c5cc81dae8ee8782f0f42532e7790240a243929713160b366163331846531390c2d2e43b913920d87ecfa28e554ddd9a6454ee412848ef22a44ca92f902c6546b51295a5520198694082b7e8952b2259e33cd83db7128da2464bfb3d6da3610611366ac78e6c977aefbb05288d945c5b493af3a03b275d742a7e063d41309b25a715ded6b721b20db9066d890a04b443ade69c1c47a5abe51bb1fc2972a5a0f6e17db1528bc16d9dcbad7ac8f3d96f3ad4bb1ec47cdfaa813715395e28b14fef220a226ea47c7c882d04394c795d4de3164fa5092b8d4430245b4a5cda24bbbeaba09e8fd63cbbfb439a6b3bc8f405a529c691b11a1374829ec2f72a54b8ddef5813cfc766421bf52af23335df5b608c74e46526cb22dc9e0cc6c6fe5c87399f94928dbfc311087434959e7118376f294c6f281775d88b24978e6c7400aa4656614672d1547ab69b35c8bd576238414a4f80165b12295e665fd222b35b367c3b4f2a08e553198778e94ad6a0816da9d18c1acd968adb947631bd9001601cac6dd600f5b1ae4cec5b6dd9c5fa565c06c805f647b8d587ca210ab93f64c90436e6fcd9b3c7f4587846c66b159af7df4e32a8c0a63ee6a6c4327890178b206051261f0d638e4d90dc02ae12a4ff2b23f07f250777097e201a877e22d8dfdbc926dbf640c2d8865efd1bf3ea67e4e69f4cad878015e53fe6ea9c4c596ee34fc1ef68ca0ae4835065865e7e0cd50acea3c259d3c249732b4734b5de28b2d06bd97914fd53ba4ebcfa10f757e8e0760b2321dd878759e3cad0cf71dbf726bccafadf852bbec55202fe067360d2a2d4c1839ca303616c0ac5dbc634d76f72ac65cda0fe783217b8f9bd59259bd9ddbf386c133e434933dad99a7604e70d435cdb4935d6d695a581fe06809afa15f30a4cc874da71bb330fdfb4c7d5b5a0d8a39f999faaea2ce63506ae1441e6b3ee6eb08dcb1dbcf0cec02034c33ff67c3546596bda50a8ca366d143307a6f6c33a093520b06c695701a1f29a691728cf605a840bc42921dc284b076e928b6f2f64f4adb0986484f3db7aa6d0784f550bf7d359c013eacc5c53bbecd903b474303ba96b9d2281e6682269f757180d17d10acfcd445e440ad91adb94a237ec70d1297253128224507fa87ee22ceaa2d3a2ad367a5c54a097d572efd89e3afdf535912514e39ee4016064855e7524df78fb6a9c4a89f21b88817770005d65fa3c1fccd4040d8012dead143f3cce8ef4ad7495659b4606b039e3dd900556c396db6f87924ccfee6286aa6d42cbedafa7dd20148f51d23f012986982257be0c52ba273626c8efcddaee2ca1a0befdf8e7934b58a26e548c7decb441488e52607e38c7fef0695968ce6d84f6c2db3c98961916cc23bfa0b127be6d00e317ec3516b49369c5f9f669ce8d1a0626d4bb45277a90370b986721f7c5188dc3d5496453de53ec19aa45ae5a7b8733d93fb6cf7dc29fc8e1a72a54d48142a29d3233f82968176c1bef5653310f4b445b5e91e58d01da082d9325930d736811d735443da98b50dc9d4020fc7f90e717de4ec56f8c6180d20879b9ee11fd43ac38df4b63e858a84b154089582c75e859122dbd75ad25f0a187907470bbebed7b41bb099c344b998e6f326077bd9a3b2363946904423e449c61ac16d9ac1896dc03e1740bdd98b1e0cee04464ad089124cccf43540e16f2e22054ebe8288c77ba1afda3572f47c974a073e561b7dcec678c22f559c88dd050482d851befb91fc9ba4b56d095628e905a9ce2c296b5be07a63cc6c35f846c5ee87c9e00ca074594ad9f71d4328bd794100eb68d7cea1f1a0ee477e9011e5ce01eff0ee767554b94394eee755d5e7add60d0a502bcacf9341d10d087f7b83613779078c50127ace781e8f2cfe2fe83fe6b550066bcf40610478ae1b5e9268b407b94f8f56fdb573adc0298cbba716ec7618e3519bf0f52de3df24d747cd7d2db8f43aa8dd7b8db824456257ade2552015037fad57aa36b4e505ef3e8130e7d423b8d5d59d7fe1154eeba7b8d3e1c65511370676d10f9d8161282e1b155b1955c5504aacb04a3ea4eed0f6eafda1946dc619be4cd7f746cccdb457dd1fadfb79f3bf082081004f79c281f97c058cfc399a31827fa7a3a6bc31eea72c4122688149f4b97191019529785291037639673f5f0e572da2c9e49b2d6024c5403cad7b9ea0c08a1c08555db54e4da5249d49ae78660c54bf9cd82546b9b5c3df2374ce855335ae4abf39cb99b157f978273658e8d6caba34be943b9538a3578c104e7d645d7809fdd589887c99ebb2fabf58a5b59efce3231943b06feae317da18ec4364be2a352714b01c9b14995304e43b0aed7594cd59d35f0d0df9713613e443de76f5c53ab6d79b6d20e0d299e117664053b4ad085bd7fcb5437273bf6037a353d93fea4a6987deae9d44ba631e7102ed8406fcad1479da30fa66c62423b3c353a662f499c14778e0625086df9865ffa47f16ab54f86bfd13f5dee8ef5d11b638c48ab99e240a27181a81e65b2aa06ee7a3df2bd0a87b32ac1e21564f64ef3b70253f880040e4fed6db4d8c4345f7402ac2d321ca66fadc1dccbefe8d1e9b0b8904a165a3f53923c9a0e4d18e6577e036b1d6db32e51d6e5ef2cb0e0a5576e78cbf7a8b5009c8fbc4f7732a9a08356ecfd01516ad16b548cbdbf12694acb4e4efb23e2b479eba370c40e8d55ec09fbee09e41e3d73991c79d38e5fad668acaef868e8dca2e581d51c6ca478a45cc5535ec77abae8c73d9301f45961a917ed3e2da9f20b37f1ee4bee4c4fe2ffb7bdf1e626f0a0dbf838497ed2f79b03919ecbf38b4c26351a991668d4b17a18918f169bf4cde43ea9a569ce4a40331bed485406dddcbe95e500cd2a33a44fccb2a90092397fce8a0dcc26c5712c688ff864837317acc744e38b3bd1481bd79b82b68030ec12fd4c1d4262d92923b1da46b0f3731345debc775f235a0796a5d63af5f40962377e400331613e29c78b2bae6593de8cb75334dbfc4ced9451d8434ab50b5bc61d66bec74fafeb0fbc637b2f17367898aab0f9a36b8d075ecc2b32e025161cf889cfb35d0396615c2f2439360225e4a95090d097426d64e64c1846054746ae6dba724462968eed54aa820fd8740c03b6874566f08c78eff383ad9e003cc9fe10d203944ecc9c28ff8b489e0061eec9719fb495d5404ffa5514920e1e3bb7172c12d10a40617bd27af6c2dd4516713f963741994e27c69a4c94a031258aba8b7830b2369000869149321e269384c3f4dd22dae29052783da0c22bd5ae201dfcbbac4c5d8a562425daf4291e3a0e987d875995ef259433e9f97b3474ede2ef081a3c53bfca6ac56394076c689e62885aacfefb4cb8d18656e7b07efbb01cdd307e49dbd37f069c3a46e7324639621efe86d2219b8395afb5d60e63c8e90907d7f63962c975521ba541fd2928ae253efe1769c23ec6e130aa1364af28de77aef0692299b43cae76d94cf35d191d3d9e88b203ce73d94b4b4d704460ac81be0bbf687befc31b1afcd43a9e7df916a3175ce0a2229af05dac11d1280510f01f7b60cd1df432e8b3c9d82bb266f5e63a90dbce223cb910e9186d02bfa3697fffdc714a37d9862d0dc3735286ffc99364bd570158dd25876542122b2ef381243f7f19c6c2fec016e5647a99935022421c6981b1574cbfb8fe0af724bbf52607696ac02074464b743c682bcb77b56948ca47deb1d9cb316d4932ef3e2c2d847089f2e49e8a47c746099b6b6d0d7ffa461b808023edcfaa313a1a99df0d5a0d2deb6eec73d191edec53cfbc5efce40ae69157d42a70c8ddd36645ecfb970d2c7ee050b14c16efb6d3ebf7717366aca8b0ad1e1489ee2ad74d0662884acba77a12b235235e4a468beb49e3f498f6dab9d9fe90bde8ea915c388f270373c2f8cbfda095dbb697c5843d0de78816843eaaef8e5953d0f8402266e2bce5dc214862bee47cd432851f6f220868cc4d4c42e9ae42113f0037c7397cbdff9e0db06b2730f4ed1745e4c0dc9446a31d891706f315df694e67796ac2f02588854aba2384b93f0e4f278cbbdc6ea78fec10511778adb6da8d8566a8aae8c244a2f2dd4fbcbda29caa68d4c25b7c800e5b1f81117c0798a7fde2bf9bf13e465391cab4923d8b9dd8a2bfcb7cb082467adf765fae6d169d9953512e4aaa3e45658c1ea4d30fbdc483a7dc5a78cebf8fefe112c476f35f987af97262fda3cc9e61fe743545dcc9468e08f5f259a810318ecd6a954cd2afda18ce8b2630e3efb7844e02479fec70a58ad845118cec111a178bf8adb66a7634acb1c260684489fc3d90c0f47f4a1c646bbad81d35c043912b497ca84c174897add4157a55884358be57610312b972296bccafaad66f5961950f527e34af3f01ea2f54d850627c49f5ffc6289b4e73bfa19882652aa00adae7ce638f4d8c9fed4fa7400aab0d4f69049b13ed9d1237d315e5c96f1aa660aa316e4f2350fa177c08b725002c29098e7d90c3fecdefd08f0d39ba7618eea6f5a623949b6d10155ca1a0f737429139c4409a186b191a60fecc7073535b020843ecad6decb6dd87d686edfef18b9fd50f0891830f305644f5af374fa4bd38aad0eee751bd1d5f63aaf739d9f8ced45e5924ff2bf37a48d16a763e3f9af8f8c2a29899b7d0e72516a55f197925d7137a2a5e42fae199c407d2cc6a03622574b7eab11717df8df7fcd31bf3327919210900bd57aa3757ada6c4b10c83f7c89e4d54ca3d26d7ac80e52846eaf80c4c7877c0ee12c73aef70a358b5a97aa17dba95bd35824e0383beac07c8e70bd187ea27686defe9f1a58e9ec8831cb5c78051b09dcc38524283cd5a511954e9c1d5b811f57ec33103c3d32fe67dfcdc66bf614c6f4b533c285b28f071ec59b321dece696bf2d39c49a6f5b6e03a967525f178236e415ee1d29cc0b8b31a393f7e50fea0a6eb1f33595e57a9cc821c2d6fa5748866cbf4b65d3e1bb83bd5aebf3b798db36ffc364240b1092043e2f000b727ed7a2891d0347a658d8b9ec99b463dcae4d31347cef1fe612c2987c8477c8ea3a09349ac868740bbe6d639a37764bbc4028fd3606cbd949c28dca2c03afd6d642480f34b5e1f5e3640046101ac06e55b2b163126457dbb598ffa376d30964243a73e503d164dd2cdaa6e3339284e4d5d1500a410c5ee72b33519828d6ab0278f8a676d846b57ca783151a82f62e4e0411fd8d8058dd0b063b6a906d9922f7a56287388d771f7fe7932a6f4b08e2c906cc8ffe2d05d8c540a49e766ea6ae30751c6914f40a5fe3322eaecf7b40297931e0461a3568a24a14b22596ef9bfbfef0982f00d5f0bd447f59e4a79bcef364d76627457a6e6211a42b35094822665b037a4cc20a10f64a29263f57622abd3a297a5d5b850660874da7d449a54034c52941eb224b90fccc234557d944dd3dfbbe824ff17da36a351536fa01ca9fde8f1de042780e0ae3dbb8548306d992f2379af3bb0be041259509ffb23ea1e1e54eea3ace28d8f139412ddc6b68cc160f029d2fb5643dfaccc58815d350c406b674a411822241bc19727148900ae1e2735f39f94f1de89d95fb2f39af3656d82b0e9c73417472e404df6bcfb078a77b40b8e1261c79d1daf313471eba73c4e5c2e0f8ddae2d0dc13ee26c7bd5801a7c4ed2373602107ec5fd4da27a63b7878c3594b4c660a6180a993a7e1a56abed4d64eaf46ebe796282488dd562ee33f2d8c2923ebb303d49821ef9a7030ada8e53b9b158b2e2204ebc8509aedc12ac6b51e6453ea7ce835789493ec986a59baca7f78dc0a0819f29f828f07bdbad44125d6a430b8240fce259a4184c2e42d859e3d14edb820b9972165dba8602768c6e1a17cd0bb3f489c5c46595a0095772163ec9455687e5df19ecec90fa3130de23fcbda0f534039624fe909f6b6262df8a016c8c6919704ae5258d3e85040dddf6874d8a6599b9a78fbfe9e258f8eddd8c1c1a2faaf1a18b8a71203c6177e9dca4c7a59217e4f6949bf61af348fae76e5d1c6c10a03ec19e7910466b8bfff501b1294048810f3b90f2a1e1a387d2b7082c25b4deb08fd211e700d988e630f36345a654b9416bc5a72e144548d7158f7e729df0255f383161ae76a46cb12217633dd1d94bf19cbf7636cbec11608206b8f3eefcfef138a88b3541e5ff52341551db6b9150995176a7c425f90a6d01cf39b0426e60157fadafec3b981bf8458fe2904c71fba873350d1c06738c57911410857e537dc0e242ee8ce1961779e1b47bbd92ecc0c687f4458e93f278b749ec3f3106d02d041da6ad26fe67fe7c27464079cf8f2635f6a99ac2570f5e860f77806d72f414829defdff0df4a19061d030689397158065cd17758a4e09909ca448ac89e848e3f023ee988f396e00c26f89008ea812df84f8b312c9da1e6d099ff43ff6c34090e9456976808a6235330f4364da7bc2ee5043a24627aee97c1f2dec7dea7a7bc1db74c2a964a36f3464b25f43d01aacea8c5f6eed6ee8cd8fa70fc3c739ec7147360301001299120c4097381f0042238e1d00782a65836f380591afc999da981b1e02225ff5adfb69b626ba6b4da2d5bc61dfc6edfe011d23f63b5545a20f20f0ae5e1bef77d988512deac0a226b5da001513506168b4d6a26cf7ef7c3e2aad7fb5b13657548bbd8b4854396b8da62e360248d2a9ab5b617b3cbfcb0a08d26b534232b607d22dbda2d88dc0fabbc5fb7af8557d33003a9853cab10e68ac7850343f011a402a44ab5afcc2c28e0ee1a5da80bf6a65b0524289aeaf9414f560ae6f71af929531f9d9ce0aab577e249cdd4999cd9f83b9b2ab68aa3b1954af1585e7dba26b75852850001ce5d49696081626f2fb0b3f5bde5cd7739d235b06ffd2884f101f0e691fc48d61785c4f0130628a06d6a6873fcc5849e57906df2e6571e35e8a24b49c01eea1ab01a7b75ebc42b0382ce5c46d32c086b114a6391410b8a2b2c292f5f270170f86784c7f94c7ee121b3807bad46122b361a358ee471fb7dc4ba9b4b12ca028b6c194d0f24f314dd24087dad83d3a5514fd47a3ae1dc18004da50c299e66faad992515d98abe3cd4c244ffab91e1c63ce3ae0006670a3a79a2c2745f4d18358658f3a1fbedf47c0a5e4debfc359cd5a17563c07e2393ecc1c776e6e33794c7fc235fcda2d844304d97d97108e2d4763a72e8925dfb5516c4b56d1f6e2c8a9aab7c26cf99161ceea72ba6c34de7c3fd68b7c054182d66f26bf36b4c61720c8c54adc22108a9227af776295c7449731860256bfc65246ff44b53db097fc1552c5129464636344c0731d489910c78c42ad54ba4e657ac69feb243a0e5e77061a850a6a3fa0bdbbf7e8a0e2db49b9aac6edc0b081f29143d7436f7dfa27a0d51103dfe1f6614d6a9577ef24401fbec3687feee5e540678ab6f2862a69574e24b88f02e2653a810b0928c6a448abb6c6f6cf27b32b180823884bd59dbffa09ec5e95c9aabb37b9f49f993c1b94cf0221a7a932b2581d559f806b78424a244ccf7eff124726886c298f1f345bcf969d9c901ebb141cd9cff2e2b9e64ecde27600ea052735bbcea458b4b1ba048b79cbd1006009a2dbc9852c52097bdf54f77466a06b20dfd40c869b44f3b125c65ebe44b0f819ac6150fd46e39acee04d13c3492eb6fdfc77e03da955bee58becfacd70b865354fcb44d2f2f3d4d3cc9db92ffc8aff00dda3d71bf6f07e86301b3444ee774a290f56e40be0da16179e0c673094921d6d4293e5dad7a4f564ebb0307db335a3d58676690a3480b5ce89aa34d3c553d3b5490209716b07a91c709279c70f4fc8672069b99f24763e368ff446f6642e0dbcf9e6612f64771a4b1d21e6e54eb51e221457465518cb050ae1ed4205751b30f06363fee7983ddcd0145cf0320c75b2ff2547f27da490dfc3fae9776225cc343176ae4e851e9a52b73d9b7dab140883272c0b0696be5d47920b61b2ab2bf6925176aca60ffe765257fe9b154200962024bc32ca9bb6ca0ba4acd188b6b35ede78d2a25a6dfc97ebebd6b7ad28ee47532cf296140df0b18c0131dbba253d12c73868be2074efdd7317b5786bb85ac403fbdd26bd432dcfefd71a0e27edd534060c5586b84801c8bf983b2629557914800377950df26ae64f837fafc876d92fac3d944d2f2b886272755ad804a35308b5a6f2247a06ff0fd4007fcbdf57b500328187b7d0964e10e2a089fab0fa38073b1a805d9e830b76390e06556c2100e8f676d5908f7c9c62511d2e9f91bfbbd289a91fe24bbfb1225607cd2429bea478a7dc5db62d4a075b8048fe12f25b4a703ab9487eb7afb70bc1000b3224e51f1f71c3697974966b32fdabf4506600ef83c4111f48beabc59f854a0f80effae7229237e1bba875d8221b23ed8353956b95a48a7bdf0de7d06392997d68eb609db749c9f0abd9653ebb2343d83b5f993cd7e2d73e650a93647f6c16221185c8c13f81bca9b6ebdf237cbefe3174df3b76114adb648c48ae705c327535599c62ec6c0138548791551c46c500a5337d2f9ec79b623dfcd63f91dd4d029369c78d29278e8d334f8f3f78537cdfe087d5fa4d1abf08d7ec1b307592e229c8ebdaf9108c063edcf8badd49d6cecb9298bf256a7c1ea6866f5f64946422ed5ab69630101ea895d438e5b44b32221a0bcef30c37df906dfdce5b9bbe4eaabc06a2fa266cc3c0b5cfa9c86ced68c0d9dd8ed6e6b75f41acf8955e757b55ac3c44e321a924cb39737a4574e71c47338f339acb7aec9a278e4a12beb1f2011669b2b747f180a5194c4fc438f5873810357ea84446e7913e1df07977ccb8318c6dac4f0b05b558b9474260a69de5ba1263b69bde21f316bcfac6f6ab0a0242c009c598d82a6c57b95fc39c278197f6f9a16b7b18d3a6bc96c231b4819490cd45d4e10214d6b05f7a55b96aa2dd1411cac67a64a6f15f584f38df19e0e05930500a16e4937b86ea24229c224fd3c997293e5b14c264b3617f2a4ebab480e9b35ecd6e0cac134e785add5391a8160020c13f1004a3e8ca12b5a6b5602e53c2583b1f6bcd37cce5f0adabdf460544ded529d657dd47a25a54f0b31d4903f4e97b20686a6e8dc5eb9ad14dabca7aa63184e1a6c0bdb58f9270b32820d44b45d6bca2c0b5efdcdae4446c3cf110cb5b376b0a96c04a863718ef16b4f46eb702dfb51a811219af9dc5e3428df6b58a350188a6e043056ed0854b5f9678e956c76ac36229ed50d19197b9ffc615710191474fa3ecaaa87db76d438c9eee0ed9c38e390885c565a4eefa8a233b0876550674d5ef6078a859cd30d6afda9b80eddd9272ee60fb52eb8831de44632ed06253f7a78716a35d0fee2e20368507510c51da9daad34cb55ffb8afacfceb6e6e2cc18b5335f87551883677e60e49dffa7d7930eccf723f1fae8ebba306d8e20413a42ba3f4dfde8fee8e92860e17bdc2cd39cb2f90ba7849f8da92a3856bc052c546eac7916677cfa4d233ca5b875afb6241dbb8c2677a5a5cc7f588b0f331bf836bcebdfe69977bc2e4cfed6d0046046e263fc76cae083ff0f1f2b49fdbabeadaa45fe38e90362bb051443b495fe188281266fa24aba8983b3fc1bc7bdeac12e1491ee184d5d82d3bc8842d59b9a580dd3cb4ffe638c2b1e50c11e475964e63dfb584cdcc037e6168c64e0bc23cd4229821238d01f294bab46c0601ff312c20d6267d8dd8063732d27676a473e846f6c1aff60c327005a376afc9c14775c301ae79ea3282bd3d22dc732aaf3300f7ec9dd8015f00b602075eca45d21fc66883b17d141c23637c70e646e7c33802075d005989ced19ff3411ac4b9ddce7abec490791025db7c4039029303f2476a6b82ab732acdc8de111dfc17f25c68f5dcf1f696509e0f9fccce4f80d9fcdcfb76794cffe7919387671e1a914893d7cb906a44a69611348b848064ed8d5b0e6543a6e5fd001356b370064f4a5ae40a7e0b3551ae0d808c0eb28e4bfbd0d22e15217d07b0e5aa3f7cbacc192cf678e71ba57655e8d4bde1fa92d3b9b82c88eddb3a972742c439a8d0addf2c47e81d0779377633cec48dd06a6b48c6706abebc5a2665b3dce371a7771763646c86b9faab4c30c41fe95d725c4685df0dc829a4190447b93787649d246f201b1b59a16f70612724fda8332e35ebdaa7660dc0d76793cbf9a520e6d65bc3558f67362776314953d69049564f63edf3d5e1611dcffd0163ad67fc6ae9932a3792812c489fddca47cad71b56cdd9684f215748555e55d7178fb5c815951639320573336cb5801f93f939e93422f8dd404bec6c86fb82bcc7d90fdbada636d58560e7a6489e28e3c61032c0bdb7a5c9248ed345e49a2f2de5f736bc9c84d1d744a492aab4d85e5049331a88ad1ec4124dd1f2b9790546a68beb70ce329671268c8eeebb6a09d84001d3a790ee5432de86fb50cc0ed6ff739bde52eb059fa4ee7838f1d6c9283f4f339cb816a897e5a0a6f720cc5f1f03c029e862aa254af32162bf96e29c437ffd9bc415c958d01c0e4b46e2338ae6b97c39de2e021f4c3ba069226e5520e70311e86a138d299ea908917a15cc3e84aa717512cecb9ea830848d645dfe07848fd21e50eba4093f0fd7fd5efa76ef292fccfb8fdf8766b7774ae648e75f1482c1d8eda40d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
