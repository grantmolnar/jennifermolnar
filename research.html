<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7e4f118a095c6c1e1743097ecd204a473dc1fac80e2cb7e82a77ac722d8d84a5eefbc05853b1cb5bc50eb97d457ecf21b25ff6a7ce8a3ca4acfaa38d3859a4fe212ae9e1c94a12e1bc10e7317bc8d117652f7d96cb975f12ab96e77b7494e0d4a13ef9e4d1a8acc4f76c800f5cb9a887b5722bccbed115e185e098cbbef7be28d20703673f4e2fbcf47bc472a4a3ee92a020164476d3276b75df1d285981b86911ec67e802ec50468d1311797aa4899942415c22f2f25ffd8ea463863238dde6e9b12b4415ad1f03346a6ab3ab151c9bcd889e6b5e723ca0757d5b9391e3b87b73a150206a2c90bf8e4602dae1827ab45d3e39dffd6df21de1c8270c5bdf05772df17717ce23fb57ba32dc07b3dd9db87accbc5f0a503c44e93ff4d5d616f230a567ac97a7ee7db6c118bc0477bd18af66851ef3691564135eb2a5fe2ca384a8f0f991a5b21ebd4632c1a2e31566ed0e3df0aad1294044ff8840f3fbcbaa4f3d3e483c36caeaec88377646ea5ccbf1d018e10929e3c30c64c9a86b93dd503b5a16c63b3e265ea776fcbe70079487fe5c4fa65e7e2d66bcc65f5d37a0f38b4e2d63615a46ab720b77ff1fe938a16fc0688216880e80eafe680d9ed2143d8238627947c1811edfbc1584d9f9892f6c4f4fd10ecefd891b87d7298e1b9bb69b232580732d3b67bde46e7fe5d23b7f2bef8bbd32d827a54e237fa18312df8f2a496d7da3b276ddac9e713fc475e89dc168edaff97aa9fb4d2ccce88968e8de3bd6944de7fb24880cc728f2cfb2bd00c5339fc8f1b3803c1fd988f9107cadc0a4bb5b08f0f36e7b755346d078c6530641b76cd606e0d741f32f49617170fbcab1708dcb7fe7afffe12440c5f4a424ba36e87b2169f4ded41dd49e7dcdf93f035598bab1ca7b59f8e785fe3cef52e7197984a7a3763d44b55e22b1706ca5844f8d40b7d85f593f7b316f2acc6db59eb774ba65e2668279f5754c25d74888d4d74025c57fa99aabdc60a3bbfe7be7bd16b94eec91b90e321bdffea14bc6a6bcab3ac1ddd2e3ce84d46db91c6b7b914a60093283eafd505d982f1d8884f54e01cfa34e66bb82e1c997046fa980704c9b25efa2257732d3049240cca5a5e0aedbad309390650681cf194b34e6a2e2c850a038f21d445aba8c540f663b054554204c8d04e89bfc69031745d83b8063231fd63408b3ceeca0509874f12ff7e0ca2e39c0ec4ad327e2ecfcd7e5a5faee296f49e94a23a675044f587ec52d155ae699c6111c8ef1f090aa3ed1729173126038e4a76aebc64ade2b84b36fddf44435b8f47a7afec869a6df0b6604cd219b890e67e19aadfc16ebf21f26834f695ef2d368451b0de244b5695faef30a418718305301745d4bd39b95d92968184795a3b9d5957b57733eff9ca559d1f756e1cbcd26003a1dc307b39fd5bb64c3a5bcd7b660448452b79887e81b681567a0f25bf18b86c0f5f68439a71235188ba2c4e7295cae94737e54f8d0a3d7f890a9f5269930766cf227cafd39fc18c163c87afc1303a7ae0d1bdbb7b6d145263b3960361401007c732f71bce683857f5e50cb1575df130028158836e33360945ddb91e1f874540e9c0a1363f59f4a2b9498c9b5049cef0574cf7a1a595edf75e68641c5cdaff7bdb9b5b566dec89d79c9661ec9cb637efd9984f35a97d9b3ca401fe4189f99e2998242ddc32f9e7a6e9f6576fd573425a8bc8792df9134d27f5ac1c97383233fa51060ccd3a5ea78b641b4e738eabaf98fc614bae7b381781b909931a98ff9908e47e6b01b120b3eeb02b280827af407915be5c90cdd3af7a3a545a3fe96d86ce9475b9081f0bbf1e3f441b3394416c4dbe6278e0e3f8e04368ab3a4ef5e80e90fb4308ccc66d4b51d421d5891fbb40df17e035fc24d02ebf454a04e3f7bb40ef3582092305fd9e20314546280e3395a76a2b5166e58ace15cb5fdcc75c7f466e17fe0515a514225b6119bb0deeeee4bc51142d64545d84f60b60fa0c600662ababbd751dc9bfdf3cce4159e7ad6fb7df2aa68b67f26d5e20b7a50f41c0ddb7f97a4e2fbc740432b18afc08f27d3d053eedc97d9977799b2cee29a78aaec1206ebb1a19a8c9f0d9c0169ee3be560c7cff9ab6cc381d1941a39fc48b5a10412095a3839dfef566732183e094b0e41c51e44cb83ec649b855c05117ba68aa3e09feeeec37115246e182049c132c0b1c30ca114af5ca7c1033948d30bdf773c587b5156523405cb5e219cd64f995c92225cd624ecf29e0bb68b32cafead7cb3b05e84796ea9a89b3243682867c1f869f44d3bd1d6b6a121f3ca7904b01f83c8598cd949989b57de69f15a30f3f4c856207cf721212da54dc2d06c745403151010c742dc9103fcafcb1da5f16190c0abf76c2a3c33328e4d78918a90b9976a755eeca08313672982f4a8468282493a3d8c4646b7893988794b7d13dce06ac6acdec381408793def1813054e9e5c8b6b0e67d6b7cbaf3d2648e5681eb0ba02841d7895570dbf687898e60283fcc60a1a90dc04646e5c0c600abd53c3a85b9ff79a82e8c6847794bec781375bb2609b689831604f8e251549416421c5bf252a8d11be3ca92430713b3a2a23dd14b70159a83456df7b66a032c48b0baae01f8de6066d62d698f73104a82a118ce62805c631c2022e9181ec5983e43b2d16ad993b7736550eba22ee5ff2e897e130dfd19c960c2e77c4720b8c1a603ef63b95ba20ddb70422758590db6c349586c15bbfa47e8d63cf50db34c5190ce71c2e86d1feadb4082e2103103bb2a00c394f5128490212693a8564adb32d204c1c8d6b1b8fddd9ad9582faa108edcfd1d017c07ac271ed7da3209589c3fff76d113182f5b841ee4324c730171337267ca23fd816aa58544624519784fefea4db2aec22cded93be9473f39aa8d5a2b6f24b80e8d667e26fa902be959dced34dcbba870f2b01f84a0d1958b43f59cc60b8e7567c08b38276837306c84407f38ff89010a48993c5333afa9294f737e5c1cbf53d4b82b279f9778948743266874ab52f6f86f6f6cc72482c30e43a544758de3cdd708c597dbbde8fc00b7ce90636b1157093089f6678ce99de5753f82629a725eca0eb391346cd49524db173e0a20e5354bd77527013d7c346d4cbde1bbe413b275cc6a9499a7849f0c48a236cb9f495892456464263ab61f4c22051774940ad6298070b3237a780613f5001bcd557877a297cade61fa129baa68251ca4d481ebe3b9373de95d64bee2d2ed6ffbf91230da2a31d1217171baa9c804cfff78e73ad8d645fbeed3aee93d2498f15fd21a5687d22fe9718274d2c1a02b98e10e73d583f93e808788ec24f5d490dc3022e5d0febd79addc6b6f128284c14569a9309289965efdcac5751e483004d22915ebbbabd77e309b8f24ef8003ba4fe913e84930569107e64109e12a28781d519d3fcbc32922eecd5feac336e472b76387664c166621728df31a674e07c912484d75adf7175ec7b82bf7e31ba56e89ed265a0626a4298b12ff81d816c3bc0a3fb450bb353c8e6091793216b5ec343f697179f8b85ff7c4682af45939ad57589d85cafc59a5b5d1c3fe806fbf67df9e6c6d8807c9119dda523e487f2ed2618cc633555e1ecbbc6d6ea3520f65d1e8db216f027347d3efac84af8cc11f8fa069efc83c46b3e82d88b977300e53fdd06f26ce6afd71d3052ffda80a59332d0b5ac722341ce1dd3281319c74812fbe93ce946488ff20c4f3173e644a4a1991bb2148e9e6c6b139629c4f3a2ef72549fb4e3a6174ed3bb9d99f31b17bacaa637bd263b419fc38c11e6c7cfdd6589f6430f71469c926ab22e5afbcbeea3522cc9cafb2cb3e74bc8a475d878dcc5879dc83dfc57691bafc4e77f329c0d022a7fa86c455404f9968528a20537d6779b683c2c558e8e0fc40708cd2b4fb984feea9686ee2cc1cd5c63feec0be696f60b13ef10875471848f0014c65f3e13d5f04cecb4e70932f0de1be8c973d1e1731e253f7ff02321398003b4e73364c706e4f54a2ad024b9bc43e94443070944f4ebb430dde905c6c9004c3f60277f73122c63955e9486fd2cd013e16f19ded45df9ac6f7ab5bfe70c6234e47844ce4687fc26e2dcb650a01de2e0d6285cfa1c67e446a8b39a9e03a9af538dbcc0898ebdb80a80d089bc90e2cc8411cc70996db24544877d9201193e1be48ac7fb403a6cb0edf8d0f1b200d222afead2bda45582896a3d7807e0270721e744485ca7ea9dce0270fa775c6f0947c75c409549188995005c085ca29184bf09b90b8b22fe60c4bb35d8d45c4e95abf508a9a96b258edeccc953a13cfa24caa58b944767b7e749ebc7937f737283e12bcc5ce12cf658240dae15e88237c3d5671633c35ae89a68fcab1694f07a51eed166d285a616564cf1c66a5c35a35902a4899a1ab7ae24f43ee9ed416c93ac9cce14f781c980fb72b5d943fcc00f8ebd2ce90fa230942b7845e2a6ca4dca6bed76bfe691c41cfda042dff81730b26f6189c6d4400eee33c9eba8d5f6d0fd3418e095fbcb77b01aebf4b4d4947c7f3b722d16ca396f680012f55657ae32db6c673f3dc23f17f790ea57dab207fb7b8247b91e6682a3d67767fba164309c6697e9ebb00b4451c62f31fbeb5f95c5ed143e017877682fbbf2c9bd4b4e62ca364fd67dda94c8bf2628e857da60f11333ce370de4e041a6fc676a8f71c80a753bf32a0f0091540b84e0e943029d8e9829d967e4657e2c53e178351639db2a9c17f0173a31fce304a7d207ca9f7bccaea181173759ef3ca3925ef4d345bafde5cbe9626942f5d5618932b7ef7f951dd6c6e85289c6f3283bb6e8662ab7d03cbefadba8b41044eb9f43263c72067ab9e032239b527b7f7dc9caaefc64c38fd3de94d9a2b65093afc36b6583bd25f6a7dddf3d99c54d0ee43e7725df627007f842c0244f12d49be36abe03736ce4a6951a2c22f137446594d9ea5c7ef9464eaa310aa3f0afb8bfbd73df807f879746ad304b4cd88fcabd012818c0262de6cbb41500e40f34eecb179cc209844ea65ad4f01caf63541b1a21539cc4e6098c045a7367b1be80dec156d0e2a55ca58b00cc1124d2aee5edbb8cab2297941b48a404fb70b91dab66a514f25d51811aca62aa5f613206255abd3f305eaa586e4dfe253e2d799b25b0406db4f4d5b920640ae26c07a95330d4a5c23e2a149d1ef8d94c4d0238bad078111bb8d2717d76f3ed5b4eca15f4c3d422c36471b65058d7b15ec65edca940c0c771f66173ccd1ea6b00e8765822a61ce21760c5d7b0e57360584f3854bb77cf6a96b8cfaef8a4ab2ba34b2ca299e1961f91501c180380d50c46eb0e95a26df8e15aa68631a3c97ae60f220e5895b0f7d7f1f28fb0713a500b87c6f2a4f3435bd1b8a8b5118d81463ce7508a4a7b16abb3dcf1776a1f92d59a8018130649ff98f5011311bb0a0b865d00ca443faf24805f898f87b1c8e17d4ad0aeba0a00b62b3adb05ef4be996459a610346a81081df430ba8e13e33f4d33e8d06cb31fc54f662067d30b8d9d4fb8b6726f4c3d508c2b5daf7802c784601f7a361f88b56eb14e4639f4da70c295b6f23ef02615514762ba65e96e66c7dad6e9616fbcfce4fee583c86aba1699abd7acebcb6e24debec2932654717b762d3aa452a3a7da1292155ca9635998a0ec1b41466e29dc3f79b47b07324e6401995c7f9d7ff49b01588fbe4eebecc8210250b182a6ccafce3b291757d56eceadffc5348cf841787a9bd8aa75fd278fae6eb47f1917382445046868df4530d7219596fc163d1a5e99171ddf0c047e103698cc7789116ff2ff3004f9c7d66ea558715b2c3210978ef7ba3dc2c15cacac28a250f0c0047b457335b1e435b3b9ff298211db01d2140982a9daa73982d97debebf0dad2a3a591547dd7ac1f2c1d75505f35c7167457d58ec400d905a025ff590e33cf294378865ebccd95ba242bd4637a6b1dda5498ac37bc8630e7fa7a35efe0c4d5809be3034101c8ddb3e88f595f175451657801a6249bd89b3d74d05d7b845d6ce2480b2d0b373fb47b9017bb09d256477f7382063eeda78c415e33a483e250d9b3de370ebfdfde6acd693c1685b4faa34f4e428088318ff8935430f5dd7c0da19427a45bb4e7ee5e02e352c473b14a683eeec07034df8227ce4a352f8b58bab4cf4d80f6fdc759e6635533ea5317da7cf1863366d551ae2903f7b17846c64dbbff8af562d9763364cfd4cb03396dd2d0bb32f0d0283d02be7b5bd50e9e7c27ec4e146e5a809612a245938f3b73d886589c09d59bef88a64ef40622c0be624e4e9a66df7d651eb681dca1d76af25b0c0541354979d02a3eea8b18f34ab33d946be157c8c44239617ab1db0991550e141ae06ed074c24393b694a639ef11b6615b60d722d9d32744665fafc9594c91e47bb17fce47c40dc053cc2a2ec20b3905609b4390dc4232cf76c48ff9497afa0ca455e783270ec8507add68054549363163521de4d11277a0d585ad7aa6436e23c57f27380d89877b76ca3397e59aff3cffb4cf9d603d470d556d219ef5b34f8e74a1eed70275a11b2f492ddb70f07e0cac284a1bdbb5ea2d0f597b3a472d332f5cdb7a3e32bfce75ff766a9a988f315132c8b5beec45385a59a9fb128b4edc0ddef6649cad78ec8a38fbc20c016520681e1a5596c0662c427418f4030e8d1bb66007d3a9364d81c0b5034d26546c4d068fa9a3b449d00ef60aee77f4f70c645ecb2dd3b3c9e6a7517ecc0c6597a3d3cc6b5c218f7184a42c9ca438380719854e8d0c59d41e078d4a90f73d0875159907feef8bbed44260f985845ca4448c514aeedc83d92475764fc97c6fb11604542aa7f22142969bb549008c45eee3a7156947a99f218320a7c0593d240a5d715dfd2dcdacc8a891bd0a1f05e9647a7d5cb2d8df76a3a6d1c01aa9b56872a7f05a8be19fe825d4e891b8414d9771008b249611e286aee0699a97533d1b1b68758314dd32aec9362459d837120e86fda3f8da608018c0d3a7a70e4c065e40b15bde50ac38cdf2063bcf368913578638e3e036af77e35264111b577775ce02b1939860073e67fa00ea5ee6d5aa458914c0e9951fae0a0df5c04e7b3528bc5c882dd86a5e6cb27bb04f1574c2ad05d56e4c8c88b6cb36e4504a98cb42e1d08c8818707287c52c25a6454c7142ac62784265f1c48a0dee8c6c7486e831af9426b94578fcf264bf0f840e1c9bd7c619c19168011c4c1426b293508fc49235ef1df30c6c3b778563b43233e4ecd62aa8e29844ab16f6e8b8e795e5b48c6133b8be85f87daf5e4d5aafd3c6df2a0458b2e36be2447d0fe5dea26cb15e7ca217ecf8965631cce78389fdfbf0c78d69666b22c5cc552335e2b7b41463dc99c79d9a06958a1c94d16a68dd36e269eec475b9c487b647070784be409ed11d62a4cadbbaa1d291af36c704ed7791de7fada70e2e2506d88c7e9fb2eeb6c2c723bdefe0ba3b9b31c56aad59339118e1839b32607704bf93ab087286e57997375f6e97838aebffc2eb7ffb8b0249ed613aae82160deeb21063833bbba56ac12807260d69c7fdf46d9eaabd5e1260de3d384e86ea06dbda99c13dfddac2508a0b9d3b31776af5e1333bb6e2b75b91daf0dc4f3f198460992e2fb2472768559a122a28762ac4d477d9f7c50288d45062596e66643370d3a2bac66c60d50e2a8ab8305a546f8c0f513c2b85b7ff912ec672bc2c65bf46b442a938d3359c4a1c4a0a28f1b9ed0d3ac963e97ffe437cc7254290937028b9c7cb2e7e223b0b09b1ab1ae07da46f6960a20f6576c7ea45eb788df9b59e753436a53290ed6512e1424b49b378ea2a763157114de52330d4a8945de51a78cfb7edf316ce27333d1c39067cf480b98c63c2f9dc7e2837eedc7a72b259380e6f5627c5ca17badf27598558e89732a25f33821ef0a7fa9998c8f9052f0e19615b0eaecc5da85e221fb5b05ecc60facf3c23f4f2e5021a92e297b010e9032aa164b622d8be36af1f7fcc65b118679e2bd8fc82d3bce42b49cd224ed464bc90903d412957287e3c3b8a353eb08c87ab2de054c82c3c6dc47c07da7d85dba02bae94a93627d41dec6d0df9c8de9474e5726925478f7536906d12814d8d3ed20c270b34bcab345ddf9afdf9eff364178b94abf8c5b9fe48e4508e17c0a24d0a990b456e15d961ea952d1797348db6e5fd52e1114cdff768c2547af875c14eaed39a81d4f68b66a9fede0f9f4bea6632e4bdc34ae1061e433296ff0672cec6f54ced4b39c4b922b8a4efb1ab39e71b52b9af1241924cad1e18b7db131518d28979967c2c1b29f45149168c4672cba0b7e643a9634b4b8c48ba520082686878d9980c0388002064c7d35d31627ce5114d3c0f62c14e17cce8dcbb939455b69827c61ba6065654c64915aa04492b7f17d7717fb9a26aaf6863820199668a4431bb4f35c3e58a999e578573cfbe47f551e37acd2cb0ddd5b9419f8fefb21af57de976534eb4de2060e112497dfd18540254cd98190d50068846638fc110e529b23248676a7d3215f4d2b57bf39b837d41195b313db7d2c5732ea200056546ce0280502100fe0daa36fc369eec95ed1cf1611e81fcd5707f48df9a3ab68249522fed2b54f534580bd5c508818a6b49f1745d28bc04ad695e26a2499e2c332e7721dba87d6ba770e42b05589d8a82531e246e9dcdb6a4c845bf57f12fa45bb6c327dccf9aeb6ae2759ea3c42a9c0f4848aa59f107a88b1537586a352d31a55b04781f8574f413a25a73a698fb69bed428392aab1fed2ce83159dd084b68cabbad386e6ed600d8a00513398d750b73a51c37440a7c57719fcc5265b44c2f91cf988e492447aacb7db5df91b01e502841750e763f31fe024e44a78b3eb8ccd52a9a84b0faf8f793e90f455cd2d4b97a008c96d9c624c9dd94248fa02315decfeb60b5d66797f91535855bd56316f4f78658bf152112dbea6e97cdfce98db06e6c73122092c764b16560c8c3ccc7214cbd73866483be5f96143068cbcbb7e0b5e3f0a580711e7a84b81c4097d311b8a4c57572a611818c4c952511b18e198fb24c7a8b118d9d4756360232d0964a5b7ce5b13025d85025b610cfd6803c0c882d919cea655537dabf44042d217930c61940d6c661a24b7f05bb22187c3bea73af3dc68ad66144c1006cfdba72b69472b5cc6c89898b2e58bd18866f0b00ad3a39321c84fe1c2cc49ff37196e4a289fa92e1e6cff725c5569758eb4c58b2111aed5a1960d6d13f09e6a0752ccc9bbded2ff28a253593adb121ac21546505f4c79fb791e8aeb8a541c8dc4f10ffaeec319600b71f4821d7e15f7fac23ee4ab6133dd12673232f0ac272d5d9c73c5e23667b5ef58e90762558dbc3e4ba34081af316a28c18de42f41c50151238acc664014f3cade551b848412d0380fccdeee97e046ea39262f1f0048595b31a7fd36a9be1a4397d077a2d8ebbe0e63b23c8d0be8fdf50d93405d92968d5de3ede1906cff901fc622be5790c61c866c2f88701f1001144b60a3d3569b904ce32c4b43d3a2ac7da64086e12f5fe66e4303b0d3368df9ba4e0deac4524e73ef75ef0b3d052d705102ddbb89f72be8d28c096def3e439a7eb57996fe60e891adfe241cabf87746ed35ff51326057ea83de78e963cec1c22c887e09d0f2a7754f930e8f83f21aaa758751bbbeba0091913b8d7412ecbf5240e63acf87794ea56632da581ad085c94c6cdf4501e6d2b2f00e334975532c20a21a828f344d8242dc1e7e7b804489df1f3406808de7639be41b5b3ab5646090d3281308f1a427b7b4e56b9cb24d3466cce67f4a8d35e8f7605bd44ed3a451ae93668fe544243a64098ea296acc3d011cf2a570d38257b704f4e8b41a846ca10c7d760a0976cff4a0f19caf93dda4899ff4dd3f6714463ab72b82faa0d02f59bdd71d4927565fdb436a1636d64cc9ffdc0e3904b691ce56d8f3c1165715496aee5b6efdd176aa139593e1311e78006ab9536defcb931d618497c2302e59086f40a46bf07bf36f00f39515face49772d51e0c73b66ecd8449ef9cb9080d3a22f4500aa4415afa6da0a3006c6503a80ba3d3bb40c05367cd8342da2016f1de8ee606aed3d9bd27bea903d126c4833a79e9484f63aaf73d2cbac88f88015fc0ade2b77e28dfe5b1d9719485fa7f6bd9b1042e346c02f48e6bedbccad27d98d50f2656753287398e7f891e814380907abe46df34a2b9c906b1841034ddc8a1d90afecb8e014c4e203f736227e3a6bdacd3024f683079f2c9aeb75829ab7c3b800433f25271e0819f99e60e8b266a51b0bcbb6c7699641a0ec6ea0267c4558c30c8dc8b59b975eefc8cf144634584c89ef14b2b8e97613d936732bad67c2ccb40712b07b84204a4cbac5dcf55334dcab02897dba4550676fea65445d56fc918cbd5d4efb8b3ae42587948ced06bdc4f737ebda43689197627595c415bf645a2732b28fd0889c22c29e2d6cc049206925369e798b14860ba15b0a161e3c2c4203e8c652b49d389f971cf52d165c45de400f1d5cf3eaaa178d2c55276fd149259dc8b4b653f63885f090e8e37561189072b20598b151cfcf59c73af367ae5f9f8defe656dc4d70877778e6c79553726a540f518fa9153e19bb8bb3ec5d282d4687ef435fa2a302b70ede520f40abb9ceb189c1cf9e1b7c4f63ecf1cb1d264e81ebb81d7640f3c8e7e1235fac1947e737cb73d89c99907b73ec8e1b4c541ade351bb097a5d1354a506fd4360c5cc6aee3c5032741020d4c4c51e710d188d455757f53376e9f4d1f29cfd56e50bea20627ed82ebbac9d3f8e9c59fb6574c0b7070cdef78ea1d5e778a1f50956c5638bcd747d9cce539f3a1d2e4a1946bc6fc66489249cb898868d5c1a4144fcfd654aae3c5af29f187b6b01c46a8d63f4dfd2141cee668dec23afb12642b761fc3a32491b20d47ee9b9726dccb5a50efe6ebce8d4ec7342ef4e9bc773e90904b3cc4e73932d5b63d84ebaaca5f1b68387407c714c7fea83cf383cc912a6d4322470ec2ff856a4859ca9398e5bc059b7e4c489df3165e69e08da0c37a79e2dfe12fa6112a6a028f35e54661d85838f2c64625fd3911b5ce5880d4a100d8687f695fcb88cd5a2d0c26724a1100b20caaf9845d291dd3f807f4fcd2b640383b32e601e89615979cd63c390e8669d381a9d19e0b4dfe85d3c33ca67041bb33c3cb20ac02e82cfcf96d1238689b415f34765a71467a03113eb813a6e4173c7deab689b733a44e2d27a6babd939aa6a2472d3cfa43676dde80d54a8dead1d8e11256647313edca08b5852cffefb2d5b0b14b24ea543ac6b9e1c6537fe5549e4f018e0d957601db86c98779490bdd83bbe576e9ae41d79f53bffd1db1173dfe023d40cdf740fa879c4a5a650aee8a53aae39d5fe846a2bfe5879fcb0431c85dcb1d1eb31a14b02e8983d775a25758d0a5ea8b220c0ead116109e9d77391b6583a693b7b9851e9f7cdd31f109cd4d7f390f17c77a575034623fdf92141aaff49412cec96fa442885bab66941f06543eb8e7bfe76d844eef56dbff7aa70df48bc8e302b45db69bcddd2eb63432fded237260211c2c20cddbed4df85b69b582653468ec54b956ad6bc0abcd1d3b188d36fbc9e6ffc9dac3f56f8ebbdf5ae40f991e799dd16444088b4fcbab1cf52e5cb551da2e29d5bd26bb10427aaaa88b5584b21d5b167b6ed58dff1ea24faf667c823fc28f0e8a2027ab0ad90950e1a500d5013a5e6df8dbae0b3614a0a3c31f26ab00252847c92240c6e0eb5ee064476e24f4deef24c765fed952bc5add477e9dc88aa5a0f7eaa391fcd6157ba5ee0fdf6bfe2039da0a04d155d8adeef79a32a2d084fccc9484d899c9ad6475069f87754bc89ca49f1dea3ab90d766ef184bdbd4d9607db48dfa6659c2ac03bdc02dcc2fcc868b1aeefc3117764a8b73a931d4d69a4a320b9057f51d35feb80f0349adf49f6fffcbc3ee5ce21537e0c4c98558b03997e8dba8a7584e5731f69ff00a7e13aac68a290989dcd52e4ff32567ce7e2542743ba284081e2657239e0d08e9c55053b74b5572795e122fc292bcfac9072345a5cc2b9346690ec079f9e3278e8d99b93236f5e35d64b701b713472b2d7253581ddfb74b55e9099187cc4a586d7f35bcc21dc7a72c447d6f1260ee8587620cf166a52f1ef09c21d6627d06832d246fa40e9f38d165ed9f94155a0e8c6af3bfd2708c1fac394199e72bdaae4d050d18d0474ee6dd3d0eb7be6b9dbba82b81a1ecba6c6c6fc9beee68a828ab4dc52f11ebf42bdd77724f80b46cc9f382f5e1f172982d56b0d3501b2a04f5e5b8b81e2db97a9da79fd78c423e11230e162eb51af62482c8eff405f6644254fb9dc51658a361962819522e054b9bb11125bbb509d554ef521ae2cc2abb35242a084dac3b8fd14d2e1d860cfff3436afe10fce5a256b47810a598598a9d67a4a11f19fdae390c4cc520c3a0fa8dc0b61ccdcd4c6cc8bf1691b8fa73f3cbafb09329c1a4285baa3e1c969eae345f5a560dab5a4f2a91af7d460cf55657b6c9a6554e75531203eb6a8d065c5fd9b3a22c58df972abfe0d7f87a33762841a91ea267316758928bb30e12382e18df049d076938b3c633b111278ca61a9cb6349fc211dcd341fe82fcabe4ae27e5abb80c08be23e5bd460fa7ab241821611a5e19ea4c992df1d378fdb118533fd6edf136f7d586b27a25ab8d059cf20b147eb397d958e73350469b8810e539111330cadd158b5a40c6fbf54727ce44b9e10c05bd650dd14bf3af5fc61cda32cc7c12c2f735d7b9a6c32431ad4ea4bb9649dbe68af44d9c6220c1537a62937a76a33565d3720447c06b30d5ec4d3ed857cb0b4b0c935391834c912e38771ffdb861fa686aa408e171cffdf973a0a11901a7b0fc39f2e727a52bc728b198e278b6ed91fea1411a77b98aaebd46d87d3b94c1f858ff14bff68863cfdf53b6b014a39603f9b3875f39def0f1d37d7de17a2141f88108949b0a2133966673160029ff7a70c0e78c119147a59b0790d7c8ff1c8a2298080f8ad0379dd98c33011cd9fa039f5d792229c18af75494a0fee14bd4f3f5e36a53aacc4020ed36ad8e0e56d58cf5667d1813b06f99333d25f550113ba2f5ca78a724cd89479299c441c6df8285688c68fcdb41b1813b2175ae99d0145d8c63fe10322faea2d99e934a65886207e75eaf5c2b3768c03faf5c7885e365629073621fa91f3b758fd964fb090abc70b33da092df723918e408de31007e1138d5bb45390328ea771535e1d6311bb0b513fc59724ff6e2466addc5e415eb74d4e4f370347e15cfa17ae39ed9bbe276c48c63d826a440d3690dcda85bcc48b3ab49545921c73352784e2af41baa6347c98e75aabc2223e47cda24dfa0fa45f11927f50084d719e5685cd98cb9d83ef34e6bbfe53df88163b5fa8f7fb2bc64ae54c220cef46927198e2595465718a547536b7dc42ebcd4c590ce6744b2f42ebc0209f4a8eef68745df136cc049a6a9869f718fbc212740c90055a33d4ef92eedafbbadca46e7e34deb80b366cd9bd742664a80cf2ade77fd354375981c71b8ac466b539c72c870e2674c23dfff1ea9062c33bc543e4b9b3cd813d1f1aa33c38bde07bafab38482b427c4bb19160ca0b77d1ab8fe3613f3e12809130cbed578e40a9ecd31244d88db153e56b891e6e5df125ddbe8d9523c1f19a2888057d59ec0ffdd2b9e54298e2d732b69c51b6bfa9e5240a69d080dfb21a70cabc1a1b5b403472b1efa00577e1ed0e8114ef1db7df03fa6580855dedf0f7212b0e443d28f52d3c7dbce74c3136f5afe31f931b43174300d58a2024a7ab7e659bbf984313ac26ecf692e7da84dc8d367ae0855da550749ac7ceb9ded41849e304df60bcc466198e5bb71a93938d45d8a4b09f8b2547f04e73aad4c5e4aeab7e3c0c11e4d1ef2b719044e06bb25fdee40d515ff5202a1bfb2d8a34af0c51ddffee5eebe40b589fc4e5c6599610b099e90436a99b541b74d471b3f2c34845310d662fce2433c8df5cb83cbe875127ebde7c797dfadb7de12a11219473a34d0c5d330b73e5d18691acad85123f77a56531f23cb4c7cf0a3a0795c2b96c7fca1dace54f690b331034ddd06c3ac6133afb47217294707e1b01a7a0dbfd1a343fd782fe2634756327441d6b70652b62b0b158ab56fb43fa64b5b982f0cab9685dc7de0175a4d7fd14e124d0eb51351f6a27c4fa65fa4cc653d80067743810e102ed23c9ab323920d22d5e85d5812176a6130637fdfb7d714a5d96988efa27a2059c05f37cee4f119abaff1a3ce6270d3dfbe039a85ab452f7ec62e86dc4aa308ff2c393002a98c43971b920b4ae5f5f5224adb078feb99d57a6bb32234ec900ffae21012859e4a420206979219af0dc3d5c2180b16e75abcfeef5d6f2d8a28bbeb0a9cab437e42c78be630e079a4fac7001ce3c0226f7cd85bc6129f033146898e82795b87c3431615249ec2519600f6697d3cce1e02a68a69e233abfa447a2dcd97fe4ae997c714baa70c01fa7921565acf64251765e187a2a8b9d3a72995a5c3974c4b3e53659ef6ef100fbdc6d49f66ebb0d30808536e738db5229d08f1fa6319f4684c919d1bec275d350bcb2dadd2135054ebe6e4469c3335f16f13cc7c9e3290a3407f68df10bbd2a6bb1ed6bf40e0fddfb0c5626939666a7a3df7a4d71c70c4dbe400441c585cfae758f7589ee67c61a0d632b640b29cd59f002aba74cbf93a518c7d7eccce23cd208fe8d722603e1d50a63bf19390b960f69dc246bdf227b0dc53594ddc1d5e8306f120e8567095c7999b3e6d764e208fbf88a1ee9a2b71014de0670ab76ee42dfe2e5941958332e877bdba37db5c099e8d6c3ed513de641c5ee82346ff284740f286325cd75a778dafb72ac8112f33833c8b76c78c3178a3bcaf3d30f78e372f09e190a172595a9e4d9099f70f02f14dcdd41e85fd5cd5ef12964ca83644a01a6840b37c55ac09d61471f815c60137001ee2cdb3047e7b5daaef72421aa9f0cc22b6c0e8356b28f04db5c374b3b66ad6649be199fca1c8715703e8a91136de420674ccfc517339c51451c234adbdaf867481960d96983c8d2137f894f197e45e28a2cbc1ed06b0d094d3e1b87b606ff8cfc357f2844c5f233bf5798f7f773004217d328d38ec34bfdfd3a187cfdcecfb7ed96b8bc0bf558f7b4b4cc47f559b3418a64bac3e8c2dac20d3ddee752d19895c6693cc1c3999e57dad3b3b59e1b2b85e450d8f301f0496efe0f1733232627de0c395611fe00cd9f8455f3ccb7654cc845fa06b3d68c5a9149af2860","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
