<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8459d754dc35a4d398b6cf9ff98d6c2b637a8349b38b515efa7ee3b0c3248ab3993f0fb19eb407c84b563def3d2c6eba1b250dc5b96944490aaee91c83026a65b8e61271f5d808ee24edc5cb9558bf60a1537cce58dbda0786fcdba7d6d69a3a0df4f6b44baa358815053faea2c93503a20e298de06674224274bdb08ea413d89ddea0784e03b4ff8b3f5f9099985620692262d6b8a0c77d8f93a0c5c41c4125b8da619eb572f63447607ee80c428c746fb3fc631711da1c630620ab29dc9b24e1b51c3aa7158243c2ec8f49bf209fa6881c5007dafa01c894d369a573bf879b42dd756c53aa199374b9a9bc5a0b89702b294099da4a3130cccd4ce499ce04b0ac4292f0dd6e9b3e036def5c3db3ac65d3217822902c7eab325474194587b6f5e305626a9b01cc7126a0261cfceb2d1f3243b97b1120ff56c700af6854ff5801b1bbd16343effc851ba660e76115a9ea31a9f47bc577a128d5519bfdb474bb05033237277392c0191548c54a11cbaff920b44296b1b2d36a808c6b3d36e98618e2b0309f110d28b9240fcd1035ce899b7c398ae1c8423ae942192f90f4f7187565a8e9fe0a86307937271dbef0c933eb369b176b1cf14f7773eab5b779ed6ff29783752c550a65d4748f5d00e23ab907e37b94a6ea210be9749adaf4741f5ca2800abcde30a5ca060e048271a1ffac6532bc315366e817101844bd9432e8b775860b3ab8d089541707ae31a2c794ed5986be0155b1d010927799219ef5ef1efa1530122e1331f6f9573aeeafc751f033e8dbee63e97fe74dc05166f6a33903e805ec6617adfd59ae94c1c4d3906f76b6d5d964e8f5e94ad243065b84f003913b265cb0cd4d2648d3743c9d60e1219fd7929cd79754e3f29b2899c3ea10b3bc92957516b01e9020362b7192d7a668f5d3dc6047d1413110a0f82ec3e540ddb65ffc83a6137762551c6730ba9cef2761d418df077215ab74991e57f015f4615b71764e9720964851c97ca2db0678355c8a1b3b92315cbd95fd1a0efe73cda740ee8c8d69c052493c5f0b96052019c47031ab808970506e64e64cd77ff4223bd4eb886d7a7bbd94d054101a5d29c60e21f1d446cd71a5c3f259eb5f18bf5e90d37d79045bda92048f3bb6c0d2088b3ee3d12bf5dec48705292fa51ca366308e6c6ce7f19852d7df279d9b4fc5247e945daba1920ccc230fbe286b0aea8b001e7c99b7d5260d1645bf57af58ee0f216cb0c4b7df7330ff4d6be187b652a5e160198baee305e4b8ba637dc33f5572f99c35a9fdfc04438833ae28d5e9887fcbd88255137bd5aa3ebbe36d56ae35c3bb36f3108519485df5cd093f86d31f1df96d934d766e855b184c8ab30b29613176e7ec87d13c2619ee0580e675d0ad6184d09b4d52be767a5abe0324ec225d0f59d480bc4fda15272af9b8df8d88f59f1aa51d495a5d9a2ff037b38dde20869f5c50112e7d9e1c639a0a7ffd43c6e8f61d89843218adb6be0db6b227680c0ccfc7631731047133d833e65cea7202367e51d2d3e639e3dec1aeff87de134de27101995f24221f245e1b989ede2f6618d44f425a81f9fd362fa29559278801a4af236bdcf6737b27c279dca71905473911de715fd7535e0d723a3ae147289130a87199f424b79512569660664a7e6d517f39d3575db31305899b2913cd985b556582171ee65bcee937274496bc3cf903fb730df17c4b9edc4dba4d6959a695fac541cb12b59c85552d8221eade8b51b4f7586abed7ca7a181f7fcd4be6e5c053455a9e9a449bff8b590f8c99e43f285f1b3d5fe2ef1cef4d399df620684e12e532a3105304b4583f804bd8860cd38133f216d88457bf44ca750eb76315957980b613c22fce0ee42d77c09dcf85b0d1e78ec0fbcdcdf88f49b4c5f598f3d1a36be6fbb92701d3bcc181386fd7dd7e66ce73a45fe265283733bc982a43bcaed771799365b00dedcb50bc55cc511cf01d2d9bc97898189ae8af9ba4421786df8cb562cb609e1abca8d4175d4fb330e3e7f74f53ad70817dbda466f4feb096339a3b3a97a7e04400bb02277de80ac52c9469e8aa185526da70b2ec7fc462647896cd2a163f4b09c1af3c6eb3af01a62e78cf358b203d41ed86bd25e7f65d62df17eaad1409807c6bf7182d08edba32464daa3acbb99ce4f723e18502057c941aaa542982289b8fceafb23b2bd17bc47fe65cfeb6f8da67e98b9c63c408b82ebf8965786947e36ec69aaa9869a4988cdaa2e482e073a88299117b3d3f5720a31cc7ee16a7fa8f39bcb5f9d385f6712962a67965d51ed2c8caeed180750ea55f164081dfb98f56fc31f0724f52464256ac8dffe37e655fa3d6fd1e98348d6b59e8901fef64893ce19fcd80663a2cb7a62c7a97a3c4cf0c9c7d037e67e88eac38c005015e3f3e614ebb517240137be708a1ef30f80257495f903b62c8f5dc2bbb51a8d518a125f575af55cef216f4424af5846c444bcddd2f6d9a8994dc10a56989b6a77f6e755d5c6d51c87e99a0b2da680f9d2ecc2f5cb71a8dd1f4b2511699ceba381d2e2ed6b4dd6e58086f8a95126c18db157c066d6260fbf522b775e58cabcde5c1f305d003edc35a30faffba0ed849d96fdc6fec8e4fbc7bf7a89a2d0c8469fb9987be4b963f67e962efcda052fc01809343a3b5619ff9b3f0c961f7249d12dd038f49f2563565783ed69f10be5efd7cc2bf8a918b3fcdd1399a4fdeab933b5f32011a1c19b061c6f90601d8053a3e6b3506449175742ed78c3997a685611cf5ed2214f119ab3244de2a06b705f45139ff636e316256b3d8641a36f69aa4551c954e2a87a35ade9ab2ca99bede4f4781da5d8a58a7eb7f37f7ea901573be4e72b15fa83796461a781db28b26d142a7d4dce0895cbde3d2bed253cebd404d5746c780f575068a5a90cb39d8f7c89d8864a6e726f5b9a3180a68dac2d41242e6af57904562f46ebef43b0beabff66471d4ad861eab2aa96364e159e37b087362036e8f9d910e5d37e69ab5e4708cf633dc6ac347c6020d1cffaf39eb4c13cff9d1ab59e8b308d39ac4e33c2e780c9e75e7c913d90a54efe050487a5196a82021d4bedadb345e5b5b21c59dd832987423bf58d27ee2dc8ac24ea391d905347aa88d5738a71a408c92e828793313d9e49a52b4ca752657b8542a813a3020478a23eecbed2461770b8f2c9210d7fd064f04efd3533d473f62d651987d18a73c3c74e53e551c9b07a43a5c95b15d03f8fe4a1c0891b6b986f74dd6c004bba52972eca1366e5416e88ffc8b1daa7ae57caeefa8745cc12fbe1a4bc1aa1a94004977d3eea7f0b5e7f8ff144740f59d660de89f6e9e9014c23699dd508212cd1f4bf99f1db4bd19b33da5ffd5e5d5c9a37dcf21c3e4f8da33028fa34d861384f3e2f9a3e03e8f6541ddec9501b555fbd8fdafa11bb83eb43341e54f2c6f340f279843ae39fd5930406fd825d469f0e5fa624e6bb05b43ecc3a8d6b7487f60166f699f00fbf2d03c7dba1307b3b6bd53f6c97f236395e836ae66eba2c3ea55ee74e0b727d4abaa96e2b0a98c6e3cd377f56cd986d2af4e1f489929334a0b0b872733705e38a225faf9aa6bc68314413b480e90bced38726a99dfe11695c52b54b3dfc893929696085a81d9994c21614e276ac1f4ca9194e5cf36068f18691388a2a7c02b9abc91e30dd0af7cf66b26d5f6f76a939384cd8b80d0e7f6133667ab6d5705fb0b1cb4e598d7b2cb95f76db888e126a893f801b3fa9eb7a556932dcf2c4e627cc71acb7b04d92fb722ce5f80d6ae73bfb47930320d60a221711b164f7a260cd7964e3bb5fbf9851bf5270ec732cefbbd259ea3bee24beda6b6fa4a8a604a4099a9f8bd3492bc1d0a8aaf90e103275bd9c2265f423ebd912e120d2ec93d28c2997bc4eb95343330a4faf6c5c603794b3abe16a6cc2a5759400f71b3e504f64cf2e97faf37898f7a1419513ca449c22cfe3b248bf2aad9180e426e45a05d59fc9c2aa24993b96425aeb3dca237f045ae91c8ddf3fcc6ad2f18e1805fb920bf1fbba8093417f5c83b43a05d01b4024b9840a81c287df290ea252b7bb4db8264d2212a6a4518f0feb3c486eecd84beeebf7a813caf3ef415908f1da6e412f6be484808b3329896228f21dc6c717ae88bff4d41fa8e88ee7358dc32ff8dc571a0ed0c9a30bc50e5a2a6bb0b658964f3591c75f384a513a7256348873bd74e06c62850e0691252e17de904e8e7e7cbe8d9067ec4d46230c4f51aa1b92f9d7886e1c41139e8d94fb6404defe1ee5955c9fe9c410f73bba7038340c260df943f3be9038803ff75ce25eecb04e1909f48b8a7ab0982f141226799a374e51bc8cd6879d0cedd96a32302fdf0442ef4fb77cfec2dfdf8451acaf6e6bb6e5cfb895b9b2279c0d74609d7dfbd52a8ed60f3fe22e78481882a22fd243abb13d447cdd26e924e20fe6d13ae1771b3e67fc5126d132885c58c7a5339240b182be87713343fd8fc9dd30e78fc02436d4f248725c43fea381ada062681b4bd5c06c4c7d9934f9cc2731a43fdbf63efd778bab45780bf1947a7ef60480fdcf730e195956c65e505a133aaf97edf3d7e50ef9d7bdf98e0c757b730d47ca415300e0dc3a42683b2544a821f267fea7665d054096b89f442ebfa723f8dd27e8f92cc2cd179a42fbefb522e267d8b0a20ebaf8cbc4d42ada5f74d2be4a0eea4734c37cd101604668ec67df068655f64a5cd6705edab65f6c8e14a435f58fe4ff2ac911334d73cf4b12e98e5f02e97d9c31b7d89216a8e00cfb6f68bb32dcb98c03162f3cb60c98bd5598fc1a67726d4769335ed03ac7635d92fc3a03297cad7a17d7402a8df7eae40f05ce07c6df311073d4510b2c1f089731347d029580f6a6e0c0b3458f8254025b839bfeed2e004179b6af7061303822e7a96b2bb7de5d3644b0178df34fbd4e62b3e7fbb1b8611db97733e26ffdb6974e2b3d94e5da0e0c94bf0dbc8da81ebbaeaceb81262db8c534824e0518e6aef51a44d4c961a111b11d9bc9904255e4fcf741830729a813ba7a8eb0a837c157dff436dea78658884fdf8b023ab386ba5b92e4cd88af80b05a2504797f53cf804e11a4fe314dddf9b776e4ca30332efde55971d71758b01723ef698925e5b15b9afb1ab89286cac87bdf74e2e7e2b58af367c285893a32c72909dfc0821db483f47d0cbd6baf7a47c0a6194bc1adc0e85ebb4ddfa5d38e0b6c9b48ffef821cf4b5a8545c6221661a4984008367ae7458259e18604236c2b9f1be708afeadb28a3ce8f8143c1fc37448f8982479967ec9c532c8fa3f43bdeeced0e2589f9fbc3bb6397aad6a5cb65cb9b5f89ddf7cc13f627dd11e5db3a5be2a5c2f3c4b74b5172a05c51fc050e8257a3febafa41f3ca513ee0d767dc645dde39e926a3d3d61ee95ed5c7dddabe492f798a30d80f6cd08f7bd756c9c17233b127543be97bb1d2b2c1d469119844423c35a3f45b5605b7819ce037aecf69437ece8827a2701ce2e9578a24edb2b072f89f4e2dea7308ee527c6c172e27973317358145d69663dcb4b88fd4bcb257de672db3421d387a11d47aa9c2f5aaaff19befe2603edf5efcb634523cdc62d0c9549cea7f0af0496eba586ddb0cdbb71d4e0fcbd09880258574ea8a4a47278a7d51ec7eade10500503495a9e9baa14df6561dace1a2d1c735f02f59a769313daa363f7051a846fc8b1c04ec2e31e1996ff300fb8e7c766d2479e97c68411d87fcaa97d6a7890a6a281b619fa537c2948cd56d7cc1aeff036c646c8373470e8ff8de03bffd994b223864822f73e847eff8e2c987631dd0242cbe01b61ba4dfd8b518781bd7490fe232489a8f83d531838d15d8ecad81ebc06df420fdd733b08d9d85e6f2ea3d4a3a635edd91cbf9f89750cccd5dff2714f8af625a3c12a3daf7a6b6a93ae5d052e29467a46b076bf4b1d0522ea96f4ad92da4d4e3522f45ec5fd5cff951fb9163e73c3cac9e297d74ac3d14180722aff6df536411624db73e6250020dacb85d0f3230f6269a90c89895ef79690b23bdfe9b8e07ea339e698e61b0191d42904abcb8190087627b40f4289f10018bfe424cd8332dfcc2bef39bdd5ade54170bb04b838957e165c83ef33f6145a8750b6c3afa98d95a1f64b6b90ceef2d234c91a2325e50431ca9d9ad547699e424cf68c135d28b76f5b539c4c480e24c5be590ef77af52e488339b3c4cf08a05b598d1ad403961a8b5f354cb04c995770e2da969c70381f1dc41c8a39a9029268433c324dd1cbfdb02c095691d0845790673ce9aec97090d6d6b651dbd374dff28d1bee37fbca0da7890f824c847c2dfd30d2ce85cb4bfe81deb9fe686d854262909741a80f187044e4cb2b0b2fa746d354e7e6a9dec7fc59440b9aeeea72df17cc25da8bd2bd55bbef63cd95bf0b4faf606702f43f3145695caebbdd3a9ec750c133ca27bcd9ac055ffa919affbc2b7730bfcebe4b2ea4c51e4e54268fd0650139243c749c47773d8142c2b08792cf8c010fc1aa1823a199bc2b88e2598dc39de491762bbb0a125fd5ad1c41a95d16622282404291c716e84b87bc3bcd7c0841fdcf76162e78fe8e9c16628441a415b916221cf085665b1513d72fcdd6005bb96daf3f391e3b95de536bac442fe423eea63260eef6aa39430be40b74cce7f64476192bdde6719b59d8c9537757f88b16990edc6c1014a55e0e03be709cdc28974c7bae0d25be725cd31a3ae5a377e782ebe375c184d93b8fd5a9aae0a30ba2f6d622d8047d01ef112ab1a62943a4f443067b9335619f7c9b2e83a2dc304e3861f534c1606851dbd16f9386f839c882889cb4efbc5ab07a558fa351c31d2614b4b3b02088df0677eb0413baaea23d070506c86a3db9507c58a8be45236a33179a5980469b3724839a004e995a7a39aa1b6d56460033904b7fee9d06ab6e07503b7363b17bb27f5cab6ab3d2220599673df2f04422650ccc1cf2ad1010f3f6a90c67beec920553e17ed85d0c49a3debcc1fd3ac303d66ddce3ed0d243f744803a111369ebfdf1dc64a030a6ead6e752ab6cd5878d426391fce6960d6ee853c2e29b1830e382bf4b58dc0cb82dd6c3b7b9ad9278344ddc6db96b68b261951ae314285faaacbdb0d124aef1345daf5e917dea52081c1b22b4ed4ccfbdbb96b1a5399ae1e36a741e004e332f54cfce72ab156b08d6f62ed0e7de03085460360e3cf016ff1467b88729499c66fc6198725a34898df8d419c50d0bc0ec2e8c52ecf947f7bd777945d7c86e4e373d592919e8ed54693b928bc98db1aa20df1aac63cbc69b8c136fa5cfdab67bee6e7b13dd614f46cb4c0e87dc4752bb20bb26fc4de3bb6dca36d04935db485e99b0af135c3b90403acc3f1cd7212a4fe5bcd99e55a7868faf719aa95f7d4c2385518269bbdb4a7b5d2aa4aa3da0942c4e671509dac3b6869d213d8d2e9030db3b44605c7af00cf68b78ecbf5433d3f82e978520d07cea86694001e3fc7767d7ef0225f326123cc1750c0462bbb0e6a7e5f71f20618d08c1ba7ffb8d1f2f6349b3bb3c07d3768ef88d0dc65f0ca47339d5ddc54d3e86fedd9ec6a18005a34b7c704850cfafb28369075c0290fbc7ae6b93d8b78bc9a0e03561bb4b12047145ca54d748cf498b6c674bd54f13c7699d3a32d0c189b6b4a0b565d8080c3424417c96a957bde823e177ad69cbb1f5184eb3dec6bd33878caf3154d4760f0e971980130cb842d4be96d47a8918f8261e666f7b9e52cb8385c68ea97d95cdc84ecacd53fd55b055b9975b3906d6d92e33dcd6d4550789d6ef8da81583b6855bbe0ac3572f440adcbdc5cebf108a8b65e8d38e48a5ff49c0cb60b5d5e2840247a1939ce2821977c247a766ff2741e55655f91c63ae96a3cd8226b58b9f6db95ad8e3acc49a1055ccb42d993781ab411109f043391d49729af244f3306ee80841a3fe3be06c6169c1673d5ed8875bc6b21abe5fb78dc39c096cc8dc35351f13f7a67d3d1d0062f2e012805daabec8f01e00aa533e28b69b2e41d0b5821257a1d0b0b13d71d8af33889d674d83050fccd7860d167c8341d9392f08499a446ba447b4109988883431b69acc51c6195b79df9f0fc30e156310e8278eee65314906f5718c387679892e326229696de502226f1f55e764b76f3512a5c7db031907bc97ec9dbbde82f8caa62b98fcfae1f62d7bf627cebbdb1876e3107718f99d8661380a30075abbc4944ab59ccaa9ab141ad05429f7b9eebcd6bc5d6fdfbf753fda0d653a74fbf624b545dc703734d3f14511b3a4815ae23560fab1b39798f3c4542983b0eb7865b8811b176d436d246cba1e6a9a17f327f5d2b79e2df4947bad6877187c65eb044a0b55fadbef225ee8e3a51a3ea934d96c8ede1c5b0513b7b8182154b525bfe865c48c0ed60682aa14fb8024372e1954dea85f53d50c58f428f1052f3614bb23c3b4fa45d25e8ec216cc32b2e261d4744f9caa81b87955ecd9620531e2a07eb3cdcfe16b63cd826425324a78784473b296665c51015a34bb3420e657fa7519f110d44dd9beb2f9609f919bfa32a089a8ae5f221b0b7567296ea2e76de0f7e9210531ba3f1a4fdc75d7c409141c1ad4e3239379e492455ad258fc497095e5ba7841db931116c250975d352ada27c8185ef905a17109e011a196633d3e04ade8a76e5905e4445e9ef980fcff5671af2997a4e3d4f04bfca8ffa13bf734bd2880ad3884557602e8b70a59a3e076c51ce2cdb145783ccd2995a00cb4ee50a7bd507a09feab28f24cce7db6f56af92cbb4e320da1088b2d7d8261058b4a26ca8b1c95d79a8dc5799cf796a68c2b41228e76d33a69498e9fc7d607606001c887e9d5a502d490e1baab665006399b1ed1fd5927dc9949204420faf7289ef4cd842906b1e4432ae87dd4a796a2403ba6dea2f88a88b5464c191a5a9d6e512ba7a41f61847b906545e968b8e5ed66cc90a83d9585bb508f06bc774c18cb12353dcb5352efdb26a6eb11bdc9309d3838dec5f5644373040629ecf1f1087150647afd917755f1d7b42553bb50468ef471dfb2aa78203b360acbd7e92904e27035fa2d95190ba60ec63b94382935f6d94e81ed06a45b2891a720c0187aca6678cc0237cf33d24a3a8ed638b9a8094d008c1bae24ea6a8091d933935ad52d2f2be3477933a72d58340b74bc1052bd2259f2ee4b81fd6415ac9b7d0135e76f4ef5e4797a2a84a71dd7d46900e9f74082136852a5f3dd4f02d0c667fcdb7c14bb69ea45a9cee19120a949a4078969acea2fa0d23c10a6f09243b1ed2f33092f8eda4157205824d99146a6c9f63460aa306fe0c8dd15b982393b92b818dae7516a4f14bcb54ca0706702cc8e0d8535d30af568d70e3d905ae65abbe7663a12302b5a73afa038fb13f16ac7340be2f409af13a66aba11987b7edd951d020dedfe268740ca69220474a55d348701bbec8c3e563a7958670630110c2d428c01168b872bf639201cf4e2ee3412433393458e12523d6d391f093dcf04e8bd660f2168bec11c5264d9efac53dbbb5be37701c23da7a501071e94f40d2e652836067385cf84d025bba5218df6746e1ff76da297c4f23b309c01f59fdb8a290d6d85e278ee6332fcd1bd17dd066be47aa9191f57486edf00341fcb16f9c835ab9851ad2044059e6d43faab2b1766fa89d69b7ccc43edbe9c6f9d956bcf73108af54950a2bf9aba7d9f360c5c4e3eea03a0caf01a19aedd298ed5f36985aad80119b6e57e49214f214a22d4ad8f571eb1a9e19b0338c938930e0240743340acb56689e2943b57e9061278e61c0b3104e14ae1e9f06b5b9c6a91f9104d8ec8bd7b4924ff50f171e21ca15efba583106ffc95c82b842abf705cfe0a80be3c6d2153bbf59cbab19d9c4cb45b04cc3b41763311b95a2b613c74605ea78b4f3d63456303ac77ee60acd93dcca4658aa8469d8f5c418c862589025afd966e3c750a50b91aa119b2bdc759921cd29b2f59bf5318a50c200a67e823c7770a6d83cde484047bdcc34235e1cf9176e292dfcb67e4363ce6bdeebdd892b380b41e0dee31905e8258063adaf02e3b71060f9cf461794ae26fcbf8e81eeff86b95eb4a7d7676fd867b805467ea9c3a2f2b471e280f5578617f4f910eacb1e9336cf9d62dd28a8cbd35743e11034cf9dc155dd582423c465b4f3529d9385f99a8df967a898370908f4ced9eab5dac06391b9805fb40f32f5c9d92b96b50dffaecc06803c8a2ad1a760c7cd10d36ede37c18fccf4c38a089f435e80816896c9e481a6a48fb65dc39e948affc690eeedf511fa20b8913e56919c7f75413380556bebf2f7bf672f77094736fa4a0ca1dbbc8750b0b78e30201df0e2f81feb50b0a702faa3610532faa1884b6b1a92b95140f1f12b0a05106628c3804eea408e7a520b33863eee38068f4c3f73ed0d8eb42f55f6346a4fbd341accdc7e1de4fafb0f6f65bff46e05f80576a45f7aa28b59c6e350e65ef185d362d3e6b0f4e8793f6ba4edeb55d86aad77a3187b1e01a2e552a950362a87379413a767a364dac8bce9560619bce2ecbb889c44b9a395ff4d1e5a370fd554e29b16a1e7d22fa7a33162345e04e63c444eae3b4818da68e24aeb51e2a811c9af076f01015fc4aeebe642bf7ba2c2f0799071f097bbfbcf810b124d2ebb2caddf55e91364c807576a18bbb9a9a641ffda863bc8553d3321eb384f7ba023fdcb42c3535c21f0eb0f274169aae1bbb062dbc29bf39f65cf582c9e37d98fa8774694479ae92d51ca30c50695b7f09cbc45aac8f5e044cf2af52f141cb4aeadd9a2730e6cf13a6e037e9afe37847bc6e52795a69862d490d6d568256402de53521495159b5bb1d2f5359ff45f25a4b6c1cf8929d947a774f5d7c4707f45410eba500a028cddec028511d69488931291948d5b84cddd74141e59cb6952da9ff0bc7d3aba0be908ee9813c892da4203bac49c5c7a700f86bd19c85cd427d60a4755e2e75318d992ff458c4412ef9a3f40c60c74674dcdf65336c5b8c738cecd918ad4db119cdd3cb3b460c3172f3f05529c6949b6eef9b3b8f45157b9a49972990d25fe0431b89116563930e3d816b6e197e5249bcb27e30d3875d2d3aaf21b6a79adda7a9cb94fcf772b02dbf59280bfc5a968ebedefe218a6eba3f9f606af7cf5730938e3a5b5b7cf874612adac2685b3690149dd252a002adc755e5936a651e824ecb4bc3befa0b2c1bdde8af4d30e4c3620dcdcbca0d23db58aa8d92edab0c1f7eed0606d5789a2c7d64f17f64a73c050ae54fdf4311dec00fae12b5516a730b7a344e8afd9a2785eb9864da6681abdf7e18a9993c0a57d5aea47a360d2f35a27cac6ca8d86e1eaf41f49e38e984504374c6c1af41ed6cefe1bfb733fd066a598d44639637e02b4b7a6e24cca2ebc65e16bc6fbed4c096efb8206d48dc057dfeba7364b0dec6a9325a5448190cb10fd9ac2f29583970e86bd6f7b4ad0120884dfd17bd0df13820db1924dbb7a25a7b53f87ac9ce9306181860ddcdc74701cc324556dde15865363081e3cd6e1faff0fb5edd9f9698fe41dac7d561f9a17320db7abfb64d9c61fe49c77bbaeeaebcf2ef31a6d8e4a2d7199d54b3ecad977a1262231d514e885c899fad18de0f6f45a818205f8253ffa4d763638b6a6f5a0525fdce15a8e891615a732f83084b7f36e71c2c49cdfd5031ec74fc46e5313b18fa9eb14ede504dbee692f2d3281628bee35f8849d212e9fe7eb09ae0b0cfc41a7304dad78f79297a3e377292482c9351b9a0f37482cdc711349b01c6e6ab34fe281f8b3d9ab56f9f345d3187f15dd8ff90c88c7d46d2bd0c15033be15b7d7d39eceaa810ea053c9df6c17671ae41aaf7ae68bb4a5246eb1467effb7559d724f9a8f9dcc1987636e1e0b813e6fa549bd60aaed4bd465084872e9105a848c3dbafe7cb063c6b3a513fae9aaaff347aa30361d7aa8072fca08868a59a0f69a1650dcc946fc5d06d95cd2d76e4dc13a5df9f469fbffa01e7079d9b19a78eaff71102322d1d6e42e311273e291e7316c2fd746b4f13dc0ec7baf375123a2ebbbe2d144929cccd2fb1446b9c07c944313d1c331f88b5f6715756f810290bb0508dc809af99f58848f171231d5a048f1b70b7b39b580468272a154d19b90002de5b007448de74a3c089fc5d6a376c61c7b1e979348dfc64541e8a099c944bfef03e6ef8f3849057fcacd7e4f4b268fd749b12c9da565b28bbfcfefc1c481431cd3c4559a36a9f2943ddc903a735035c12444286ba484ff9e1281791bef68b4c80453d15495ba163d12f99b98145dcf8be4ebfae1afc4da2575e7ac135bb75dd2f99bef8409c4ece25bd381f24aaad236163f65d06a7fb3ff0c2917886df83402c605efd324cd0e6122aa912445e1a575cf210477a18f1b9fa05d9f17ed4cd122140a911fd147fc52df9b449a2bcc69f7d2d63f9f53e9beada276b20ba0170a5d1716805a4ad7707898010036590b9cc82985a08a7c53974e82ee2634ecc57dbf857d6187964f8616af553871d159dece58539eff86bbcf7697dd34831488d920bf17be2666a633aa94da015d524a205cabb940ae8b1eb4e8a6b060e157ddf481205b7153eaf95539430b9ca6dbf695dbbae37407bf953bfb41a8dc45c2e78882d8780a9fdd3c4735b64148333737f4698e6bd978ca577c1528d1edc908f06f45bffd1be170f539c7eaeef54e9588dbcf0b93227ff9c215ce5aa7d328b2b46eb403b10a0ab9568fb3b8269ddbd82a8a33678d13dcbb2c32979281ef5630d0f281dea0371df331b9f233a4df0253d069ae37d50da285fdd68693d89a05a3d223fc55435d88c44cb3610f9283b13402f9c13f1262e1ca0c4c85996d5392ef969914ced426d2b15d14e8e6d54a98f95c5ec32c1ecf057e6aa6dcd153f610b815887c5933d7b538e4c69395f59d952826236ac9dcc1f7a1f82277c241c6fe6645aaed7ce280c827f492a3cf35b3ed23c3f2deb70abfba7ba0a4c5f8ef7e4a5e33b9ba00595ff38c2e3ec8181ddf988be5944745395412a4bc1e40ab341f8ed6677bd39258ac62b369c8180460aaa88e01e4abe8fdf4823c336c343e21bd05a35e35e4ed0bcd325c87919b5503799a712c2f5402a70122cdab3fab3d32ff4b8a029c723bf87e900e5fe4ae525fe7ded2061a90ca3b847e288eae94df6835b2e52571717093a247a27d1bb77c903dfc060425b1e857ebd054c3aa75150f63afe7f694298fadc688154c3916b93b71e738213244e6dd5f4938264e40726dd3e2fa8a4d9d264ce2ff46f5ee0f9d5940d5cc56016a3ff15190af0bcc84f418ddf820b9ccbab57e1a84b04a9d97ec09cff39fb24e58968fc6a2856dcdf0f70da41fcc89ea2a68a187517f49bd16f5c3edc82f61f1025167fcb1ab7286362b6fa2241b878350afbda246375d69c2629c18806be1d8d35c9444e6ca7cb126c890ea061d0b7a716f3879bdbf2fd8969a26b09c25086128f8534a88aa0a2de041c5acd0849f1087530b0e79d1c1b6d1d585ab1dabbca7ed3af3bf3ecc8d48b665c3f7e3c26b15427bc5ef6c099f9cc522a58ade7e574d1e0a08034382a5085df1372a86dac4231392e6277d0dd3cab4a824d61008e4b389187a27327c9a48f31633e4e5d45ab8264f0a08ab4e2f9f01228cb4baa9b41b89a18ae3985c4a40536aafe8b31758d78da24c6635c5ba9969cc3d981297a4bb3a5a9f5edb1bd2868efd1387142af387664c8b750807e893be649dd2eb7982e4bd304842a6d52e7bb29e352b25851de1698edba40053cbf3f1f200c79b58974d83996ab91162a0227bf57da8c2822ed808fe45af7d394da41ff3eb87fb567199c993745d4951fc6e94f8d3ea45817ab5423bd46f26f777fd5cd83463b3b09cd97048a9332cb9d9b646bdaa43a9b17b82f72a9bd073929fa718e13f028056719185e02d23898853dd1a20db56ab0bf6fc10fef59ec62440d8af5252164fa3fb485c80e7413c065a8a7b7ee2b363d4144cdea7eeffbe92b6bb2f9eb047e8603b40237fc671b6da43a3d4a37e9209015dd417ddabc42a0ea9c116e20e5f359daffc2e28b4c14e7874dd9e0c6d6cedb4ac590b22a3bcb0969751a36ca875b31396829594ad19d360e067f8e45531d94e4e566eec5d18fc030ba210d946c817aa434d02bf440f82eb2216168acaf60973cf1cad91b857ad93dfeec66f6afa757cf099eaf49b2d42ad423a1bb0143c0a878b17fef21ac1e6bf98d898db0392cbf93ef9ed4c362d35f7e27dc60e14879e243361c6474fec948ca3ffeeb0c8686412f76b8563f6496346e4b9952f2c206d55cadc1310a296a570db0147e3ea4c74228f9d765ec49a8cdf66e9a96c5d4431892754cab499b41a21fb34a5a3439523d9537d4b3d85c95a7fac14030bfe3b00bced481e1fe2c1155a1c57c6473572c9986b8294478281ca8563a5f0742b1457f5058714bb30f6d6f512136657a93475cbb9c2400d558ee91ea1a411d192a5a5bfde1bd07e836832bc875d8810b6caf6cbb8ee4a6d2c528c79a5cac6cae10d827989a6959933059bb26cac0bc0096c180977e2525f12c968685e49c305f5be144297b2cf2e907b49f7bc683b4680ac1eec56edd1b6472129e1b5132ab4d5f76a53ad8259ae348273926b03b71739a9ea7836262d993038295ad293999df5fe1d19b0295f2f6b5480f2af68fac04bb70437b3ed40577b35ae3def4007305f9a2d82f94f9311679c0f25ddd8d668ad9e42e2f7212a03d5383c6dd190ade8bb9ec4f1bcc135d852c23671afc8f1fb86e82ec22a63275de00a7cadc0e76045942a0f0b12de4147984a307e374d47db0d40736cd64bd93ab4da2a680a10762eba78d2903a59e926a0254a24e4a7b89e08004bd5e5348e3e0233f78bb849af7efed313b9ed740bf0cb63204caf274b592093e48fd0136bf763b49655ec7249c69d48761a99ad0f0c7504f89932cdc85b35a1402a5acc794a241b1ef0085bac9f55df3312770210916a87db12902c6519b41b828cc573f4e7360c106a8bc59ed741c9618bdb824b3994814092eba4caf10ef317f1abf1d5c44cb19af871d07d52ccaf1c8f1d77ff4dabe243b5eaca85064d8d085e32d1c5e95f42c74162590a8312b2e8365595324101371dd7f68a17bffd7eb98564c8e4801bef91c5efb104effb7e3a5bde95dbad570637cf32afcad4f89d918a6a76216cb634ffbef4865fa21b42cd515234e2c5eee01b1aed022c9a06b7a2f6633c98ba630dfdf23c794b61e0511267a6547d84515350f9339f274be3a43232215545ca5555bcd88737d3e872c34eeabf63860a2b81cfaae7b9c1cfc0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
