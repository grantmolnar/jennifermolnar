<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Private preview</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Private preview</p>
                        <p>Enter the preview password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b4f7e75a296f651b0c5e33aa82a5e376ac775454d726dc9a7d1db3ce0b420464d9a8467160e924501577e0987fe460ba9815d4f53ed069b6f1006faef71788a714124c8fabda2072b6030a68a1ee120bde6824ae332492405427961ca136caabc8ae45baf54eca05cc53664b13493a4e60954d85e8024d688b41b86b37911aa4aea2b9fce6e00d869dd0dbfa031617a0d08d73129a84d580a5666ddd61c9bd01cc1c1bd424df47d0d48c1f54d49672c295940bb1e829dad9b7733a95c420e955c8c9f521805b320f97e3b35bddd6814e99fba03e5709859458024d9fd03898708013322dcd1fa493eb11d1e3adc3e126b278a67a8856e8ee404484c6ddbdff618abd0e419c8e9d99e335b56a6d13c857f76fdfffb60316cce3cca902795a392c19c03d77952de0dc9c862b3ece06a9ff7e556978766c0bcd4fcc3473a66b6197c0a91d0d97bfebd9f98814d514973e439774be283f69a147fe721a8aa78aab5bdafc48548fc8b6f14ce86fe08ce4ae520c1cb51c7c9ad831d30e2de87af3cd485c83f42bf5d762f4092398865df1e28861c5d871a0db3f6b9c30415582e96b9ac9b1e2855b05f07cf105aadfe78696ace1e346aa844fc7720d3dc4644f1cfa45352539483d330633f354ed03f51910d6c2d60f348fe94024b3f7529feeb4a12698c071c6aac8e83fcb1608b3a331ca18649f9d69cf67db600e1a70589f5ad1b48837d26cd1ec8b82d94b90bbef01c965405e528eb73f6fbaa5889baf0c21db3b2072ba7013c5987124497d17d28a37e48339ed19c2e44718cd5b9f74adf9ae3cb863c2d505a2ac2a916af13cb46f93e8bee28332549ab1b3af606088478435fd83a3598d6fdb532a45f2620d964a51c282ecf361d5eea32ff0a0c8f80e23989b0fddefaf95aa8fbe3e38088aed9d415eba7aec8f0358a2e256239db679e84f5977fd8643bde67d45de7d2630b6130065a5cb74c18b58270d71f6a90257b2e76f00a6d74fd1136f30db38c2080cba3aa188c30d641c235daa79fe32c31dfd450e6b425291d3bfd8ad45e0e7da3ba6f2eab0511f66e0c5aea290fa6a4c219340781dd95fa068e56c5d5f1006f795f4b01aec6a177706da367b3911002b837b5f52564a854da205254b9aa18e16c9290d1dd557da8e517dcb671a6acac1207ef71169cf5e120bce08bc2ede77677cbd272bc52bd2a8f91a38d6d248ac4af7dbd58f656293560ee026c177decc55d07853e357058eafdbcde8916be8385838d6fe1b212ae8cbd81ae3121f1f0e4388f53ce4b292786901ff87bdcf841e8ca5e1bea029443e358d47dfe07a70ed1dc9df2f32d270c49e2efc9446565914eba0cfc60ec53c45d9bde0e32f01d677cfa3013f49f89307d6497a6c3e0ce88ca047aa87c77fd2aaebb8bb747bfca0dbec455d2e7a7bbaa4ef5afa10e1b9345b54db2132cf29fe30ce5e7e310e824952dd908ddca1ef9823f92e31dd596f71f0a670765c4ec2a05b7619a5570e7a4e6ab83928e8d3cdde9ed1baa6d41da714d540614d782a9c9a9bd0a8a77738777cdd3ced712f54c10c4b79b81943578e021ab481fce383d462a262e97f8e4a0da08aeda60ad54b40d002b22bdd9bea4012aff4e4f0e9240c153cdf0634184a90fa9f997df68d1d76a87e8beadb2d89aa752bca4f0f1aa064e1ca1e51918beb7f6d1e12017ee23a43fc551959d4d11df6a87d407744ab8d510b20e9c088c11f88056bd46592e6c58ea5054d2bad274e83bc59632bef2824bfefb5566857f81162438231dcc19627627a87ca922e3597a592cd26d0c0757541f47fa66088fb5e8063350461155d31553f5fbf81828a045e8eecb0d20e12ffb973baa0f819b5ed91ae7b64267865e8150289b8a3bc14c109c688dede8e48fd162dc80a504c5ee20f6c92a12eed3f4c85c6a6ff47d55819d16ad009882bb91a766c2e6875ca7861e745ecbd6d018313c52ddb35592e6a15d18ca2a74d396dac1908b0e3bad0f940cdff877ba43a0d9b91b6cacd2ee67ba85e6f9860e0f10aa260872e4087acaf2f11ed450b5a7dad75045944a42ab3a6af5a4d0d0482021e96ae11e1a1675a99282c6f3725688cdcdd1ebf1adcb9d9a47600777dbff43481a4f31836ec29dfc1c2865711c74f3c5f11eaca4d5943fb0d9f97258ceff1db502afd34360ee1891d0c21391d3e5145343f0552ddce17577f82bc465122d17f0865b7fb13b54cc7aa8a13f44c03ba6c67bbdbf9358b7cd5c4d7a1c096b39e772401b976409a087f8e454f33c60150135d832862d74ec4eecd90750957f375bd6d50e17db83fd5370902f4f7ddd1f5fbd8c5ea7460a69d9942cd585d7e2701b29ebd15ce3d0b6b785334bbd9332e5e1a2fe5712c970eafec5a9bee09fa170eba1c059f8966851bd85c17b55718d0010e9a6b76796612cd1d787019020c326f4f5ee20e4ce185380b16feae5da5d625cb1392fdba4c54541278a6a057a7d015d7d3d50b0524237ddbd2af8b4d391f7bc4826d4fe25023d18e990a3a0f0e2f2665211b72b00a9bf6ef7089b9bef65fbf6ce16f9e48880d4e7a31c4d44e7f64bff57b78edda17765f55025e6262c3e904aae4cd0d55b1b8657fb84775aa1e954fdfe62297416076daa53c8ff8009c7b37b84becf6c1ef7662f4f6abd158df96983e7013c6630d4f7893b2b6b04d955a45e6f70859d08714de3707134c60da74c8752524a305c23ae8638b01a6391c466302b2b14278deb6c8fe66650ab6de32ee78d9f96a806282ff81565dd69d320b45476becfbb729be99259da31943ec668b0e133f08e87d8b673edcc4513c2f4dc5f2cf7237655bcbfde6421834f8b7ececfcd1632496ce2309677e3b79520461c8bb7c9a7e5ba65957d9045c9f361eb505e78611cfaa5a7ba4542f49a809474535282f1a15d744cf63e5f15059173142b62d86c1cac8498e76e45c4c41fb3aa106763fe520d0118d32d665e5cab30559730ab958133466b31340ea6b1c29fe450cd0538a0cdd7f65362395bd2588e8e8c59df506b93abecae3d95e6e789eb6ae749de5097c25d7e07e50d7f20abfbff97c16e2a3cf5720951c477f053aa5f4a056da6612933fb049f49c2324037320ff95f13a98e6a9155655a69b21c8161b030dfb78c303b7dc4b8337a18182511733d0c0b8744901f7bd763b34d43581e49ae2e6d594e3c6062781d7c8ade274d7ce4f19ecd54be4ac7bc7dd62f158b978274ad16f32fbfeaa2dc043198cde6d0d57e32b72b9b5f28ed127bd0a5075fc625862bc93ef3a5508542286c1c140ea30c8f19ceee30df962eba3b32ea646b3f61311725e9edc79403ba951e3a5d245ca5d46cef9eea1cb287c375aad13e2470aa63fe2ca57d4dd32e3c4ce05df70186190a3b0b6b794cf9fd8eee03d9801232fde87d778027ed0a6b91500b0958a0985061237117f08726446904b1ce9c194ea6c4f31b36db5f08e9ecf0429e240b40070f7b155c18c59ba3b7289b60371bc64245284bcb6d42fa315c176c7739e1f8a549dda054a81e6f82715fe4608eb99f0db26d6b831411b5ca6e9798d050fdbfe5ecca1efe16b1326f1dd160e1a6b4d4af626e2e1c411b330da04c6f11f7e46e8ae99551ef63f679b5f51ad1c0d57f9d059e5bfe8c62b429e45eb0477a3fefb5143cf671400bd040a9b2935436c6c511e2b65db290885f4f4e1eb8af648d1eea22c0c3fd52916d7f30d70293e1cc8fb001271d5ff445b336d0731815e7afcf030e9fa3f0b142dc5fcce2651696564e0e1ddefec8ceaf47133e89babaacaf285a4ef67a1de405bd0284b88eef710dbfe74275cf0a280e56c9b04f3c269ee03148069837f0d71cc7f6892a2fd34fce8ca1d56776ffc5110d789d5e4720b6bbf3e52d35e1b59566a0007266a03315f0069348d2c32e54210c41ef32ee2023dcc047ef5f5d6d4967d74d82dfad25752dbffbefd56a7d125fcbbe5b7ac28e1ec2827a9b315ae81a635316f85f11f33350c9476e5fe6eb12992f53495b1fa86d552c61d9758fd5f914916df6dbf4bf63082b2a5724601f09f15b9f72bdd4cc1fd865d427cdab27fdb93299813f18c22fe57e8c0246bcff8b872f315f62f5ff5066f926e3003a469324d4e5ded88c39e7a5100a37dd235e4d96cf0610f87ece75ccdae6d7d5fe6c020a81e7ecac20f256c1bef1cf62633b6b023ca6346acc190fab4ad09619c8be66eade852b3be9e31ab9e7454d0cac5535a21653998241debba76c5e7bd642469b6b2127bb09e3e9ebed272e0f6368a63dd5a7320d7f248dbec5fec972930c32d6830530e22eb6ce604db0c9ace2776d9da7ead3f6dd2a70d8d69ea3d1e390edc708e0922745e2160d12e0a2e866af0ef6411f4440367d5681a177855c4e982eaee1e4c802bc4490ae22d5fd252abbcc25733ec2e02be214ef4d627334ea9fe6c1f66b60e7a7606fad981d419c33c4d7215527dffc555f7f653a060074b51a9ac40420ab189fe4954edf1aae4ce5451f1946ec8366026f5c829c1103b44fe646f7af1c1f924b7bde3756f1a54ad4854cc4ff25c4a27ba690d1a34a42c8fd6a260fd945d562a0b8899a0c091d7ac2df63297e63d1b2adb79bc06f21d63afd6d3e00874cfcf0ad9d43bdba753122f645120c3febf57fda59212b7d74f2a81146f5c7664a31b3b543ebfdbbadf4ce503bf81700aa39a64c2f0ae03303917f99555eb48fc8c6cd152eebbb7793dc238656b0db612b4da2ce0b63c52f26d81969ffe02ae08d177f6757fe41e33bac125563ca410b4e02102c1c5ce7bb62713f379a1c694dc53d908b7caebd761da06c9509e1088b306d618850fe093cea774f420e803fc14bbe620df323f37e729c7834b72de638ad3a8a88138dfc7f102eeedfe1c438ac14e819c350a94e52fa430fbf1d0019a2d06280a5a199cfdebf85d03e4dc4223221bef3d48f1147123f28699105e9bf95180e3a66d91adfda5b43cd245438b81f4127feae9a0e0ad4eecd6e31ade9104725514c52c2b8f0c54a7a87cc23bd491c80ab83a94adf611e7ae741f95aa0798985b7263930131a3eceae40a91c68433b5a56a74080e645da443ef7a5084c9b10aaa1079a3f140b8b293960973885fed4e372f30340dc6e4c331535a50944e4c23f77b1d45bdd91b2f9433ca3476bac62502ec9d1ad3a3f8dad8a017b11a58d08a7fcd4f338a3431c7a2ca7a0117e6e741e79d257cd7a84e35505e4396697d2b5e61cc2f66d0e7c031cffe46f6d391f95754f55aa953169bfe26e6750a7afd5160c1586837041487e810369707b97f9dcfeb4df4528f7beaf13c2b83cf1e14f152564a838f281f40ced090f56efa4a1601b3f20e13651fdad62f1bc58748039baff3d66772c0d7b61e5d3b5ba1d750036cc0ad076492d3bd9b86882a3dea46f2a79366406e857ce832767a2eaf6e6ecb8d3a27a56f6c7415a04b9986423fa0718f1f34782ff517111668344c56731ef9613f982a9c5a2987074321baf00e2f40be26bdafe69acf0fbf03e1d661e688713beee6ac3ce5a1a4dbeb823e3d4c2f28393f9a348e806ccb17c105c23d0f950ce76c3047a2311fd40c9e3f47aa6c20c681494ea7613c837ffb4b6b28d002c5ae46dad27065e40edd573fa8d3519a2c74f9030cf2e70add5322f95864a9bcfc43f9cdc3627b0417e7df347d1720f8f69430f7479dd1349be815f296eca8ecf5577b5aa10b28a767b522f782afc1b33120b859c5575c090785bb8c60135c7c954d5b719a08b83327103b5d425efbed13499c18c824b0d81e990c114f1398649403f647d9d3fdbb0fc047a52396ae3bda4cd7ee9cade1c06143037fb6aca062fd4444ea266e872ebcbbcfd3653cef67e37dafbd189cbd07b55374b5ae1c4314c015ebff64fb09d6233f54d1aa7a0ffc6658d120754ee2a11f34cda2a49f07773982180b927d27929d37dfbba7205997947a10b5100246ae2f153b2e784c04f3d08bdef4113f8823461f913eafb51bc7f4ca53d1c1ff5a21888e657d63b7da90010a95a9eb089a3c299a5c41f661ba8ce0ba5162e80feb0570594c20448637dda2f104e9c4d551c2ae680568c91ff80c66f8ff0881b7c632f326cbc89992a28933a3bd6548020e8ef0f40ce16774353baa914e76afdebf2b078c5bdf4f39ea46937c152a9456ab1a4fc2f907f8d793a46e3d15859d0d22d1c57acb8a46efb24f33e64aa65837c00acf266724cc7ac41e0b73f8a86d43e7c1d77a8a2d5a972922685bea2fdd44d939782a421fea950b0f3e249a7f8eebccc1c57db96cb5fae8170dea4c2b8584f20287004d98a906adf408a9f0c06561a13e5e6e837d39d750407af974485c1fbed6682f17b925f81d852474609d6403c9b620c7cab2ea82545e4c4df41bf6726fc444bbe51dc5e6cc9f16e5dfb35595234d48177018e33f820390359c3af83d3b6a933a5ff8d71745685ae2a4dcbd24bd63ffb095123a5624069bb92eaaba51fb865875d496002dc5f9698fc0850e96a3985a7d003153f6df7de276979053032bdde131c79f2b7bc8c2695df7783d2c97a76c39881cf318661b4a5e6f3559917c79fbca787ed68808cf08b94b6fe3e30c7e8910745adf8c4c97866f9ffe68011f33a227f6589c107512b1ed030a0c67c39d67dcb5e5620fa8e59d65f1a907e01a3f7b8a0921082edc695687743d8a16d57070814c7a865aec426e80c4c54a485b2159bb3b678f2625c0e740b0e7ea697a4f721d5030cef31bb7d1767dc348de5999afdb465034b6b9fd3901f6122cd7809d7b78fecf720c7489d781f15f361539247a37c9f0bb5116bd3d004262228745cc54e3032c52473e95146229f101156d92ea69cef14ca970df5ae1a31897522b41ac02cca9a552fb0723503be689f0bdbe81edad8bb9cf93019a141385818315be72170fc90dccb32d808b1ba935e5cbf800c8d845e85fa6f6037ef680de4cefdfc04c6f5a2f72126311b4fea812e79166e17236a6e873e90d501ec272df31075592afb0ad286ebb5853ccdb21832898fe81576b390d8fa741b3039e23df922ffb871cf8f22a043b7bfc8c55a42dd932bce9a8c655210fac30e98c0aa3c1c8f84e9ba53b3f1de500db304fccd5127bb386cf523842f71dcca11e797fa799e34fd4482ada34c3a50234aa596bdd426ffee058240a672bdf8cdefb54419d7d1c0dc9ced91c9008523935afd05df27d185d25a121f3d6673131eb4e2823a4149dcc48b55213934bbd998d083bcb4e0fb8ab90ce3477f27746dc07065f4f33eead0a079138a671ac2bdb4c012f9aabc869d07a7452055ae8bf32603c4d18aeaefd36ec5ad2beb92f1eae1d986b7c49b17d980754c40c158607544f58ba9daf2fc9b9cb7fe09ee4e48e1e88f5fc570b65ace231d668cea9fae4b5b44f707c878e69394e1a563565f077f2bfa037f8f8b3cf880619c98507c8c95caab77cea15ee17b3f5c217e556a4ecb34e42812c89aafbdacb7c074540f2d94f22471c67178c2d3ad26bab18ef2bd8464271825d4b01284e67bb2ea9285eb8468e45cd0a8ec839dc3a92034a412ceda036a07c5df2e024d24b140dab5fb9565f9543985dec586c832394e76b5b958eb1631b6d1189e66d6014d5f0b859ab3946bb9cb2e7501d833445e3e6d6003687b97c2e71d875a0644a39ff6a0a454b149598171f09ccf38ce32ee11be13b9a9965e800d860830db032d548139f1b938ac1007985417212bda811f2867c6229a3e02f635d6baa11f7e3062cfa89ed881cdec2f50be0871efa78f611d9713b089698a3dfc9b1d18780052ac215b79c9f8d079d339fa0e81147b77dc17a77ee8b53a35285c30a925235bb25cccbbac6ca2cba9652a95add9ce16fa484ecb75a579ab5299d612238ac61cfa35d87dd983b8a42cfe138c3f2f5344072e1e0e0b517d51335e602803280ad392339f04635c0c68d7912f7a133e71dec38f108a5052fe87211a35df9d680d60f3b7beb037b72fde003470f4c6e4afcebf4dd04f5406a4b713dabb9c048cfd17008b3ec86f81326f8632b832c91626de6f2fa4724e1fbc7303b2919d3c595b8aa1a38eb6466ed9498d7a3fc0b58bf456daf858ce301f7528705e5a2091d885ddb720df7823c86e9d36048da608309582efa12df930c5cb416ceabe6070f47414055a5520324f3e8145905d66534e33c4a48e3c5a4c2e7257dde52323fa73a6fc51dc168e5243aeb7b0bb80c7e49da029ecca0f64e1dff2775b8b1162113f792307314b1be9e83dbd32729bfdfd3b834e06f4cb2ebcc997e6e123964d654aab0c7ff445c3cbd8ee2643d11d7d4090489ea8db720e037c5e0d16deced02a9bf9f0d83dfbe1e9aadd57b4f2a8d483d510346e83076be9b9e1fb29358d50b26ac52420754a4f860110f960fd4857f94102372470eb2f4e726a851bd8ad72f0355d736a29835fece63386e4ca7170ebd572f52dc18bdfe0bedf0a97564a4e7708b81edf884dcf7a91d4d1848a04ac10151f98885057486565b5982e5fac15bf629c4a236619207eb0038a01c3f3e70c8bbca5de2075f291720402c3d86d040e075b304aa8e708aceb525ce39f14302dce491454e2894236c7ca5141ef89f22cb8b895fedcfca44acbdbab77a8f91468e79681dda9c4ed0c480cd3133f2a01fa93727f702fe968053cfcfc4df6502881014a0f5591da820f27d0fe9b1aa5a371bd35c45a62c38712cdda1004714ae4c8b6a447ef3b809edb6d71ede6b4523d271c639e0df013ff183ca7c519780d25dc32a4d0b6f8625cbb2093ca383fd3c8230575438d950a7c4c3b694617462bd98757a654ec723d0cb65e7e512c08727eee1bded15bfc0eddeeee95165b8d22449a5383ba3b52a108f62c8320f6b3f0bad075a0f9e9f192692d00cc85c8dc1849040d5890f451aa47654f824fdc8dbce45eada912d3b9325cf56d0caf62de6a0aeb64d24f7a24017b91b3fad51abe0f44f734979ed6781d3632c000b33f5b175a1c957b921bcd293682936ef995f2222e53065f75550390be0561fecf02844cadcd4664c9c365a97edf8d52c733020bf1d4ac86eb902ae83af12d459cb2c4d6d42a0cffea413b23cff5c6fa1bb4f98977479481d87229cd10972a57ae37e452cbcc52bc71c6a18b72a0877265395f67222fc0f99ee4be7b014e769355f1eef14428470cc8e9ffd5b7f6d56af93b345d26bff82abe59fcfa492c3ec1e87d47061521c11f72126d2637e2feb6212691f07d3d28da48929dbdc92f19dce6c1d5a987ea1fc8490817da7791462c97448c1634e4fc53582cfcdabe8a7972c051ae120b9c7b2a4ef1f404f21507f437e8a72c5468c6f9263c659bebce5b9e997fed850a893ebfe93fa51ceac3806ebc8c05fea920d0c872852f13006460bc635d2165805eb2b75379456d36de29b3d8b20f707d5dcc99f64f005e0f988694203ebc955af71d5b8eaf1853782041fecff3e2123febb37a30692bacf37bfe7b71237516a5bf8884b90e78ab4ddac59dffd8e8c507ca03127e02fbb1b8cae6ee8211985d223b0af44b30526e35069ff50071a6ed863b4e53aa63bd2ae54ae2caca79cae81a25933dc8948fda0a2f6ccc1c690f3781e4ca7220f26ddfe76ec1a1c917a90ee016c7862a8045cc90dc683052a92195d7b5a8269ea8a34f442ba60dbffbe74ac304a92a597568beaeb0f807cc27e23e7872446d95c665df26a07b6a54d0988aadb4cdcdfd4ab608bc0cfa7bab5081b5449e9803882eeeb930e3e8e6c2fd99140df967e1edf49f7649e414575f21e86dc2e6f96faf17fd66a57c7c03ac1cc564683521027f3198c748171865f5d929bbb55dfbd74e85c3a889cd25f1eee3135591983aaafcdefde26ac0dd9ff8303b220bf4b9cfb3e39720b29f18b08221f7442174951665411a2c7ee779ec0897cc7325b104a223e3b60780b6383bbd5b80c330237f2c6c93290b7c0bf795f08ebdcdaf2d1358e8ea1c94b4a0051d4f78c7e809f106ca0501b23cfe5be97c0396a8c74a9de8b24b77f67f2a5d9945cffd2375f5e89eba0a0891c8d96ccf0069508a65ae29d3b1fdb9daa62d0a2965ec43fde7f05a78a7c96192b62512b7f8640b96ca5bbf943fd5746e4a9f7979e56f7f4f7cf5bad4a2a7eb67eab89ab1d27ff6810eeeb5a36d13a986eb950046c8d73d97599c59da8ece6de8706069cb10a8d7bf6c30224f6770a89a0a6a6107079998490ade148cf779ad0feef6605a008f4dadb64d5446ca7f8f6f27880117c7f224ab36215ecf8ab0ba74d77af1547c4e139ed7e241bd9dffaf3da70c71eb29158c0746e285257f15b21e65225d74fda75d013df11c98ca471b5e1ddf72624a589cb3a2827044d42cfff6e59c7eff1acce56fb551c7aabe495ea1b3f305543bbb372fc61a16500e8e250c0afc0583eb37b79fc980c71093abc6ef02ffb108bd514eda3610f10d9c6df3d72e7e0e33ea00174ea0d77b15210b7cb14de4485f34d15091a74d4ff91740045890afaf0096c47efaa08a3ef38794039cceb55e2df662446c060c73a5fce3488ab9b5bb69860f52e71d7c49efa1ad8cfaca82e4704f02a0342b99c8002d68e4a87295376d4e2e9db2b9733a48175e1b39748be6c51103d160949fab15c737677ad4c0952e705479a3449eb658303bddf4eb57d40d4f3194ee9deefbb9588188cd187d4b5b3f28a9c93d9cc30ce2f9b9b17f1c195df53a842c279b8297e8b34f34ec409170f3be72cb6ad7d7c7460f20625b39252bc41fdc803437b368714ba4b2c36906babd542a5657b1c0fa83b31a418e02fe26f227a9d64b244d8caec19aaf2dcdcde01732536be1d02117fba3f3c3d6f4cbfc477ac4d5187908a46a6133eea0e97727dd39caa23555c4e30d2f520efba6a2b301421e29957c2b14ceab87540c48ce3350b4751e1387225722c9f29d046cc7228aaf86723aaaf926fe5f528f98aab5d0ce43bd4c180ca539e86f71d2900270557ec30b28bccac61fee6e9e1444e2c8c947f7f00dbbe4b145a5fb617139ea33e41613aa4af5cff630035c3c35a37bbf96dace6ecf4bdab731ceb91616a15b2dec50c4a416d381c0aae56e45cae3cfec73cab509326518ffab2e1804e98e1c0e3e0f86ac900d30ce64f40343e925323828ddb525ff4c2f12b1eb4860ce502b00f97b6307fac157fdb64a7fd69748db4a57e6e379581f66cc85d7630bef15380f59e77baa93a7f18096d6461e224a640a8c83621d76dcdbb76a39ea885c3ac7966dbb19648af9e898a001b317ddcb831e93bebafcde92e742fd12a8413fd8ebdb48089e2ad2ae584f82d00fab7a3baa4b3c44ee7b634c70f1767b7bd46559a95c647d85819d2fdef343c27619935f60e60e6494664229f8372b2b815bd6f441ab1034b770813294f1b4fac4779d63a4f01ca2dd167ebc2bd0b553cf3b9b155d07f743e360a1d830a18a949580178023a85e3c33ed9d1ceace6f935de1b1d1fa055cb34abed447fc62888fb371081f3795d65fb8b90c187f03e42f8edf04916665662c92cd39099725ea76428d3011cb2d5b379496bb67c097b5ac22163641c3d6d6c02d76dc5e7bafde3f24218a1aaf4a1bd82b5a0674072406a0c464ee5dbb1bc54dec26f18ffcd875db118ab5759a4c781857d80cc9bfd0f454264fa202945e8a398e0e8bcf4c7c892aac5904fd4dff304b54da5fe9fef94f61ede3f37ef3b6a9892f5fcd72da3933b453423e5a007fc30bf97c87967b816785fe25dd4eef87f57943aa3994373f0667139d411ad25799276ae3a1da5e54ab9ea1b5f60caa7441d916cd146da5af5d7422d1faf111ed489866d0230c4bc5b1cd9de7f061994e25c5b59a0580dd02af961fe54fb003c54faa6ed5b51bb221c379e31c98714d85bc5b2df3f47fa93b01baa8067eee084f1eff2c6ea64d45048a0edae1e358a73a27bc293043cc9b4e0cec3ecfb29f6aa12d7f32eaa3d75f092e786c2a738b8fdd6ebf62316773ff1c5a535fd06133014677be929a3399724d7dfd8fe39521366a91f20ddfa73b9d317d5c57dcead445a4acb234fbfcbcaab5cfcafb2bd44d990ba476d3910e022901edf579316253f29c9066a509d7c02c9619b1eab72464f2d562778462231984254c2841d2c68c671e2777a0acb23a85dcdc97ebdb5a7ec870390f45fca4a5f8adfbffde21cdb78506c74b3ce4597b7e4857dfffa543b7340d03fd05c1b3ee8c002ae3a3dc78b52b668bea11a5f8b53155fa8f68bf6680c0f0948475e14cd95e396b833de87a8087db8eb48d3b586adbead080508cd372562c5f74e2a038a5bd56b0bb94db51f492d1b74625e9a8cbac156c6a0cb04207a1811cf68a915a1e33f9a78db71ab3b2490174c4c369bdaba1a75fe41d571ad1387dd23f9286e0ef86efd1e67d3e5ecdb5b533d5c2efff1f8a554d6017d05b674cfa8fad0f9932cafcd7d2a89b29a835a592b5735a0b1cbb506649e439bd6f3afc4cd4abab9d37db60badab51dcfb82c5e4473bf568f3463bb1429f759795867bd951d2ae4f315d0f97f76faaeab09610985025646f3b23a0943c34d67071c2bdd87e8f601f106ad8d941216b3c3382ca2efcbffc25d19bc2c773a40b4c5a9f26d9a86b326405db8c277c261f6d6da396721cc9f20c1360bd2fcefd19c29a8b080c2d75f30246354d8ddbcbb53f590f4687294c85955c47494de753d60699bd57908743642c268a4647f89e8d814ffeeea657ac2376a27fceccb1bf6ed22f3bac7cdca228edd1a4efed1594831cfcb15c57d1bda9f8f49772a3873edeb0a5e67baf612fa6dccf0d9bf6bd2e46385a87e2767e1275606cefc880da895be86065346ee0f9592e3a438b8855245aadc340e0b4d982578c3526742e1c6faaf44841cc29678dc132a9a888e70819fd0110f822df8c828e943c2882360abd631927f012929ea2d5efd13d18758b27ae1224fecd597d42662515b8733238242d67a82192f077658d2e574d84d0f33114499684136c903f598f3fe0d14faf7c03ba66505a63505eb11c2ed4cb9d6f9a7a5bdc7239d2726d7c302a2c46d4a35a88afc9711d088a0d1561deb10e9b2b2410d5d2c631fd8fe78c19952d35c4dcdebf07414ac4d414e961dfc25c8cf4149f17be3cb014ef1d960634186afeed7d04dcd6c7434330d0d6a8b8fc90e78087e8a07b524cea4cad0f0cb93ba56af0ea6a9863d6fe6b83a66499f031b2ba3f5cf8c20d699f5e1ff09dc15a651eb37191c4c5a7740f4345576f763d6d127edfc09712e40f20a6cc61538d5b242ae0a3081af8bfbbed1b9b6041650b3db383b722f18ec7f493da7f572a53bd4eb9da9727764c5155082a336afb82252db41eff9bebccfe8f8f43f80bce8c7be6304ebd19d9da986816545e1847757faa1e6d69e43fcb749f935411236a653ad8af15316d73c4462be5843b0ac13ab45f50ccb73736b4c0ad1aa796bb41a1c1023d86c58beda9e4d4b39045f126cc80200f9cf260992198440f3ff8d9c9a5be464c86be9fbb37475b3e1411d7ed1d1b0858b423adb154d009bf3d3a2e0873682d97252f4b9f19dc464fe28d9e71d0deecc1abebaf757fc5460af92feb70d5047230f0c604024b37431c7a1567708adf441dac50a2eaceb9cb241d8916f4da7ad313b9b9cb64eebfca48ed9f277cfb0d58ef6817aaf2da0054cc97f2329a421efe14cd4219b5576723976fef0d0aad40fbfbbbe01052ab6a6010755e5029f23b002436c4c438b047459dab65797fbc1115e85139f4d1a287b9ddf13023d54ba95296c1dec17172c31ad218dc8c48d66c581468cbfe1027955b8c88e2dd208ac27427c95cdb7200a60b4d4863adfc955bc6731a92643af230fad82a56e6d016025d0c3f7bac88940307f35fdd69859d14dcaeb8e6585d46ada5eff10c262e04f132c526747f0cf0d391f28a65ce7914c543ba6cfd9f043c6ae772081d6e2da09c2809bb60cc5d8797a479ad778d96b69f9b02b2d20b18d102097cfbe79d270fb241f5aa3815c6f0a35596a7ff77bac76432d0a49e78349b521f238ca77ff3e6f563512edd681533bf6c67c11f0fad9d9678e1bf187e694c59d07a1e375024bdaac60543112e1932949ead56d74e18a48c94523febdeedd2332a63eb7b0780074442410a1b7f9854265ceb43ef363cf73e4f2f2996cfad37065031f2a18109830628c7d751065749c74488e60c8e02bbc721255dbb4496137f7ec4bdb5d4263943a4bb9316009143af5c20afc2bc6349fdbb2a847cd94066b1366395f8a49dcd45ec40d414491de8b7511cbfaea85d014dab86054bf207f5ae1a4c5fae74ffe54fe07669ee4c56d44c1f5a6b3733b29340d43eee99a449b87071a1ef8d91d68d4c2f5ae706832c7fbac6b262bccbcf63b32d870ba59b7c0571163fbb7878bfe383afbdcc49955f43d60f836d5d6e7f72e9d2e0e4d1ddb4add43b8ac2c699df07e8424eb2c4eaef843bf95cb89d21efc2e49b4bd6e22e783291207516d9403068eef1521f61602a74669674c8eae062d84c80d176b329f8103fb0292c268c9dd67881e7c7edf1cc9270a018841ab47f0d112fb811480c019b71f40ab4f2754ae10a2cba2d905d9de2eaa4172a5159ff27896206f8205714309737ed34132dff1ca55975613d60aa01bc3a35fa8f2615cc44beb83dc2b60255548fec49ee69e0cf0019789ae6d38a2f3381e1e539914f57c8790c2d279ee617fee14f36459c194256587a972b1bdf50e07feeb021316dda37e8da531dd9debf6655478306d93c0877a376719920ea315516dd69e66dc3018437e1f659c3516c43b6d1119d2343b703d07c09aa6b631e3e7fa450fbe6310a3735579fedc6b2e75a45a9ff835d6648fe5bc59e9c6a27babc560dce9dad5b6621108cca9faf5a1383948791770ff999e3dbeb2c8fb49d2a75e498d7fff695e014b2a8eea86f92a4326462e5cfb3e29adf85ad2ddf76b556d8f98945f7743600504a185f7af8f7f121a8b5d6755610639b1f3c6cbd9f48a3133e0244df4e39b6e8dc47e86d7aab2a6c2df22b546e05f55b0a735e6ef3934a8b60bf6e6789d94daa8a9204756c57079a23934e2c56684634d1192a533d0e58b2a91509f3d536b57fa277a2d55d7ebf1fc11ff14bcb5e97291ec81dd98e050ffd811504fc972ba1616a15340763c376307fdfd314133fc00ce6979d69ec81712e5b6dfb9eeca19c2b84bdc8d5998105431c972dcf31d90c1f6f9e966a70e5611323dad792f60c71a4f417e00d66bb41b923f6e742d6afe8e921846b62cbffb6fddb2bddaa77ff57d05b584828eb508aa409ce0058c47ad457e103eb34f8baf748cac9308e7233d5ce1a05d5145fae870ad4b8d83867a138a2db6ea35914d7a95e68a50bb67eda97ac0ea8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4290edf5ab9c348d0d7d0b9e329b1e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
